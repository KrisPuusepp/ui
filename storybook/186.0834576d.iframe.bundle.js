"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[186],{"./node_modules/@pixi/assets/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{de:()=>Assets,Q2:()=>LoaderParserPriority,uz:()=>copySearchParams});var lib=__webpack_require__("./node_modules/@pixi/core/lib/index.mjs");const assetKeyMap={loader:lib.nw.LoadParser,resolver:lib.nw.ResolveParser,cache:lib.nw.CacheParser,detection:lib.nw.DetectionParser};lib.Rw.handle(lib.nw.Asset,(extension=>{const ref=extension.ref;Object.entries(assetKeyMap).filter((([key])=>!!ref[key])).forEach((([key,type])=>lib.Rw.add(Object.assign(ref[key],{extension:ref[key].extension??type}))))}),(extension=>{const ref=extension.ref;Object.keys(assetKeyMap).filter((key=>!!ref[key])).forEach((key=>lib.Rw.remove(ref[key])))}));class BackgroundLoader{constructor(loader,verbose=!1){this._loader=loader,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=verbose}add(assetUrls){assetUrls.forEach((a=>{this._assetList.push(a)})),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const toLoad=[],toLoadAmount=Math.min(this._assetList.length,this._maxConcurrent);for(let i=0;i<toLoadAmount;i++)toLoad.push(this._assetList.pop());await this._loader.load(toLoad),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(value){this._isActive!==value&&(this._isActive=value,value&&!this._isLoading&&this._next())}}function checkExtension(url,extension){const tempURL=url.split("?")[0],ext=lib.P6.path.extname(tempURL).toLowerCase();return Array.isArray(extension)?extension.includes(ext):ext===extension}const convertToList=(input,transform,forceTransform=!1)=>(Array.isArray(input)||(input=[input]),transform?input.map((item=>"string"==typeof item||forceTransform?transform(item):item)):input);const Cache=new class CacheClass{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(key){return this._cache.has(key)}get(key){const result=this._cache.get(key);return result||console.warn(`[Assets] Asset id ${key} was not found in the Cache`),result}set(key,value){const keys=convertToList(key);let cacheableAssets;for(let i=0;i<this.parsers.length;i++){const parser=this.parsers[i];if(parser.test(value)){cacheableAssets=parser.getCacheableAssets(keys,value);break}}cacheableAssets||(cacheableAssets={},keys.forEach((key2=>{cacheableAssets[key2]=value})));const cacheKeys=Object.keys(cacheableAssets),cachedAssets={cacheKeys,keys};if(keys.forEach((key2=>{this._cacheMap.set(key2,cachedAssets)})),cacheKeys.forEach((key2=>{this._cache.has(key2)&&this._cache.get(key2)!==value&&console.warn("[Cache] already has key:",key2),this._cache.set(key2,cacheableAssets[key2])})),value instanceof lib.xE){const texture=value;keys.forEach((key2=>{texture.baseTexture!==lib.xE.EMPTY.baseTexture&&lib.VL.addToCache(texture.baseTexture,key2),lib.xE.addToCache(texture,key2)}))}}remove(key){if(!this._cacheMap.has(key))return void console.warn(`[Assets] Asset id ${key} was not found in the Cache`);const cacheMap=this._cacheMap.get(key);cacheMap.cacheKeys.forEach((key2=>{this._cache.delete(key2)})),cacheMap.keys.forEach((key2=>{this._cacheMap.delete(key2)}))}get parsers(){return this._parsers}},isSingleItem=item=>!Array.isArray(item);class Loader{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(target,key,value)=>(this._parsersValidated=!1,target[key]=value,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(url,data){const result={promise:null,parser:null};return result.promise=(async()=>{let asset=null,parser=null;if(data.loadParser&&(parser=this._parserHash[data.loadParser],parser||console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`)),!parser){for(let i=0;i<this.parsers.length;i++){const parserX=this.parsers[i];if(parserX.load&&parserX.test?.(url,data,this)){parser=parserX;break}}if(!parser)return console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}asset=await parser.load(url,data,this),result.parser=parser;for(let i=0;i<this.parsers.length;i++){const parser2=this.parsers[i];parser2.parse&&parser2.parse&&await(parser2.testParse?.(asset,data,this))&&(asset=await parser2.parse(asset,data,this)||asset,result.parser=parser2)}return asset})(),result}async load(assetsToLoadIn,onProgress){this._parsersValidated||this._validateParsers();let count=0;const assets={},singleAsset=isSingleItem(assetsToLoadIn),assetsToLoad=convertToList(assetsToLoadIn,(item=>({alias:[item],src:item}))),total=assetsToLoad.length,promises=assetsToLoad.map((async asset=>{const url=lib.P6.path.toAbsolute(asset.src);if(!assets[asset.src])try{this.promiseCache[url]||(this.promiseCache[url]=this._getLoadPromiseAndParser(url,asset)),assets[asset.src]=await this.promiseCache[url].promise,onProgress&&onProgress(++count/total)}catch(e){throw delete this.promiseCache[url],delete assets[asset.src],new Error(`[Loader.load] Failed to load ${url}.\n${e}`)}}));return await Promise.all(promises),singleAsset?assets[assetsToLoad[0].src]:assets}async unload(assetsToUnloadIn){const promises=convertToList(assetsToUnloadIn,(item=>({alias:[item],src:item}))).map((async asset=>{const url=lib.P6.path.toAbsolute(asset.src),loadPromise=this.promiseCache[url];if(loadPromise){const loadedAsset=await loadPromise.promise;delete this.promiseCache[url],loadPromise.parser?.unload?.(loadedAsset,asset,this)}}));await Promise.all(promises)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter((parser=>parser.name)).reduce(((hash,parser)=>(hash[parser.name]&&console.warn(`[Assets] loadParser name conflict "${parser.name}"`),{...hash,[parser.name]:parser})),{})}}var LoaderParserPriority=(LoaderParserPriority2=>(LoaderParserPriority2[LoaderParserPriority2.Low=0]="Low",LoaderParserPriority2[LoaderParserPriority2.Normal=1]="Normal",LoaderParserPriority2[LoaderParserPriority2.High=2]="High",LoaderParserPriority2))(LoaderParserPriority||{});function checkDataUrl(url,mimes){if(Array.isArray(mimes)){for(const mime of mimes)if(url.startsWith(`data:${mime}`))return!0;return!1}return url.startsWith(`data:${mimes}`)}const loadJson={extension:{type:lib.nw.LoadParser,priority:LoaderParserPriority.Low},name:"loadJson",test:url=>checkDataUrl(url,"application/json")||checkExtension(url,".json"),load:async url=>await(await lib.Xd.ADAPTER.fetch(url)).json()};lib.Rw.add(loadJson);const loadTxt={name:"loadTxt",extension:{type:lib.nw.LoadParser,priority:LoaderParserPriority.Low},test:url=>checkDataUrl(url,"text/plain")||checkExtension(url,".txt"),load:async url=>await(await lib.Xd.ADAPTER.fetch(url)).text()};lib.Rw.add(loadTxt);const validWeights=["normal","bold","100","200","300","400","500","600","700","800","900"],validFontExtensions=[".ttf",".otf",".woff",".woff2"],validFontMIMEs=["font/ttf","font/otf","font/woff","font/woff2"],CSS_IDENT_TOKEN_REGEX=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;const loadWebFont={extension:{type:lib.nw.LoadParser,priority:LoaderParserPriority.Low},name:"loadWebFont",test:url=>checkDataUrl(url,validFontMIMEs)||checkExtension(url,validFontExtensions),async load(url,options){const fonts=lib.Xd.ADAPTER.getFontFaceSet();if(fonts){const fontFaces=[],name=options.data?.family??function getFontFamilyName(url){const ext=lib.P6.path.extname(url),nameTokens=lib.P6.path.basename(url,ext).replace(/(-|_)/g," ").toLowerCase().split(" ").map((word=>word.charAt(0).toUpperCase()+word.slice(1)));let valid=nameTokens.length>0;for(const token of nameTokens)if(!token.match(CSS_IDENT_TOKEN_REGEX)){valid=!1;break}let fontFamilyName=nameTokens.join(" ");return valid||(fontFamilyName=`"${fontFamilyName.replace(/[\\"]/g,"\\$&")}"`),fontFamilyName}(url),weights=options.data?.weights?.filter((weight=>validWeights.includes(weight)))??["normal"],data=options.data??{};for(let i=0;i<weights.length;i++){const weight=weights[i],font=new FontFace(name,`url(${encodeURI(url)})`,{...data,weight});await font.load(),fonts.add(font),fontFaces.push(font)}return 1===fontFaces.length?fontFaces[0]:fontFaces}return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(font){(Array.isArray(font)?font:[font]).forEach((t=>lib.Xd.ADAPTER.getFontFaceSet().delete(t)))}};lib.Rw.add(loadWebFont);let MAX_WORKERS,UUID=0;const checkImageBitmapCode={id:"checkImageBitmap",code:"\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== 'function') return false;\n\n            const response = await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    "},workerCode={id:"loadImageBitmap",code:"\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: `\n                + `${response.status} ${response.statusText}`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };"};let workerURL;const WorkerManager=new class WorkerManagerClass{constructor(){this._initialized=!1,this._createdWorkers=0,this.workerPool=[],this.queue=[],this.resolveHash={}}isImageBitmapSupported(){return void 0!==this._isImageBitmapSupported||(this._isImageBitmapSupported=new Promise((resolve=>{const workerURL2=URL.createObjectURL(new Blob([checkImageBitmapCode.code],{type:"application/javascript"})),worker=new Worker(workerURL2);worker.addEventListener("message",(event=>{worker.terminate(),URL.revokeObjectURL(workerURL2),resolve(event.data)}))}))),this._isImageBitmapSupported}loadImageBitmap(src){return this._run("loadImageBitmap",[src])}async _initWorkers(){this._initialized||(this._initialized=!0)}getWorker(){void 0===MAX_WORKERS&&(MAX_WORKERS=navigator.hardwareConcurrency||4);let worker=this.workerPool.pop();return!worker&&this._createdWorkers<MAX_WORKERS&&(workerURL||(workerURL=URL.createObjectURL(new Blob([workerCode.code],{type:"application/javascript"}))),this._createdWorkers++,worker=new Worker(workerURL),worker.addEventListener("message",(event=>{this.complete(event.data),this.returnWorker(event.target),this.next()}))),worker}returnWorker(worker){this.workerPool.push(worker)}complete(data){void 0!==data.error?this.resolveHash[data.uuid].reject(data.error):this.resolveHash[data.uuid].resolve(data.data),this.resolveHash[data.uuid]=null}async _run(id,args){await this._initWorkers();const promise=new Promise(((resolve,reject)=>{this.queue.push({id,arguments:args,resolve,reject})}));return this.next(),promise}next(){if(!this.queue.length)return;const worker=this.getWorker();if(!worker)return;const toDo=this.queue.pop(),id=toDo.id;this.resolveHash[UUID]={resolve:toDo.resolve,reject:toDo.reject},worker.postMessage({data:toDo.arguments,uuid:UUID++,id})}};function createTexture(base,loader,url){base.resource.internal=!0;const texture=new lib.xE(base),unload=()=>{delete loader.promiseCache[url],Cache.has(url)&&Cache.remove(url)};return texture.baseTexture.once("destroyed",(()=>{url in loader.promiseCache&&(console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."),unload())})),texture.once("destroyed",(()=>{base.destroyed||(console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),unload())})),texture}const validImageExtensions=[".jpeg",".jpg",".png",".webp",".avif"],validImageMIMEs=["image/jpeg","image/png","image/webp","image/avif"];const loadTextures={name:"loadTextures",extension:{type:lib.nw.LoadParser,priority:LoaderParserPriority.High},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test:url=>checkDataUrl(url,validImageMIMEs)||checkExtension(url,validImageExtensions),async load(url,asset,loader){const useImageBitmap=globalThis.createImageBitmap&&this.config.preferCreateImageBitmap;let src;src=useImageBitmap?this.config.preferWorkers&&await WorkerManager.isImageBitmapSupported()?await WorkerManager.loadImageBitmap(url):await async function loadImageBitmap(url){const response=await lib.Xd.ADAPTER.fetch(url);if(!response.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);const imageBlob=await response.blob();return await createImageBitmap(imageBlob)}(url):await new Promise(((resolve,reject)=>{const src2=new Image;src2.crossOrigin=this.config.crossOrigin,src2.src=url,src2.complete?resolve(src2):(src2.onload=()=>resolve(src2),src2.onerror=e=>reject(e))}));const options={...asset.data};options.resolution??(options.resolution=lib.P6.getResolutionOfUrl(url)),useImageBitmap&&void 0===options.resourceOptions?.ownsImageBitmap&&(options.resourceOptions={...options.resourceOptions},options.resourceOptions.ownsImageBitmap=!0);const base=new lib.VL(src,options);return base.resource.src=url,createTexture(base,loader,url)},unload(texture){texture.destroy(!0)}};lib.Rw.add(loadTextures);const loadSVG={extension:{type:lib.nw.LoadParser,priority:LoaderParserPriority.High},name:"loadSVG",test:url=>checkDataUrl(url,"image/svg+xml")||checkExtension(url,".svg"),testParse:async data=>lib.pX.test(data),async parse(asset,data,loader){const src=new lib.pX(asset,data?.data?.resourceOptions);await src.load();const base=new lib.VL(src,{resolution:lib.P6.getResolutionOfUrl(asset),...data?.data});return base.resource.src=data.src,createTexture(base,loader,data.src)},load:async(url,_options)=>(await lib.Xd.ADAPTER.fetch(url)).text(),unload:loadTextures.unload};lib.Rw.add(loadSVG);const validVideoExtensions=[".mp4",".m4v",".webm",".ogv"],validVideoMIMEs=["video/mp4","video/webm","video/ogg"],loadVideo={name:"loadVideo",extension:{type:lib.nw.LoadParser,priority:LoaderParserPriority.High},config:{defaultAutoPlay:!0},test:url=>checkDataUrl(url,validVideoMIMEs)||checkExtension(url,validVideoExtensions),async load(url,loadAsset,loader){let texture;const blob=await(await lib.Xd.ADAPTER.fetch(url)).blob(),blobURL=URL.createObjectURL(blob);try{const options={autoPlay:this.config.defaultAutoPlay,...loadAsset?.data?.resourceOptions},src=new lib.eH(blobURL,options);await src.load();const base=new lib.VL(src,{alphaMode:await lib.P6.detectVideoAlphaMode(),resolution:lib.P6.getResolutionOfUrl(url),...loadAsset?.data});base.resource.src=url,texture=createTexture(base,loader,url),texture.baseTexture.once("destroyed",(()=>{URL.revokeObjectURL(blobURL)}))}catch(e){throw URL.revokeObjectURL(blobURL),e}return texture},unload(texture){texture.destroy(!0)}};function processX(base,ids,depth,result,tags){const id=ids[depth];for(let i=0;i<id.length;i++){const value=id[i];depth<ids.length-1?processX(base.replace(result[depth],value),ids,depth+1,result,tags):tags.push(base.replace(result[depth],value))}}function createStringVariations(string){const result=string.match(/\{(.*?)\}/g),tags=[];if(result){const ids=[];result.forEach((vars=>{const split=vars.substring(1,vars.length-1).split(",");ids.push(split)})),processX(string,ids,0,result,tags)}else tags.push(string);return tags}lib.Rw.add(loadVideo);class Resolver{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(bundleId,assetId)=>`${bundleId}${this._bundleIdConnector}${assetId}`,extractAssetIdFromBundle:(bundleId,assetBundleId)=>assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(bundleIdentifier){if(this._bundleIdConnector=bundleIdentifier.connector??this._bundleIdConnector,this._createBundleAssetId=bundleIdentifier.createBundleAssetId??this._createBundleAssetId,this._extractAssetIdFromBundle=bundleIdentifier.extractAssetIdFromBundle??this._extractAssetIdFromBundle,"bar"!==this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar")))throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...preferOrders){preferOrders.forEach((prefer=>{this._preferredOrder.push(prefer),prefer.priority||(prefer.priority=Object.keys(prefer.params))})),this._resolverHash={}}set basePath(basePath){this._basePath=basePath}get basePath(){return this._basePath}set rootPath(rootPath){this._rootPath=rootPath}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(searchParams){if("string"==typeof searchParams)this._defaultSearchParams=searchParams;else{const queryValues=searchParams;this._defaultSearchParams=Object.keys(queryValues).map((key=>`${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)).join("&")}}getAlias(asset){const{alias,name,src,srcs}=asset;return convertToList(alias||name||src||srcs,(value=>"string"==typeof value?value:Array.isArray(value)?value.map((v=>v?.src??v?.srcs??v)):value?.src||value?.srcs?value.src??value.srcs:value),!0)}addManifest(manifest){this._manifest&&console.warn("[Resolver] Manifest already exists, this will be overwritten"),this._manifest=manifest,manifest.bundles.forEach((bundle=>{this.addBundle(bundle.name,bundle.assets)}))}addBundle(bundleId,assets){const assetNames=[];Array.isArray(assets)?assets.forEach((asset=>{const srcs=asset.src??asset.srcs,aliases=asset.alias??asset.name;let ids;if("string"==typeof aliases){const bundleAssetId=this._createBundleAssetId(bundleId,aliases);assetNames.push(bundleAssetId),ids=[aliases,bundleAssetId]}else{const bundleIds=aliases.map((name=>this._createBundleAssetId(bundleId,name)));assetNames.push(...bundleIds),ids=[...aliases,...bundleIds]}this.add({...asset,alias:ids,src:srcs})})):Object.keys(assets).forEach((key=>{const aliases=[key,this._createBundleAssetId(bundleId,key)];if("string"==typeof assets[key])this.add({alias:aliases,src:assets[key]});else if(Array.isArray(assets[key]))this.add({alias:aliases,src:assets[key]});else{const asset=assets[key],assetSrc=asset.src??asset.srcs;this.add({...asset,alias:aliases,src:Array.isArray(assetSrc)?assetSrc:[assetSrc]})}assetNames.push(...aliases)})),this._bundles[bundleId]=assetNames}add(aliases,srcs,data,format,loadParser){const assets=[];let keyCheck;"string"==typeof aliases||Array.isArray(aliases)&&"string"==typeof aliases[0]?(lib.P6.deprecation("7.2.0","Assets.add now uses an object instead of individual parameters.\nPlease use Assets.add({ alias, src, data, format, loadParser }) instead."),assets.push({alias:aliases,src:srcs,data,format,loadParser})):Array.isArray(aliases)?assets.push(...aliases):assets.push(aliases),keyCheck=key=>{this.hasKey(key)&&console.warn(`[Resolver] already has key: ${key} overwriting`)},convertToList(assets).forEach((asset=>{const{src,srcs:srcs2}=asset;let{data:data2,format:format2,loadParser:loadParser2}=asset;const srcsToUse=convertToList(src||srcs2).map((src2=>"string"==typeof src2?createStringVariations(src2):Array.isArray(src2)?src2:[src2])),aliasesToUse=this.getAlias(asset);Array.isArray(aliasesToUse)?aliasesToUse.forEach(keyCheck):keyCheck(aliasesToUse);const resolvedAssets=[];srcsToUse.forEach((srcs3=>{srcs3.forEach((src2=>{let formattedAsset={};if("object"!=typeof src2){formattedAsset.src=src2;for(let i=0;i<this._parsers.length;i++){const parser=this._parsers[i];if(parser.test(src2)){formattedAsset=parser.parse(src2);break}}}else data2=src2.data??data2,format2=src2.format??format2,loadParser2=src2.loadParser??loadParser2,formattedAsset={...formattedAsset,...src2};if(!aliasesToUse)throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);formattedAsset=this.buildResolvedAsset(formattedAsset,{aliases:aliasesToUse,data:data2,format:format2,loadParser:loadParser2}),resolvedAssets.push(formattedAsset)}))})),aliasesToUse.forEach((alias=>{this._assetMap[alias]=resolvedAssets}))}))}resolveBundle(bundleIds){const singleAsset=isSingleItem(bundleIds);bundleIds=convertToList(bundleIds);const out={};return bundleIds.forEach((bundleId=>{const assetNames=this._bundles[bundleId];if(assetNames){const results=this.resolve(assetNames),assets={};for(const key in results){const asset=results[key];assets[this._extractAssetIdFromBundle(bundleId,key)]=asset}out[bundleId]=assets}})),singleAsset?out[bundleIds[0]]:out}resolveUrl(key){const result=this.resolve(key);if("string"!=typeof key){const out={};for(const i in result)out[i]=result[i].src;return out}return result.src}resolve(keys){const singleAsset=isSingleItem(keys);keys=convertToList(keys);const result={};return keys.forEach((key=>{if(!this._resolverHash[key])if(this._assetMap[key]){let assets=this._assetMap[key];const bestAsset=assets[0],preferredOrder=this._getPreferredOrder(assets);preferredOrder?.priority.forEach((priorityKey=>{preferredOrder.params[priorityKey].forEach((value=>{const filteredAssets=assets.filter((asset=>!!asset[priorityKey]&&asset[priorityKey]===value));filteredAssets.length&&(assets=filteredAssets)}))})),this._resolverHash[key]=assets[0]??bestAsset}else this._resolverHash[key]=this.buildResolvedAsset({alias:[key],src:key},{});result[key]=this._resolverHash[key]})),singleAsset?result[keys[0]]:result}hasKey(key){return!!this._assetMap[key]}hasBundle(key){return!!this._bundles[key]}_getPreferredOrder(assets){for(let i=0;i<assets.length;i++){const asset=assets[0],preferred=this._preferredOrder.find((preference=>preference.params.format.includes(asset.format)));if(preferred)return preferred}return this._preferredOrder[0]}_appendDefaultSearchParams(url){if(!this._defaultSearchParams)return url;return`${url}${/\?/.test(url)?"&":"?"}${this._defaultSearchParams}`}buildResolvedAsset(formattedAsset,data){const{aliases,data:assetData,loadParser,format}=data;return(this._basePath||this._rootPath)&&(formattedAsset.src=lib.P6.path.toAbsolute(formattedAsset.src,this._basePath,this._rootPath)),formattedAsset.alias=aliases??formattedAsset.alias??[formattedAsset.src],formattedAsset.src=this._appendDefaultSearchParams(formattedAsset.src),formattedAsset.data={...assetData||{},...formattedAsset.data},formattedAsset.loadParser=loadParser??formattedAsset.loadParser,formattedAsset.format=format??formattedAsset.src.split(".").pop(),formattedAsset.srcs=formattedAsset.src,formattedAsset.name=formattedAsset.alias,formattedAsset}}const Assets=new class AssetsClass{constructor(){this._detections=[],this._initialized=!1,this.resolver=new Resolver,this.loader=new Loader,this.cache=Cache,this._backgroundLoader=new BackgroundLoader(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(options={}){if(this._initialized)return void console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");if(this._initialized=!0,options.defaultSearchParams&&this.resolver.setDefaultSearchParams(options.defaultSearchParams),options.basePath&&(this.resolver.basePath=options.basePath),options.bundleIdentifier&&this.resolver.setBundleIdentifier(options.bundleIdentifier),options.manifest){let manifest=options.manifest;"string"==typeof manifest&&(manifest=await this.load(manifest)),this.resolver.addManifest(manifest)}const resolutionPref=options.texturePreference?.resolution??1,resolution="number"==typeof resolutionPref?[resolutionPref]:resolutionPref,formats=await this._detectFormats({preferredFormats:options.texturePreference?.format,skipDetections:options.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:formats,resolution}}),options.preferences&&this.setPreferences(options.preferences)}add(aliases,srcs,data,format,loadParser){this.resolver.add(aliases,srcs,data,format,loadParser)}async load(urls,onProgress){this._initialized||await this.init();const singleAsset=isSingleItem(urls),urlArray=convertToList(urls).map((url=>{if("string"!=typeof url){const aliases=this.resolver.getAlias(url);return aliases.some((alias=>!this.resolver.hasKey(alias)))&&this.add(url),Array.isArray(aliases)?aliases[0]:aliases}return this.resolver.hasKey(url)||this.add({alias:url,src:url}),url})),resolveResults=this.resolver.resolve(urlArray),out=await this._mapLoadToResolve(resolveResults,onProgress);return singleAsset?out[urlArray[0]]:out}addBundle(bundleId,assets){this.resolver.addBundle(bundleId,assets)}async loadBundle(bundleIds,onProgress){this._initialized||await this.init();let singleAsset=!1;"string"==typeof bundleIds&&(singleAsset=!0,bundleIds=[bundleIds]);const resolveResults=this.resolver.resolveBundle(bundleIds),out={},keys=Object.keys(resolveResults);let count=0,total=0;const _onProgress=()=>{onProgress?.(++count/total)},promises=keys.map((bundleId=>{const resolveResult=resolveResults[bundleId];return total+=Object.keys(resolveResult).length,this._mapLoadToResolve(resolveResult,_onProgress).then((resolveResult2=>{out[bundleId]=resolveResult2}))}));return await Promise.all(promises),singleAsset?out[bundleIds[0]]:out}async backgroundLoad(urls){this._initialized||await this.init(),"string"==typeof urls&&(urls=[urls]);const resolveResults=this.resolver.resolve(urls);this._backgroundLoader.add(Object.values(resolveResults))}async backgroundLoadBundle(bundleIds){this._initialized||await this.init(),"string"==typeof bundleIds&&(bundleIds=[bundleIds]);const resolveResults=this.resolver.resolveBundle(bundleIds);Object.values(resolveResults).forEach((resolveResult=>{this._backgroundLoader.add(Object.values(resolveResult))}))}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(keys){if("string"==typeof keys)return Cache.get(keys);const assets={};for(let i=0;i<keys.length;i++)assets[i]=Cache.get(keys[i]);return assets}async _mapLoadToResolve(resolveResults,onProgress){const resolveArray=Object.values(resolveResults),resolveKeys=Object.keys(resolveResults);this._backgroundLoader.active=!1;const loadedAssets=await this.loader.load(resolveArray,onProgress);this._backgroundLoader.active=!0;const out={};return resolveArray.forEach(((resolveResult,i)=>{const asset=loadedAssets[resolveResult.src],keys=[resolveResult.src];resolveResult.alias&&keys.push(...resolveResult.alias),out[resolveKeys[i]]=asset,Cache.set(keys,asset)})),out}async unload(urls){this._initialized||await this.init();const urlArray=convertToList(urls).map((url=>"string"!=typeof url?url.src:url)),resolveResults=this.resolver.resolve(urlArray);await this._unloadFromResolved(resolveResults)}async unloadBundle(bundleIds){this._initialized||await this.init(),bundleIds=convertToList(bundleIds);const resolveResults=this.resolver.resolveBundle(bundleIds),promises=Object.keys(resolveResults).map((bundleId=>this._unloadFromResolved(resolveResults[bundleId])));await Promise.all(promises)}async _unloadFromResolved(resolveResult){const resolveArray=Object.values(resolveResult);resolveArray.forEach((resolveResult2=>{Cache.remove(resolveResult2.src)})),await this.loader.unload(resolveArray)}async _detectFormats(options){let formats=[];options.preferredFormats&&(formats=Array.isArray(options.preferredFormats)?options.preferredFormats:[options.preferredFormats]);for(const detection of options.detections)options.skipDetections||await detection.test()?formats=await detection.add(formats):options.skipDetections||(formats=await detection.remove(formats));return formats=formats.filter(((format,index)=>formats.indexOf(format)===index)),formats}get detections(){return this._detections}get preferWorkers(){return loadTextures.config.preferWorkers}set preferWorkers(value){lib.P6.deprecation("7.2.0","Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."),this.setPreferences({preferWorkers:value})}setPreferences(preferences){this.loader.parsers.forEach((parser=>{parser.config&&Object.keys(parser.config).filter((key=>key in preferences)).forEach((key=>{parser.config[key]=preferences[key]}))}))}};lib.Rw.handleByList(lib.nw.LoadParser,Assets.loader.parsers).handleByList(lib.nw.ResolveParser,Assets.resolver.parsers).handleByList(lib.nw.CacheParser,Assets.cache.parsers).handleByList(lib.nw.DetectionParser,Assets.detections);const cacheTextureArray={extension:lib.nw.CacheParser,test:asset=>Array.isArray(asset)&&asset.every((t=>t instanceof lib.xE)),getCacheableAssets:(keys,asset)=>{const out={};return keys.forEach((key=>{asset.forEach(((item,i)=>{out[key+(0===i?"":i+1)]=item}))})),out}};lib.Rw.add(cacheTextureArray);const detectAvif={extension:{type:lib.nw.DetectionParser,priority:1},test:async()=>new Promise((resolve=>{const avif=new Image;avif.onload=()=>{resolve(!0)},avif.onerror=()=>{resolve(!1)},avif.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="})),add:async formats=>[...formats,"avif"],remove:async formats=>formats.filter((f=>"avif"!==f))};lib.Rw.add(detectAvif);const detectWebp={extension:{type:lib.nw.DetectionParser,priority:0},test:async()=>new Promise((resolve=>{const webp=new Image;webp.onload=()=>{resolve(!0)},webp.onerror=()=>{resolve(!1)},webp.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="})),add:async formats=>[...formats,"webp"],remove:async formats=>formats.filter((f=>"webp"!==f))};lib.Rw.add(detectWebp);const imageFormats=["png","jpg","jpeg"],detectDefaults={extension:{type:lib.nw.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async formats=>[...formats,...imageFormats],remove:async formats=>formats.filter((f=>!imageFormats.includes(f)))};lib.Rw.add(detectDefaults);const inWorker="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function testVideoFormat(mimeType){return!inWorker&&""!==document.createElement("video").canPlayType(mimeType)}const detectWebm={extension:{type:lib.nw.DetectionParser,priority:0},test:async()=>testVideoFormat("video/webm"),add:async formats=>[...formats,"webm"],remove:async formats=>formats.filter((f=>"webm"!==f))};lib.Rw.add(detectWebm);const detectMp4={extension:{type:lib.nw.DetectionParser,priority:0},test:async()=>testVideoFormat("video/mp4"),add:async formats=>[...formats,"mp4","m4v"],remove:async formats=>formats.filter((f=>"mp4"!==f&&"m4v"!==f))};lib.Rw.add(detectMp4);const detectOgv={extension:{type:lib.nw.DetectionParser,priority:0},test:async()=>testVideoFormat("video/ogg"),add:async formats=>[...formats,"ogv"],remove:async formats=>formats.filter((f=>"ogv"!==f))};lib.Rw.add(detectOgv);const resolveTextureUrl={extension:lib.nw.ResolveParser,test:loadTextures.test,parse:value=>({resolution:parseFloat(lib.Xd.RETINA_PREFIX.exec(value)?.[1]??"1"),format:value.split(".").pop(),src:value})};lib.Rw.add(resolveTextureUrl);const copySearchParams=(targetUrl,sourceUrl)=>{const searchParams=sourceUrl.split("?")[1];return searchParams&&(targetUrl+=`?${searchParams}`),targetUrl}}}]);