"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[239],{"./node_modules/@pixi/core/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{iw:()=>ALPHA_MODES,T$:()=>BLEND_MODES,VL:()=>BaseTexture,a$:()=>BatchDrawCall,JZ:()=>BatchGeometry,Ie:()=>BatchTextureArray,lW:()=>Buffer,Cd:()=>Circle,Il:()=>Color,ZX:()=>DEG_TO_RAD,lg:()=>DRAW_MODES,Pj:()=>Ellipse,nw:()=>ExtensionType,wG:()=>Geometry,A7:()=>MASK_TYPES,KI:()=>MIPMAP_MODES,y3:()=>Matrix,AB:()=>ObservablePoint,_b:()=>PI_2,E9:()=>Point,mg:()=>Polygon,$r:()=>Program,jl:()=>RAD_TO_DEG,Ae:()=>Rectangle,c9:()=>RoundedRectangle,HS:()=>SHAPES,pX:()=>SVGResource,ex:()=>Shader,ZM:()=>State,vK:()=>TYPES,xE:()=>Texture,UX:()=>TextureMatrix,vB:()=>Ticker,wx:()=>Transform,oo:()=>UniformGroup,eH:()=>VideoResource,Nt:()=>WRAP_MODES,Rw:()=>extensions,tq:()=>isMobile_isMobile,Xd:()=>settings,P6:()=>utils_lib_namespaceObject});var utils_lib_namespaceObject={};__webpack_require__.r(utils_lib_namespaceObject),__webpack_require__.d(utils_lib_namespaceObject,{BaseTextureCache:()=>BaseTextureCache,BoundingBox:()=>BoundingBox,CanvasRenderTarget:()=>CanvasRenderTarget,DATA_URI:()=>DATA_URI,EventEmitter:()=>eventemitter3_default(),ProgramCache:()=>ProgramCache,TextureCache:()=>TextureCache,clearTextureCache:()=>clearTextureCache,correctBlendMode:()=>correctBlendMode,createIndicesForQuads:()=>createIndicesForQuads,decomposeDataUri:()=>decomposeDataUri,deprecation:()=>deprecation,destroyTextureCache:()=>destroyTextureCache,detectVideoAlphaMode:()=>detectVideoAlphaMode,determineCrossOrigin:()=>determineCrossOrigin,earcut:()=>earcut_default(),getBufferType:()=>getBufferType,getCanvasBoundingBox:()=>getCanvasBoundingBox,getResolutionOfUrl:()=>getResolutionOfUrl,hex2rgb:()=>hex2rgb,hex2string:()=>hex2string,interleaveTypedArrays:()=>interleaveTypedArrays,isMobile:()=>isMobile_isMobile,isPow2:()=>isPow2,isWebGLSupported:()=>isWebGLSupported,log2:()=>log2,nextPow2:()=>nextPow2,path:()=>path,premultiplyBlendMode:()=>premultiplyBlendMode,premultiplyRgba:()=>premultiplyRgba,premultiplyTint:()=>premultiplyTint,premultiplyTintToRgba:()=>premultiplyTintToRgba,removeItems:()=>removeItems,rgb2hex:()=>rgb2hex,sayHello:()=>sayHello,sign:()=>sign,skipHello:()=>skipHello,string2hex:()=>string2hex,trimCanvas:()=>trimCanvas,uid:()=>uid,url:()=>url_url});var ENV=(ENV2=>(ENV2[ENV2.WEBGL_LEGACY=0]="WEBGL_LEGACY",ENV2[ENV2.WEBGL=1]="WEBGL",ENV2[ENV2.WEBGL2=2]="WEBGL2",ENV2))(ENV||{}),RENDERER_TYPE=(RENDERER_TYPE2=>(RENDERER_TYPE2[RENDERER_TYPE2.UNKNOWN=0]="UNKNOWN",RENDERER_TYPE2[RENDERER_TYPE2.WEBGL=1]="WEBGL",RENDERER_TYPE2[RENDERER_TYPE2.CANVAS=2]="CANVAS",RENDERER_TYPE2))(RENDERER_TYPE||{}),BUFFER_BITS=(BUFFER_BITS2=>(BUFFER_BITS2[BUFFER_BITS2.COLOR=16384]="COLOR",BUFFER_BITS2[BUFFER_BITS2.DEPTH=256]="DEPTH",BUFFER_BITS2[BUFFER_BITS2.STENCIL=1024]="STENCIL",BUFFER_BITS2))(BUFFER_BITS||{}),BLEND_MODES=(BLEND_MODES2=>(BLEND_MODES2[BLEND_MODES2.NORMAL=0]="NORMAL",BLEND_MODES2[BLEND_MODES2.ADD=1]="ADD",BLEND_MODES2[BLEND_MODES2.MULTIPLY=2]="MULTIPLY",BLEND_MODES2[BLEND_MODES2.SCREEN=3]="SCREEN",BLEND_MODES2[BLEND_MODES2.OVERLAY=4]="OVERLAY",BLEND_MODES2[BLEND_MODES2.DARKEN=5]="DARKEN",BLEND_MODES2[BLEND_MODES2.LIGHTEN=6]="LIGHTEN",BLEND_MODES2[BLEND_MODES2.COLOR_DODGE=7]="COLOR_DODGE",BLEND_MODES2[BLEND_MODES2.COLOR_BURN=8]="COLOR_BURN",BLEND_MODES2[BLEND_MODES2.HARD_LIGHT=9]="HARD_LIGHT",BLEND_MODES2[BLEND_MODES2.SOFT_LIGHT=10]="SOFT_LIGHT",BLEND_MODES2[BLEND_MODES2.DIFFERENCE=11]="DIFFERENCE",BLEND_MODES2[BLEND_MODES2.EXCLUSION=12]="EXCLUSION",BLEND_MODES2[BLEND_MODES2.HUE=13]="HUE",BLEND_MODES2[BLEND_MODES2.SATURATION=14]="SATURATION",BLEND_MODES2[BLEND_MODES2.COLOR=15]="COLOR",BLEND_MODES2[BLEND_MODES2.LUMINOSITY=16]="LUMINOSITY",BLEND_MODES2[BLEND_MODES2.NORMAL_NPM=17]="NORMAL_NPM",BLEND_MODES2[BLEND_MODES2.ADD_NPM=18]="ADD_NPM",BLEND_MODES2[BLEND_MODES2.SCREEN_NPM=19]="SCREEN_NPM",BLEND_MODES2[BLEND_MODES2.NONE=20]="NONE",BLEND_MODES2[BLEND_MODES2.SRC_OVER=0]="SRC_OVER",BLEND_MODES2[BLEND_MODES2.SRC_IN=21]="SRC_IN",BLEND_MODES2[BLEND_MODES2.SRC_OUT=22]="SRC_OUT",BLEND_MODES2[BLEND_MODES2.SRC_ATOP=23]="SRC_ATOP",BLEND_MODES2[BLEND_MODES2.DST_OVER=24]="DST_OVER",BLEND_MODES2[BLEND_MODES2.DST_IN=25]="DST_IN",BLEND_MODES2[BLEND_MODES2.DST_OUT=26]="DST_OUT",BLEND_MODES2[BLEND_MODES2.DST_ATOP=27]="DST_ATOP",BLEND_MODES2[BLEND_MODES2.ERASE=26]="ERASE",BLEND_MODES2[BLEND_MODES2.SUBTRACT=28]="SUBTRACT",BLEND_MODES2[BLEND_MODES2.XOR=29]="XOR",BLEND_MODES2))(BLEND_MODES||{}),DRAW_MODES=(DRAW_MODES2=>(DRAW_MODES2[DRAW_MODES2.POINTS=0]="POINTS",DRAW_MODES2[DRAW_MODES2.LINES=1]="LINES",DRAW_MODES2[DRAW_MODES2.LINE_LOOP=2]="LINE_LOOP",DRAW_MODES2[DRAW_MODES2.LINE_STRIP=3]="LINE_STRIP",DRAW_MODES2[DRAW_MODES2.TRIANGLES=4]="TRIANGLES",DRAW_MODES2[DRAW_MODES2.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",DRAW_MODES2[DRAW_MODES2.TRIANGLE_FAN=6]="TRIANGLE_FAN",DRAW_MODES2))(DRAW_MODES||{}),FORMATS=(FORMATS2=>(FORMATS2[FORMATS2.RGBA=6408]="RGBA",FORMATS2[FORMATS2.RGB=6407]="RGB",FORMATS2[FORMATS2.RG=33319]="RG",FORMATS2[FORMATS2.RED=6403]="RED",FORMATS2[FORMATS2.RGBA_INTEGER=36249]="RGBA_INTEGER",FORMATS2[FORMATS2.RGB_INTEGER=36248]="RGB_INTEGER",FORMATS2[FORMATS2.RG_INTEGER=33320]="RG_INTEGER",FORMATS2[FORMATS2.RED_INTEGER=36244]="RED_INTEGER",FORMATS2[FORMATS2.ALPHA=6406]="ALPHA",FORMATS2[FORMATS2.LUMINANCE=6409]="LUMINANCE",FORMATS2[FORMATS2.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",FORMATS2[FORMATS2.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",FORMATS2[FORMATS2.DEPTH_STENCIL=34041]="DEPTH_STENCIL",FORMATS2))(FORMATS||{}),TARGETS=(TARGETS2=>(TARGETS2[TARGETS2.TEXTURE_2D=3553]="TEXTURE_2D",TARGETS2[TARGETS2.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",TARGETS2[TARGETS2.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",TARGETS2))(TARGETS||{}),TYPES=(TYPES2=>(TYPES2[TYPES2.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",TYPES2[TYPES2.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",TYPES2[TYPES2.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",TYPES2[TYPES2.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",TYPES2[TYPES2.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",TYPES2[TYPES2.UNSIGNED_INT=5125]="UNSIGNED_INT",TYPES2[TYPES2.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",TYPES2[TYPES2.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",TYPES2[TYPES2.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",TYPES2[TYPES2.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",TYPES2[TYPES2.BYTE=5120]="BYTE",TYPES2[TYPES2.SHORT=5122]="SHORT",TYPES2[TYPES2.INT=5124]="INT",TYPES2[TYPES2.FLOAT=5126]="FLOAT",TYPES2[TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",TYPES2[TYPES2.HALF_FLOAT=36193]="HALF_FLOAT",TYPES2))(TYPES||{}),SAMPLER_TYPES=(SAMPLER_TYPES2=>(SAMPLER_TYPES2[SAMPLER_TYPES2.FLOAT=0]="FLOAT",SAMPLER_TYPES2[SAMPLER_TYPES2.INT=1]="INT",SAMPLER_TYPES2[SAMPLER_TYPES2.UINT=2]="UINT",SAMPLER_TYPES2))(SAMPLER_TYPES||{}),SCALE_MODES=(SCALE_MODES2=>(SCALE_MODES2[SCALE_MODES2.NEAREST=0]="NEAREST",SCALE_MODES2[SCALE_MODES2.LINEAR=1]="LINEAR",SCALE_MODES2))(SCALE_MODES||{}),WRAP_MODES=(WRAP_MODES2=>(WRAP_MODES2[WRAP_MODES2.CLAMP=33071]="CLAMP",WRAP_MODES2[WRAP_MODES2.REPEAT=10497]="REPEAT",WRAP_MODES2[WRAP_MODES2.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",WRAP_MODES2))(WRAP_MODES||{}),MIPMAP_MODES=(MIPMAP_MODES2=>(MIPMAP_MODES2[MIPMAP_MODES2.OFF=0]="OFF",MIPMAP_MODES2[MIPMAP_MODES2.POW2=1]="POW2",MIPMAP_MODES2[MIPMAP_MODES2.ON=2]="ON",MIPMAP_MODES2[MIPMAP_MODES2.ON_MANUAL=3]="ON_MANUAL",MIPMAP_MODES2))(MIPMAP_MODES||{}),ALPHA_MODES=(ALPHA_MODES2=>(ALPHA_MODES2[ALPHA_MODES2.NPM=0]="NPM",ALPHA_MODES2[ALPHA_MODES2.UNPACK=1]="UNPACK",ALPHA_MODES2[ALPHA_MODES2.PMA=2]="PMA",ALPHA_MODES2[ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA=0]="NO_PREMULTIPLIED_ALPHA",ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD=1]="PREMULTIPLY_ON_UPLOAD",ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLIED_ALPHA=2]="PREMULTIPLIED_ALPHA",ALPHA_MODES2))(ALPHA_MODES||{}),CLEAR_MODES=(CLEAR_MODES2=>(CLEAR_MODES2[CLEAR_MODES2.NO=0]="NO",CLEAR_MODES2[CLEAR_MODES2.YES=1]="YES",CLEAR_MODES2[CLEAR_MODES2.AUTO=2]="AUTO",CLEAR_MODES2[CLEAR_MODES2.BLEND=0]="BLEND",CLEAR_MODES2[CLEAR_MODES2.CLEAR=1]="CLEAR",CLEAR_MODES2[CLEAR_MODES2.BLIT=2]="BLIT",CLEAR_MODES2))(CLEAR_MODES||{}),GC_MODES=(GC_MODES2=>(GC_MODES2[GC_MODES2.AUTO=0]="AUTO",GC_MODES2[GC_MODES2.MANUAL=1]="MANUAL",GC_MODES2))(GC_MODES||{}),PRECISION=(PRECISION2=>(PRECISION2.LOW="lowp",PRECISION2.MEDIUM="mediump",PRECISION2.HIGH="highp",PRECISION2))(PRECISION||{}),MASK_TYPES=(MASK_TYPES2=>(MASK_TYPES2[MASK_TYPES2.NONE=0]="NONE",MASK_TYPES2[MASK_TYPES2.SCISSOR=1]="SCISSOR",MASK_TYPES2[MASK_TYPES2.STENCIL=2]="STENCIL",MASK_TYPES2[MASK_TYPES2.SPRITE=3]="SPRITE",MASK_TYPES2[MASK_TYPES2.COLOR=4]="COLOR",MASK_TYPES2))(MASK_TYPES||{}),MSAA_QUALITY=(MSAA_QUALITY2=>(MSAA_QUALITY2[MSAA_QUALITY2.NONE=0]="NONE",MSAA_QUALITY2[MSAA_QUALITY2.LOW=2]="LOW",MSAA_QUALITY2[MSAA_QUALITY2.MEDIUM=4]="MEDIUM",MSAA_QUALITY2[MSAA_QUALITY2.HIGH=8]="HIGH",MSAA_QUALITY2))(MSAA_QUALITY||{}),BUFFER_TYPE=(BUFFER_TYPE2=>(BUFFER_TYPE2[BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",BUFFER_TYPE2[BUFFER_TYPE2.ARRAY_BUFFER=34962]="ARRAY_BUFFER",BUFFER_TYPE2[BUFFER_TYPE2.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",BUFFER_TYPE2))(BUFFER_TYPE||{});const BrowserAdapter={createCanvas:(width,height)=>{const canvas=document.createElement("canvas");return canvas.width=width,canvas.height=height,canvas},getCanvasRenderingContext2D:()=>CanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>document.baseURI??window.location.href,getFontFaceSet:()=>document.fonts,fetch:(url,options)=>fetch(url,options),parseXML:xml=>(new DOMParser).parseFromString(xml,"text/xml")},settings={ADAPTER:BrowserAdapter,RESOLUTION:1,CREATE_IMAGE_BITMAP:!1,ROUND_PIXELS:!1};var isMobile=__webpack_require__("./node_modules/ismobilejs/esm/isMobile.js");const isMobile_isMobile=(isMobile.Z.default??isMobile.Z)(globalThis.navigator);settings.RETINA_PREFIX=/@([0-9\.]+)x/,settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT=!1;var eventemitter3=__webpack_require__("./node_modules/eventemitter3/index.js"),eventemitter3_default=__webpack_require__.n(eventemitter3),earcut=__webpack_require__("./node_modules/earcut/src/earcut.js"),earcut_default=__webpack_require__.n(earcut),url=__webpack_require__("./node_modules/url/url.js");const warnings={};function deprecation(version,message,ignoreDepth=3){if(warnings[message])return;let stack=(new Error).stack;typeof stack>"u"?console.warn("PixiJS Deprecation Warning: ",`${message}\nDeprecated since v${version}`):(stack=stack.split("\n").splice(ignoreDepth).join("\n"),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",`${message}\nDeprecated since v${version}`),console.warn(stack),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",`${message}\nDeprecated since v${version}`),console.warn(stack))),warnings[message]=!0}const url_url={get parse(){return deprecation("7.3.0","utils.url.parse is deprecated, use native URL API instead."),url.Qc},get format(){return deprecation("7.3.0","utils.url.format is deprecated, use native URL API instead."),url.WU},get resolve(){return deprecation("7.3.0","utils.url.resolve is deprecated, use native URL API instead."),url.DB}};function assertPath(path2){if("string"!=typeof path2)throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`)}function removeUrlParams(url){return url.split("?")[0].split("#")[0]}const path={toPosix:path2=>function replaceAll(str,find,replace){return str.replace(new RegExp(function escapeRegExp(string){return string.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}(find),"g"),replace)}(path2,"\\","/"),isUrl(path2){return/^https?:/.test(this.toPosix(path2))},isDataUrl:path2=>/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2),isBlobUrl:path2=>path2.startsWith("blob:"),hasProtocol(path2){return/^[^/:]+:/.test(this.toPosix(path2))},getProtocol(path2){assertPath(path2),path2=this.toPosix(path2);const matchFile=/^file:\/\/\//.exec(path2);if(matchFile)return matchFile[0];const matchProtocol=/^[^/:]+:\/{0,2}/.exec(path2);return matchProtocol?matchProtocol[0]:""},toAbsolute(url,customBaseUrl,customRootUrl){if(assertPath(url),this.isDataUrl(url)||this.isBlobUrl(url))return url;const baseUrl=removeUrlParams(this.toPosix(customBaseUrl??settings.ADAPTER.getBaseUrl())),rootUrl=removeUrlParams(this.toPosix(customRootUrl??this.rootname(baseUrl)));return(url=this.toPosix(url)).startsWith("/")?path.join(rootUrl,url.slice(1)):this.isAbsolute(url)?url:this.join(baseUrl,url)},normalize(path2){if(assertPath(path2),0===path2.length)return".";if(this.isDataUrl(path2)||this.isBlobUrl(path2))return path2;let protocol="";const isAbsolute=(path2=this.toPosix(path2)).startsWith("/");this.hasProtocol(path2)&&(protocol=this.rootname(path2),path2=path2.slice(protocol.length));const trailingSeparator=path2.endsWith("/");return(path2=function normalizeStringPosix(path2,allowAboveRoot){let res="",lastSegmentLength=0,lastSlash=-1,dots=0,code=-1;for(let i=0;i<=path2.length;++i){if(i<path2.length)code=path2.charCodeAt(i);else{if(47===code)break;code=47}if(47===code){if(lastSlash!==i-1&&1!==dots)if(lastSlash!==i-1&&2===dots){if(res.length<2||2!==lastSegmentLength||46!==res.charCodeAt(res.length-1)||46!==res.charCodeAt(res.length-2))if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");if(lastSlashIndex!==res.length-1){-1===lastSlashIndex?(res="",lastSegmentLength=0):(res=res.slice(0,lastSlashIndex),lastSegmentLength=res.length-1-res.lastIndexOf("/")),lastSlash=i,dots=0;continue}}else if(2===res.length||1===res.length){res="",lastSegmentLength=0,lastSlash=i,dots=0;continue}allowAboveRoot&&(res.length>0?res+="/..":res="..",lastSegmentLength=2)}else res.length>0?res+=`/${path2.slice(lastSlash+1,i)}`:res=path2.slice(lastSlash+1,i),lastSegmentLength=i-lastSlash-1;lastSlash=i,dots=0}else 46===code&&-1!==dots?++dots:dots=-1}return res}(path2,!1)).length>0&&trailingSeparator&&(path2+="/"),isAbsolute?`/${path2}`:protocol+path2},isAbsolute(path2){return assertPath(path2),path2=this.toPosix(path2),!!this.hasProtocol(path2)||path2.startsWith("/")},join(...segments){if(0===segments.length)return".";let joined;for(let i=0;i<segments.length;++i){const arg=segments[i];if(assertPath(arg),arg.length>0)if(void 0===joined)joined=arg;else{const prevArg=segments[i-1]??"";this.extname(prevArg)?joined+=`/../${arg}`:joined+=`/${arg}`}}return void 0===joined?".":this.normalize(joined)},dirname(path2){if(assertPath(path2),0===path2.length)return".";let code=(path2=this.toPosix(path2)).charCodeAt(0);const hasRoot=47===code;let end=-1,matchedSlash=!0;const proto=this.getProtocol(path2),origpath=path2;for(let i=(path2=path2.slice(proto.length)).length-1;i>=1;--i)if(code=path2.charCodeAt(i),47===code){if(!matchedSlash){end=i;break}}else matchedSlash=!1;return-1===end?hasRoot?"/":this.isUrl(origpath)?proto+path2:proto:hasRoot&&1===end?"//":proto+path2.slice(0,end)},rootname(path2){assertPath(path2);let root="";if(root=(path2=this.toPosix(path2)).startsWith("/")?"/":this.getProtocol(path2),this.isUrl(path2)){const index=path2.indexOf("/",root.length);root=-1!==index?path2.slice(0,index):path2,root.endsWith("/")||(root+="/")}return root},basename(path2,ext){assertPath(path2),ext&&assertPath(ext),path2=removeUrlParams(this.toPosix(path2));let i,start=0,end=-1,matchedSlash=!0;if(void 0!==ext&&ext.length>0&&ext.length<=path2.length){if(ext.length===path2.length&&ext===path2)return"";let extIdx=ext.length-1,firstNonSlashEnd=-1;for(i=path2.length-1;i>=0;--i){const code=path2.charCodeAt(i);if(47===code){if(!matchedSlash){start=i+1;break}}else-1===firstNonSlashEnd&&(matchedSlash=!1,firstNonSlashEnd=i+1),extIdx>=0&&(code===ext.charCodeAt(extIdx)?-1==--extIdx&&(end=i):(extIdx=-1,end=firstNonSlashEnd))}return start===end?end=firstNonSlashEnd:-1===end&&(end=path2.length),path2.slice(start,end)}for(i=path2.length-1;i>=0;--i)if(47===path2.charCodeAt(i)){if(!matchedSlash){start=i+1;break}}else-1===end&&(matchedSlash=!1,end=i+1);return-1===end?"":path2.slice(start,end)},extname(path2){assertPath(path2);let startDot=-1,startPart=0,end=-1,matchedSlash=!0,preDotState=0;for(let i=(path2=removeUrlParams(this.toPosix(path2))).length-1;i>=0;--i){const code=path2.charCodeAt(i);if(47!==code)-1===end&&(matchedSlash=!1,end=i+1),46===code?-1===startDot?startDot=i:1!==preDotState&&(preDotState=1):-1!==startDot&&(preDotState=-1);else if(!matchedSlash){startPart=i+1;break}}return-1===startDot||-1===end||0===preDotState||1===preDotState&&startDot===end-1&&startDot===startPart+1?"":path2.slice(startDot,end)},parse(path2){assertPath(path2);const ret={root:"",dir:"",base:"",ext:"",name:""};if(0===path2.length)return ret;let code=(path2=removeUrlParams(this.toPosix(path2))).charCodeAt(0);const isAbsolute=this.isAbsolute(path2);let start;ret.root=this.rootname(path2),start=isAbsolute||this.hasProtocol(path2)?1:0;let startDot=-1,startPart=0,end=-1,matchedSlash=!0,i=path2.length-1,preDotState=0;for(;i>=start;--i)if(code=path2.charCodeAt(i),47!==code)-1===end&&(matchedSlash=!1,end=i+1),46===code?-1===startDot?startDot=i:1!==preDotState&&(preDotState=1):-1!==startDot&&(preDotState=-1);else if(!matchedSlash){startPart=i+1;break}return-1===startDot||-1===end||0===preDotState||1===preDotState&&startDot===end-1&&startDot===startPart+1?-1!==end&&(ret.base=ret.name=0===startPart&&isAbsolute?path2.slice(1,end):path2.slice(startPart,end)):(0===startPart&&isAbsolute?(ret.name=path2.slice(1,startDot),ret.base=path2.slice(1,end)):(ret.name=path2.slice(startPart,startDot),ret.base=path2.slice(startPart,end)),ret.ext=path2.slice(startDot,end)),ret.dir=this.dirname(path2),ret},sep:"/",delimiter:":"};let promise,supported;async function detectVideoAlphaMode(){return promise??(promise=(async()=>{const gl=document.createElement("canvas").getContext("webgl");if(!gl)return ALPHA_MODES.UNPACK;const video=await new Promise((resolve=>{const video2=document.createElement("video");video2.onloadeddata=()=>resolve(video2),video2.onerror=()=>resolve(null),video2.autoplay=!1,video2.crossOrigin="anonymous",video2.preload="auto",video2.src="data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",video2.load()}));if(!video)return ALPHA_MODES.UNPACK;const texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);const framebuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0),gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,gl.NONE),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video);const pixel=new Uint8Array(4);return gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixel),gl.deleteFramebuffer(framebuffer),gl.deleteTexture(texture),gl.getExtension("WEBGL_lose_context")?.loseContext(),pixel[0]<=pixel[3]?ALPHA_MODES.PMA:ALPHA_MODES.UNPACK})()),promise}function skipHello(){deprecation("7.0.0","skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")}function sayHello(){deprecation("7.0.0",'sayHello is deprecated, please use Renderer\'s "hello" option')}function isWebGLSupported(){return typeof supported>"u"&&(supported=function(){const contextOptions={stencil:!0,failIfMajorPerformanceCaveat:settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT};try{if(!settings.ADAPTER.getWebGLRenderingContext())return!1;const canvas=settings.ADAPTER.createCanvas();let gl=canvas.getContext("webgl",contextOptions)||canvas.getContext("experimental-webgl",contextOptions);const success=!!gl?.getContextAttributes()?.stencil;if(gl){const loseContext=gl.getExtension("WEBGL_lose_context");loseContext&&loseContext.loseContext()}return gl=null,success}catch{return!1}}()),supported}var colord=__webpack_require__("./node_modules/@pixi/colord/index.mjs"),names=__webpack_require__("./node_modules/@pixi/colord/plugins/names.mjs");(0,colord.l7)([names.Z]);const _Color=class _Color2{constructor(value=16777215){this._value=null,this._components=new Float32Array(4),this._components.fill(1),this._int=16777215,this.value=value}get red(){return this._components[0]}get green(){return this._components[1]}get blue(){return this._components[2]}get alpha(){return this._components[3]}setValue(value){return this.value=value,this}set value(value){if(value instanceof _Color2)this._value=this.cloneSource(value._value),this._int=value._int,this._components.set(value._components);else{if(null===value)throw new Error("Cannot set PIXI.Color#value to null");(null===this._value||!this.isSourceEqual(this._value,value))&&(this.normalize(value),this._value=this.cloneSource(value))}}get value(){return this._value}cloneSource(value){return"string"==typeof value||"number"==typeof value||value instanceof Number||null===value?value:Array.isArray(value)||ArrayBuffer.isView(value)?value.slice(0):"object"==typeof value&&null!==value?{...value}:value}isSourceEqual(value1,value2){const type1=typeof value1;if(type1!==typeof value2)return!1;if("number"===type1||"string"===type1||value1 instanceof Number)return value1===value2;if(Array.isArray(value1)&&Array.isArray(value2)||ArrayBuffer.isView(value1)&&ArrayBuffer.isView(value2))return value1.length===value2.length&&value1.every(((v,i)=>v===value2[i]));if(null!==value1&&null!==value2){const keys1=Object.keys(value1),keys2=Object.keys(value2);return keys1.length===keys2.length&&keys1.every((key=>value1[key]===value2[key]))}return value1===value2}toRgba(){const[r,g,b,a]=this._components;return{r,g,b,a}}toRgb(){const[r,g,b]=this._components;return{r,g,b}}toRgbaString(){const[r,g,b]=this.toUint8RgbArray();return`rgba(${r},${g},${b},${this.alpha})`}toUint8RgbArray(out){const[r,g,b]=this._components;return(out=out??[])[0]=Math.round(255*r),out[1]=Math.round(255*g),out[2]=Math.round(255*b),out}toRgbArray(out){out=out??[];const[r,g,b]=this._components;return out[0]=r,out[1]=g,out[2]=b,out}toNumber(){return this._int}toLittleEndianNumber(){const value=this._int;return(value>>16)+(65280&value)+((255&value)<<16)}multiply(value){const[r,g,b,a]=_Color2.temp.setValue(value)._components;return this._components[0]*=r,this._components[1]*=g,this._components[2]*=b,this._components[3]*=a,this.refreshInt(),this._value=null,this}premultiply(alpha,applyToRGB=!0){return applyToRGB&&(this._components[0]*=alpha,this._components[1]*=alpha,this._components[2]*=alpha),this._components[3]=alpha,this.refreshInt(),this._value=null,this}toPremultiplied(alpha,applyToRGB=!0){if(1===alpha)return(255<<24)+this._int;if(0===alpha)return applyToRGB?0:this._int;let r=this._int>>16&255,g=this._int>>8&255,b=255&this._int;return applyToRGB&&(r=r*alpha+.5|0,g=g*alpha+.5|0,b=b*alpha+.5|0),(255*alpha<<24)+(r<<16)+(g<<8)+b}toHex(){const hexString=this._int.toString(16);return`#${"000000".substring(0,6-hexString.length)+hexString}`}toHexa(){const alphaString=Math.round(255*this._components[3]).toString(16);return this.toHex()+"00".substring(0,2-alphaString.length)+alphaString}setAlpha(alpha){return this._components[3]=this._clamp(alpha),this}round(steps){const[r,g,b]=this._components;return this._components[0]=Math.round(r*steps)/steps,this._components[1]=Math.round(g*steps)/steps,this._components[2]=Math.round(b*steps)/steps,this.refreshInt(),this._value=null,this}toArray(out){out=out??[];const[r,g,b,a]=this._components;return out[0]=r,out[1]=g,out[2]=b,out[3]=a,out}normalize(value){let r,g,b,a;if(("number"==typeof value||value instanceof Number)&&value>=0&&value<=16777215){r=(value>>16&255)/255,g=(value>>8&255)/255,b=(255&value)/255,a=1}else if((Array.isArray(value)||value instanceof Float32Array)&&value.length>=3&&value.length<=4)value=this._clamp(value),[r,g,b,a=1]=value;else if((value instanceof Uint8Array||value instanceof Uint8ClampedArray)&&value.length>=3&&value.length<=4)value=this._clamp(value,0,255),[r,g,b,a=255]=value,r/=255,g/=255,b/=255,a/=255;else if("string"==typeof value||"object"==typeof value){if("string"==typeof value){const match=_Color2.HEX_PATTERN.exec(value);match&&(value=`#${match[2]}`)}const color=(0,colord.Vi)(value);color.isValid()&&(({r,g,b,a}=color.rgba),r/=255,g/=255,b/=255)}if(void 0===r)throw new Error(`Unable to convert color ${value}`);this._components[0]=r,this._components[1]=g,this._components[2]=b,this._components[3]=a,this.refreshInt()}refreshInt(){this._clamp(this._components);const[r,g,b]=this._components;this._int=(255*r<<16)+(255*g<<8)+(255*b|0)}_clamp(value,min=0,max=1){return"number"==typeof value?Math.min(Math.max(value,min),max):(value.forEach(((v,i)=>{value[i]=Math.min(Math.max(v,min),max)})),value)}};_Color.shared=new _Color,_Color.temp=new _Color,_Color.HEX_PATTERN=/^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;let Color=_Color;function hex2rgb(hex,out=[]){return deprecation("7.2.0","utils.hex2rgb is deprecated, use Color#toRgbArray instead"),Color.shared.setValue(hex).toRgbArray(out)}function hex2string(hex){return deprecation("7.2.0","utils.hex2string is deprecated, use Color#toHex instead"),Color.shared.setValue(hex).toHex()}function string2hex(string){return deprecation("7.2.0","utils.string2hex is deprecated, use Color#toNumber instead"),Color.shared.setValue(string).toNumber()}function rgb2hex(rgb){return deprecation("7.2.0","utils.rgb2hex is deprecated, use Color#toNumber instead"),Color.shared.setValue(rgb).toNumber()}const premultiplyBlendMode=function mapPremultipliedBlendModes(){const pm=[],npm=[];for(let i=0;i<32;i++)pm[i]=i,npm[i]=i;pm[BLEND_MODES.NORMAL_NPM]=BLEND_MODES.NORMAL,pm[BLEND_MODES.ADD_NPM]=BLEND_MODES.ADD,pm[BLEND_MODES.SCREEN_NPM]=BLEND_MODES.SCREEN,npm[BLEND_MODES.NORMAL]=BLEND_MODES.NORMAL_NPM,npm[BLEND_MODES.ADD]=BLEND_MODES.ADD_NPM,npm[BLEND_MODES.SCREEN]=BLEND_MODES.SCREEN_NPM;const array=[];return array.push(npm),array.push(pm),array}();function correctBlendMode(blendMode,premultiplied){return premultiplyBlendMode[premultiplied?1:0][blendMode]}function premultiplyRgba(rgb,alpha,out,premultiply=!0){return deprecation("7.2.0","utils.premultiplyRgba has moved to Color.premultiply"),Color.shared.setValue(rgb).premultiply(alpha,premultiply).toArray(out??new Float32Array(4))}function premultiplyTint(tint,alpha){return deprecation("7.2.0","utils.premultiplyTint has moved to Color.toPremultiplied"),Color.shared.setValue(tint).toPremultiplied(alpha)}function premultiplyTintToRgba(tint,alpha,out,premultiply=!0){return deprecation("7.2.0","utils.premultiplyTintToRgba has moved to Color.premultiply"),Color.shared.setValue(tint).premultiply(alpha,premultiply).toArray(out??new Float32Array(4))}const DATA_URI=/^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;function createIndicesForQuads(size,outBuffer=null){const totalIndices=6*size;if((outBuffer=outBuffer||new Uint16Array(totalIndices)).length!==totalIndices)throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);for(let i=0,j=0;i<totalIndices;i+=6,j+=4)outBuffer[i+0]=j+0,outBuffer[i+1]=j+1,outBuffer[i+2]=j+2,outBuffer[i+3]=j+0,outBuffer[i+4]=j+2,outBuffer[i+5]=j+3;return outBuffer}function getBufferType(array){if(4===array.BYTES_PER_ELEMENT)return array instanceof Float32Array?"Float32Array":array instanceof Uint32Array?"Uint32Array":"Int32Array";if(2===array.BYTES_PER_ELEMENT){if(array instanceof Uint16Array)return"Uint16Array"}else if(1===array.BYTES_PER_ELEMENT&&array instanceof Uint8Array)return"Uint8Array";return null}const map={Float32Array,Uint32Array,Int32Array,Uint8Array};function interleaveTypedArrays(arrays,sizes){let outSize=0,stride=0;const views={};for(let i=0;i<arrays.length;i++)stride+=sizes[i],outSize+=arrays[i].length;const buffer=new ArrayBuffer(4*outSize);let out=null,littleOffset=0;for(let i=0;i<arrays.length;i++){const size=sizes[i],array=arrays[i],type=getBufferType(array);views[type]||(views[type]=new map[type](buffer)),out=views[type];for(let j=0;j<array.length;j++){out[(j/size|0)*stride+littleOffset+j%size]=array[j]}littleOffset+=size}return new Float32Array(buffer)}function nextPow2(v){return v+=0===v?1:0,--v,v|=v>>>1,v|=v>>>2,v|=v>>>4,v|=v>>>8,(v|=v>>>16)+1}function isPow2(v){return!(v&v-1||!v)}function log2(v){let r=(v>65535?1:0)<<4,shift=((v>>>=r)>255?1:0)<<3;return r|=shift,shift=((v>>>=shift)>15?1:0)<<2,r|=shift,shift=((v>>>=shift)>3?1:0)<<1,r|=shift,r|(v>>>=shift)>>1}function removeItems(arr,startIdx,removeCount){const length=arr.length;let i;if(startIdx>=length||0===removeCount)return;const len=length-(removeCount=startIdx+removeCount>length?length-startIdx:removeCount);for(i=startIdx;i<len;++i)arr[i]=arr[i+removeCount];arr.length=len}function sign(n){return 0===n?0:n<0?-1:1}let nextUid=0;function uid(){return++nextUid}const _BoundingBox=class{constructor(left,top,right,bottom){this.left=left,this.top=top,this.right=right,this.bottom=bottom}get width(){return this.right-this.left}get height(){return this.bottom-this.top}isEmpty(){return this.left===this.right||this.top===this.bottom}};_BoundingBox.EMPTY=new _BoundingBox(0,0,0,0);let BoundingBox=_BoundingBox;const ProgramCache={},TextureCache=Object.create(null),BaseTextureCache=Object.create(null);function destroyTextureCache(){let key;for(key in TextureCache)TextureCache[key].destroy();for(key in BaseTextureCache)BaseTextureCache[key].destroy()}function clearTextureCache(){let key;for(key in TextureCache)delete TextureCache[key];for(key in BaseTextureCache)delete BaseTextureCache[key]}class CanvasRenderTarget{constructor(width,height,resolution){this._canvas=settings.ADAPTER.createCanvas(),this._context=this._canvas.getContext("2d"),this.resolution=resolution||settings.RESOLUTION,this.resize(width,height)}clear(){this._checkDestroyed(),this._context.setTransform(1,0,0,1,0,0),this._context.clearRect(0,0,this._canvas.width,this._canvas.height)}resize(desiredWidth,desiredHeight){this._checkDestroyed(),this._canvas.width=Math.round(desiredWidth*this.resolution),this._canvas.height=Math.round(desiredHeight*this.resolution)}destroy(){this._context=null,this._canvas=null}get width(){return this._checkDestroyed(),this._canvas.width}set width(val){this._checkDestroyed(),this._canvas.width=Math.round(val)}get height(){return this._checkDestroyed(),this._canvas.height}set height(val){this._checkDestroyed(),this._canvas.height=Math.round(val)}get canvas(){return this._checkDestroyed(),this._canvas}get context(){return this._checkDestroyed(),this._context}_checkDestroyed(){if(null===this._canvas)throw new TypeError("The CanvasRenderTarget has already been destroyed")}}function checkRow(data,width,y){for(let x=0,index=4*y*width;x<width;++x,index+=4)if(0!==data[index+3])return!1;return!0}function checkColumn(data,width,x,top,bottom){const stride=4*width;for(let y=top,index=top*stride+4*x;y<=bottom;++y,index+=stride)if(0!==data[index+3])return!1;return!0}function getCanvasBoundingBox(canvas){const{width,height}=canvas,context=canvas.getContext("2d",{willReadFrequently:!0});if(null===context)throw new TypeError("Failed to get canvas 2D context");const data=context.getImageData(0,0,width,height).data;let left=0,top=0,right=width-1,bottom=height-1;for(;top<height&&checkRow(data,width,top);)++top;if(top===height)return BoundingBox.EMPTY;for(;checkRow(data,width,bottom);)--bottom;for(;checkColumn(data,width,left,top,bottom);)++left;for(;checkColumn(data,width,right,top,bottom);)--right;return++right,++bottom,new BoundingBox(left,top,right,bottom)}function trimCanvas(canvas){const boundingBox=getCanvasBoundingBox(canvas),{width,height}=boundingBox;let data=null;if(!boundingBox.isEmpty()){const context=canvas.getContext("2d");if(null===context)throw new TypeError("Failed to get canvas 2D context");data=context.getImageData(boundingBox.left,boundingBox.top,width,height)}return{width,height,data}}function decomposeDataUri(dataUri){const dataUriMatch=DATA_URI.exec(dataUri);if(dataUriMatch)return{mediaType:dataUriMatch[1]?dataUriMatch[1].toLowerCase():void 0,subType:dataUriMatch[2]?dataUriMatch[2].toLowerCase():void 0,charset:dataUriMatch[3]?dataUriMatch[3].toLowerCase():void 0,encoding:dataUriMatch[4]?dataUriMatch[4].toLowerCase():void 0,data:dataUriMatch[5]}}function determineCrossOrigin(url,loc=globalThis.location){if(url.startsWith("data:"))return"";loc=loc||globalThis.location;const parsedUrl=new URL(url,document.baseURI);return parsedUrl.hostname!==loc.hostname||parsedUrl.port!==loc.port||parsedUrl.protocol!==loc.protocol?"anonymous":""}function getResolutionOfUrl(url,defaultValue=1){const resolution=settings.RETINA_PREFIX?.exec(url);return resolution?parseFloat(resolution[1]):defaultValue}var ExtensionType=(ExtensionType2=>(ExtensionType2.Renderer="renderer",ExtensionType2.Application="application",ExtensionType2.RendererSystem="renderer-webgl-system",ExtensionType2.RendererPlugin="renderer-webgl-plugin",ExtensionType2.CanvasRendererSystem="renderer-canvas-system",ExtensionType2.CanvasRendererPlugin="renderer-canvas-plugin",ExtensionType2.Asset="asset",ExtensionType2.LoadParser="load-parser",ExtensionType2.ResolveParser="resolve-parser",ExtensionType2.CacheParser="cache-parser",ExtensionType2.DetectionParser="detection-parser",ExtensionType2))(ExtensionType||{});const normalizeExtension=ext=>{if("function"==typeof ext||"object"==typeof ext&&ext.extension){if(!ext.extension)throw new Error("Extension class must have an extension object");ext={..."object"!=typeof ext.extension?{type:ext.extension}:ext.extension,ref:ext}}if("object"!=typeof ext)throw new Error("Invalid extension type");return"string"==typeof(ext={...ext}).type&&(ext.type=[ext.type]),ext},normalizePriority=(ext,defaultPriority)=>normalizeExtension(ext).priority??defaultPriority,extensions={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...extensions2){return extensions2.map(normalizeExtension).forEach((ext=>{ext.type.forEach((type=>this._removeHandlers[type]?.(ext)))})),this},add(...extensions2){return extensions2.map(normalizeExtension).forEach((ext=>{ext.type.forEach((type=>{const handlers=this._addHandlers,queue=this._queue;handlers[type]?handlers[type](ext):(queue[type]=queue[type]||[],queue[type].push(ext))}))})),this},handle(type,onAdd,onRemove){const addHandlers=this._addHandlers,removeHandlers=this._removeHandlers;if(addHandlers[type]||removeHandlers[type])throw new Error(`Extension type ${type} already has a handler`);addHandlers[type]=onAdd,removeHandlers[type]=onRemove;const queue=this._queue;return queue[type]&&(queue[type].forEach((ext=>onAdd(ext))),delete queue[type]),this},handleByMap(type,map){return this.handle(type,(extension=>{map[extension.name]=extension.ref}),(extension=>{delete map[extension.name]}))},handleByList(type,list,defaultPriority=-1){return this.handle(type,(extension=>{list.includes(extension.ref)||(list.push(extension.ref),list.sort(((a,b)=>normalizePriority(b,defaultPriority)-normalizePriority(a,defaultPriority))))}),(extension=>{const index=list.indexOf(extension.ref);-1!==index&&list.splice(index,1)}))}};class ViewableBuffer{constructor(sizeOrBuffer){"number"==typeof sizeOrBuffer?this.rawBinaryData=new ArrayBuffer(sizeOrBuffer):sizeOrBuffer instanceof Uint8Array?this.rawBinaryData=sizeOrBuffer.buffer:this.rawBinaryData=sizeOrBuffer,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData)}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get uint16View(){return this._uint16View||(this._uint16View=new Uint16Array(this.rawBinaryData)),this._uint16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}view(type){return this[`${type}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this._uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(type){switch(type){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${type} isn't a valid view type`)}}}const fragTemplate=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join("\n");function generateIfTestSrc(maxIfs){let src="";for(let i=0;i<maxIfs;++i)i>0&&(src+="\nelse "),i<maxIfs-1&&(src+=`if(test == ${i}.0){}`);return src}class State{constructor(){this.data=0,this.blendMode=BLEND_MODES.NORMAL,this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(value){!!(1&this.data)!==value&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(value){!!(2&this.data)!==value&&(this.data^=2)}get culling(){return!!(4&this.data)}set culling(value){!!(4&this.data)!==value&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(value){!!(8&this.data)!==value&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(value){!!(32&this.data)!==value&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(value){!!(16&this.data)!==value&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(value){this.blend=value!==BLEND_MODES.NONE,this._blendMode=value}get polygonOffset(){return this._polygonOffset}set polygonOffset(value){this.offsets=!!value,this._polygonOffset=value}static for2d(){const state=new State;return state.depthTest=!1,state.blend=!0,state}}State.prototype.toString=function(){return`[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`};const INSTALLED=[];function autoDetectResource(source,options){if(!source)return null;let extension="";if("string"==typeof source){const result=/\.(\w{3,4})(?:$|\?|#)/i.exec(source);result&&(extension=result[1].toLowerCase())}for(let i=INSTALLED.length-1;i>=0;--i){const ResourcePlugin=INSTALLED[i];if(ResourcePlugin.test&&ResourcePlugin.test(source,extension))return new ResourcePlugin(source,options)}throw new Error("Unrecognized source type to auto-detect Resource")}class Runner_Runner{constructor(name){this.items=[],this._name=name,this._aliasCount=0}emit(a0,a1,a2,a3,a4,a5,a6,a7){if(arguments.length>8)throw new Error("max arguments reached");const{name,items}=this;this._aliasCount++;for(let i=0,len=items.length;i<len;i++)items[i][name](a0,a1,a2,a3,a4,a5,a6,a7);return items===this.items&&this._aliasCount--,this}ensureNonAliasedItems(){this._aliasCount>0&&this.items.length>1&&(this._aliasCount=0,this.items=this.items.slice(0))}add(item){return item[this._name]&&(this.ensureNonAliasedItems(),this.remove(item),this.items.push(item)),this}remove(item){const index=this.items.indexOf(item);return-1!==index&&(this.ensureNonAliasedItems(),this.items.splice(index,1)),this}contains(item){return this.items.includes(item)}removeAll(){return this.ensureNonAliasedItems(),this.items.length=0,this}destroy(){this.removeAll(),this.items=null,this._name=null}get empty(){return 0===this.items.length}get name(){return this._name}}Object.defineProperties(Runner_Runner.prototype,{dispatch:{value:Runner_Runner.prototype.emit},run:{value:Runner_Runner.prototype.emit}});class Resource{constructor(width=0,height=0){this._width=width,this._height=height,this.destroyed=!1,this.internal=!1,this.onResize=new Runner_Runner("setRealSize"),this.onUpdate=new Runner_Runner("update"),this.onError=new Runner_Runner("onError")}bind(baseTexture){this.onResize.add(baseTexture),this.onUpdate.add(baseTexture),this.onError.add(baseTexture),(this._width||this._height)&&this.onResize.emit(this._width,this._height)}unbind(baseTexture){this.onResize.remove(baseTexture),this.onUpdate.remove(baseTexture),this.onError.remove(baseTexture)}resize(width,height){(width!==this._width||height!==this._height)&&(this._width=width,this._height=height,this.onResize.emit(width,height))}get valid(){return!!this._width&&!!this._height}update(){this.destroyed||this.onUpdate.emit()}load(){return Promise.resolve(this)}get width(){return this._width}get height(){return this._height}style(_renderer,_baseTexture,_glTexture){return!1}dispose(){}destroy(){this.destroyed||(this.destroyed=!0,this.dispose(),this.onError.removeAll(),this.onError=null,this.onResize.removeAll(),this.onResize=null,this.onUpdate.removeAll(),this.onUpdate=null)}static test(_source,_extension){return!1}}class BufferResource extends Resource{constructor(source,options){const{width,height}=options||{};if(!width||!height)throw new Error("BufferResource width or height invalid");super(width,height),this.data=source,this.unpackAlignment=options.unpackAlignment??4}upload(renderer,baseTexture,glTexture){const gl=renderer.gl;gl.pixelStorei(gl.UNPACK_ALIGNMENT,this.unpackAlignment),gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,baseTexture.alphaMode===ALPHA_MODES.UNPACK);const width=baseTexture.realWidth,height=baseTexture.realHeight;return glTexture.width===width&&glTexture.height===height?gl.texSubImage2D(baseTexture.target,0,0,0,width,height,baseTexture.format,glTexture.type,this.data):(glTexture.width=width,glTexture.height=height,gl.texImage2D(baseTexture.target,0,glTexture.internalFormat,width,height,0,baseTexture.format,glTexture.type,this.data)),!0}dispose(){this.data=null}static test(source){return null===source||source instanceof Int8Array||source instanceof Uint8Array||source instanceof Uint8ClampedArray||source instanceof Int16Array||source instanceof Uint16Array||source instanceof Int32Array||source instanceof Uint32Array||source instanceof Float32Array}}const defaultBufferOptions={scaleMode:SCALE_MODES.NEAREST,alphaMode:ALPHA_MODES.NPM},_BaseTexture=class _BaseTexture2 extends(eventemitter3_default()){constructor(resource=null,options=null){super(),options=Object.assign({},_BaseTexture2.defaultOptions,options);const{alphaMode,mipmap,anisotropicLevel,scaleMode,width,height,wrapMode,format,type,target,resolution,resourceOptions}=options;resource&&!(resource instanceof Resource)&&((resource=autoDetectResource(resource,resourceOptions)).internal=!0),this.resolution=resolution||settings.RESOLUTION,this.width=Math.round((width||0)*this.resolution)/this.resolution,this.height=Math.round((height||0)*this.resolution)/this.resolution,this._mipmap=mipmap,this.anisotropicLevel=anisotropicLevel,this._wrapMode=wrapMode,this._scaleMode=scaleMode,this.format=format,this.type=type,this.target=target,this.alphaMode=alphaMode,this.uid=uid(),this.touched=0,this.isPowerOfTwo=!1,this._refreshPOT(),this._glTextures={},this.dirtyId=0,this.dirtyStyleId=0,this.cacheId=null,this.valid=width>0&&height>0,this.textureCacheIds=[],this.destroyed=!1,this.resource=null,this._batchEnabled=0,this._batchLocation=0,this.parentTextureArray=null,this.setResource(resource)}get realWidth(){return Math.round(this.width*this.resolution)}get realHeight(){return Math.round(this.height*this.resolution)}get mipmap(){return this._mipmap}set mipmap(value){this._mipmap!==value&&(this._mipmap=value,this.dirtyStyleId++)}get scaleMode(){return this._scaleMode}set scaleMode(value){this._scaleMode!==value&&(this._scaleMode=value,this.dirtyStyleId++)}get wrapMode(){return this._wrapMode}set wrapMode(value){this._wrapMode!==value&&(this._wrapMode=value,this.dirtyStyleId++)}setStyle(scaleMode,mipmap){let dirty;return void 0!==scaleMode&&scaleMode!==this.scaleMode&&(this.scaleMode=scaleMode,dirty=!0),void 0!==mipmap&&mipmap!==this.mipmap&&(this.mipmap=mipmap,dirty=!0),dirty&&this.dirtyStyleId++,this}setSize(desiredWidth,desiredHeight,resolution){return resolution=resolution||this.resolution,this.setRealSize(desiredWidth*resolution,desiredHeight*resolution,resolution)}setRealSize(realWidth,realHeight,resolution){return this.resolution=resolution||this.resolution,this.width=Math.round(realWidth)/this.resolution,this.height=Math.round(realHeight)/this.resolution,this._refreshPOT(),this.update(),this}_refreshPOT(){this.isPowerOfTwo=isPow2(this.realWidth)&&isPow2(this.realHeight)}setResolution(resolution){const oldResolution=this.resolution;return oldResolution===resolution||(this.resolution=resolution,this.valid&&(this.width=Math.round(this.width*oldResolution)/resolution,this.height=Math.round(this.height*oldResolution)/resolution,this.emit("update",this)),this._refreshPOT()),this}setResource(resource){if(this.resource===resource)return this;if(this.resource)throw new Error("Resource can be set only once");return resource.bind(this),this.resource=resource,this}update(){this.valid?(this.dirtyId++,this.dirtyStyleId++,this.emit("update",this)):this.width>0&&this.height>0&&(this.valid=!0,this.emit("loaded",this),this.emit("update",this))}onError(event){this.emit("error",this,event)}destroy(){this.resource&&(this.resource.unbind(this),this.resource.internal&&this.resource.destroy(),this.resource=null),this.cacheId&&(delete BaseTextureCache[this.cacheId],delete TextureCache[this.cacheId],this.cacheId=null),this.valid=!1,this.dispose(),_BaseTexture2.removeFromCache(this),this.textureCacheIds=null,this.destroyed=!0,this.emit("destroyed",this),this.removeAllListeners()}dispose(){this.emit("dispose",this)}castToBaseTexture(){return this}static from(source,options,strict=settings.STRICT_TEXTURE_CACHE){const isFrame="string"==typeof source;let cacheId=null;if(isFrame)cacheId=source;else{if(!source._pixiId){const prefix=options?.pixiIdPrefix||"pixiid";source._pixiId=`${prefix}_${uid()}`}cacheId=source._pixiId}let baseTexture=BaseTextureCache[cacheId];if(isFrame&&strict&&!baseTexture)throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);return baseTexture||(baseTexture=new _BaseTexture2(source,options),baseTexture.cacheId=cacheId,_BaseTexture2.addToCache(baseTexture,cacheId)),baseTexture}static fromBuffer(buffer,width,height,options){buffer=buffer||new Float32Array(width*height*4);const resource=new BufferResource(buffer,{width,height,...options?.resourceOptions});let format,type;return buffer instanceof Float32Array?(format=FORMATS.RGBA,type=TYPES.FLOAT):buffer instanceof Int32Array?(format=FORMATS.RGBA_INTEGER,type=TYPES.INT):buffer instanceof Uint32Array?(format=FORMATS.RGBA_INTEGER,type=TYPES.UNSIGNED_INT):buffer instanceof Int16Array?(format=FORMATS.RGBA_INTEGER,type=TYPES.SHORT):buffer instanceof Uint16Array?(format=FORMATS.RGBA_INTEGER,type=TYPES.UNSIGNED_SHORT):buffer instanceof Int8Array?(format=FORMATS.RGBA,type=TYPES.BYTE):(format=FORMATS.RGBA,type=TYPES.UNSIGNED_BYTE),resource.internal=!0,new _BaseTexture2(resource,Object.assign({},defaultBufferOptions,{type,format},options))}static addToCache(baseTexture,id){id&&(baseTexture.textureCacheIds.includes(id)||baseTexture.textureCacheIds.push(id),BaseTextureCache[id]&&BaseTextureCache[id]!==baseTexture&&console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`),BaseTextureCache[id]=baseTexture)}static removeFromCache(baseTexture){if("string"==typeof baseTexture){const baseTextureFromCache=BaseTextureCache[baseTexture];if(baseTextureFromCache){const index=baseTextureFromCache.textureCacheIds.indexOf(baseTexture);return index>-1&&baseTextureFromCache.textureCacheIds.splice(index,1),delete BaseTextureCache[baseTexture],baseTextureFromCache}}else if(baseTexture?.textureCacheIds){for(let i=0;i<baseTexture.textureCacheIds.length;++i)delete BaseTextureCache[baseTexture.textureCacheIds[i]];return baseTexture.textureCacheIds.length=0,baseTexture}return null}};_BaseTexture.defaultOptions={mipmap:MIPMAP_MODES.POW2,anisotropicLevel:0,scaleMode:SCALE_MODES.LINEAR,wrapMode:WRAP_MODES.CLAMP,alphaMode:ALPHA_MODES.UNPACK,target:TARGETS.TEXTURE_2D,format:FORMATS.RGBA,type:TYPES.UNSIGNED_BYTE},_BaseTexture._globalBatch=0;let BaseTexture=_BaseTexture;class BatchDrawCall{constructor(){this.texArray=null,this.blend=0,this.type=DRAW_MODES.TRIANGLES,this.start=0,this.size=0,this.data=null}}let UID=0;class Buffer{constructor(data,_static=!0,index=!1){this.data=data||new Float32Array(1),this._glBuffers={},this._updateID=0,this.index=index,this.static=_static,this.id=UID++,this.disposeRunner=new Runner_Runner("disposeBuffer")}update(data){data instanceof Array&&(data=new Float32Array(data)),this.data=data||this.data,this._updateID++}dispose(){this.disposeRunner.emit(this,!1)}destroy(){this.dispose(),this.data=null}set index(value){this.type=value?BUFFER_TYPE.ELEMENT_ARRAY_BUFFER:BUFFER_TYPE.ARRAY_BUFFER}get index(){return this.type===BUFFER_TYPE.ELEMENT_ARRAY_BUFFER}static from(data){return data instanceof Array&&(data=new Float32Array(data)),new Buffer(data)}}class Attribute{constructor(buffer,size=0,normalized=!1,type=TYPES.FLOAT,stride,start,instance,divisor=1){this.buffer=buffer,this.size=size,this.normalized=normalized,this.type=type,this.stride=stride,this.start=start,this.instance=instance,this.divisor=divisor}destroy(){this.buffer=null}static from(buffer,size,normalized,type,stride){return new Attribute(buffer,size,normalized,type,stride)}}const interleaveTypedArrays_map={Float32Array,Uint32Array,Int32Array,Uint8Array};const byteSizeMap={5126:4,5123:2,5121:1};let Geometry_UID=0;const Geometry_map={Float32Array,Uint32Array,Int32Array,Uint8Array,Uint16Array};class Geometry{constructor(buffers=[],attributes={}){this.buffers=buffers,this.indexBuffer=null,this.attributes=attributes,this.glVertexArrayObjects={},this.id=Geometry_UID++,this.instanced=!1,this.instanceCount=1,this.disposeRunner=new Runner_Runner("disposeGeometry"),this.refCount=0}addAttribute(id,buffer,size=0,normalized=!1,type,stride,start,instance=!1){if(!buffer)throw new Error("You must pass a buffer when creating an attribute");buffer instanceof Buffer||(buffer instanceof Array&&(buffer=new Float32Array(buffer)),buffer=new Buffer(buffer));const ids=id.split("|");if(ids.length>1){for(let i=0;i<ids.length;i++)this.addAttribute(ids[i],buffer,size,normalized,type);return this}let bufferIndex=this.buffers.indexOf(buffer);return-1===bufferIndex&&(this.buffers.push(buffer),bufferIndex=this.buffers.length-1),this.attributes[id]=new Attribute(bufferIndex,size,normalized,type,stride,start,instance),this.instanced=this.instanced||instance,this}getAttribute(id){return this.attributes[id]}getBuffer(id){return this.buffers[this.getAttribute(id).buffer]}addIndex(buffer){return buffer instanceof Buffer||(buffer instanceof Array&&(buffer=new Uint16Array(buffer)),buffer=new Buffer(buffer)),buffer.type=BUFFER_TYPE.ELEMENT_ARRAY_BUFFER,this.indexBuffer=buffer,this.buffers.includes(buffer)||this.buffers.push(buffer),this}getIndex(){return this.indexBuffer}interleave(){if(1===this.buffers.length||2===this.buffers.length&&this.indexBuffer)return this;const arrays=[],sizes=[],interleavedBuffer=new Buffer;let i;for(i in this.attributes){const attribute=this.attributes[i],buffer=this.buffers[attribute.buffer];arrays.push(buffer.data),sizes.push(attribute.size*byteSizeMap[attribute.type]/4),attribute.buffer=0}for(interleavedBuffer.data=function interleaveTypedArrays_interleaveTypedArrays(arrays,sizes){let outSize=0,stride=0;const views={};for(let i=0;i<arrays.length;i++)stride+=sizes[i],outSize+=arrays[i].length;const buffer=new ArrayBuffer(4*outSize);let out=null,littleOffset=0;for(let i=0;i<arrays.length;i++){const size=sizes[i],array=arrays[i],type=getBufferType(array);views[type]||(views[type]=new interleaveTypedArrays_map[type](buffer)),out=views[type];for(let j=0;j<array.length;j++)out[(j/size|0)*stride+littleOffset+j%size]=array[j];littleOffset+=size}return new Float32Array(buffer)}(arrays,sizes),i=0;i<this.buffers.length;i++)this.buffers[i]!==this.indexBuffer&&this.buffers[i].destroy();return this.buffers=[interleavedBuffer],this.indexBuffer&&this.buffers.push(this.indexBuffer),this}getSize(){for(const i in this.attributes){const attribute=this.attributes[i];return this.buffers[attribute.buffer].data.length/(attribute.stride/4||attribute.size)}return 0}dispose(){this.disposeRunner.emit(this,!1)}destroy(){this.dispose(),this.buffers=null,this.indexBuffer=null,this.attributes=null}clone(){const geometry=new Geometry;for(let i=0;i<this.buffers.length;i++)geometry.buffers[i]=new Buffer(this.buffers[i].data.slice(0));for(const i in this.attributes){const attrib=this.attributes[i];geometry.attributes[i]=new Attribute(attrib.buffer,attrib.size,attrib.normalized,attrib.type,attrib.stride,attrib.start,attrib.instance)}return this.indexBuffer&&(geometry.indexBuffer=geometry.buffers[this.buffers.indexOf(this.indexBuffer)],geometry.indexBuffer.type=BUFFER_TYPE.ELEMENT_ARRAY_BUFFER),geometry}static merge(geometries){const geometryOut=new Geometry,arrays=[],sizes=[],offsets=[];let geometry;for(let i=0;i<geometries.length;i++){geometry=geometries[i];for(let j=0;j<geometry.buffers.length;j++)sizes[j]=sizes[j]||0,sizes[j]+=geometry.buffers[j].data.length,offsets[j]=0}for(let i=0;i<geometry.buffers.length;i++)arrays[i]=new(Geometry_map[getBufferType(geometry.buffers[i].data)])(sizes[i]),geometryOut.buffers[i]=new Buffer(arrays[i]);for(let i=0;i<geometries.length;i++){geometry=geometries[i];for(let j=0;j<geometry.buffers.length;j++)arrays[j].set(geometry.buffers[j].data,offsets[j]),offsets[j]+=geometry.buffers[j].data.length}if(geometryOut.attributes=geometry.attributes,geometry.indexBuffer){geometryOut.indexBuffer=geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)],geometryOut.indexBuffer.type=BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;let offset=0,stride=0,offset2=0,bufferIndexToCount=0;for(let i=0;i<geometry.buffers.length;i++)if(geometry.buffers[i]!==geometry.indexBuffer){bufferIndexToCount=i;break}for(const i in geometry.attributes){const attribute=geometry.attributes[i];(0|attribute.buffer)===bufferIndexToCount&&(stride+=attribute.size*byteSizeMap[attribute.type]/4)}for(let i=0;i<geometries.length;i++){const indexBufferData=geometries[i].indexBuffer.data;for(let j=0;j<indexBufferData.length;j++)geometryOut.indexBuffer.data[j+offset2]+=offset;offset+=geometries[i].buffers[bufferIndexToCount].data.length/stride,offset2+=indexBufferData.length}}return geometryOut}}class BatchGeometry extends Geometry{constructor(_static=!1){super(),this._buffer=new Buffer(null,_static,!1),this._indexBuffer=new Buffer(null,_static,!0),this.addAttribute("aVertexPosition",this._buffer,2,!1,TYPES.FLOAT).addAttribute("aTextureCoord",this._buffer,2,!1,TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,TYPES.UNSIGNED_BYTE).addAttribute("aTextureId",this._buffer,1,!0,TYPES.FLOAT).addIndex(this._indexBuffer)}}const PI_2=2*Math.PI,RAD_TO_DEG=180/Math.PI,DEG_TO_RAD=Math.PI/180;var SHAPES=(SHAPES2=>(SHAPES2[SHAPES2.POLY=0]="POLY",SHAPES2[SHAPES2.RECT=1]="RECT",SHAPES2[SHAPES2.CIRC=2]="CIRC",SHAPES2[SHAPES2.ELIP=3]="ELIP",SHAPES2[SHAPES2.RREC=4]="RREC",SHAPES2))(SHAPES||{});class Point{constructor(x=0,y=0){this.x=0,this.y=0,this.x=x,this.y=y}clone(){return new Point(this.x,this.y)}copyFrom(p){return this.set(p.x,p.y),this}copyTo(p){return p.set(this.x,this.y),p}equals(p){return p.x===this.x&&p.y===this.y}set(x=0,y=x){return this.x=x,this.y=y,this}}Point.prototype.toString=function(){return`[@pixi/math:Point x=${this.x} y=${this.y}]`};const tempPoints=[new Point,new Point,new Point,new Point];class Rectangle{constructor(x=0,y=0,width=0,height=0){this.x=Number(x),this.y=Number(y),this.width=Number(width),this.height=Number(height),this.type=SHAPES.RECT}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}static get EMPTY(){return new Rectangle(0,0,0,0)}clone(){return new Rectangle(this.x,this.y,this.width,this.height)}copyFrom(rectangle){return this.x=rectangle.x,this.y=rectangle.y,this.width=rectangle.width,this.height=rectangle.height,this}copyTo(rectangle){return rectangle.x=this.x,rectangle.y=this.y,rectangle.width=this.width,rectangle.height=this.height,rectangle}contains(x,y){return!(this.width<=0||this.height<=0)&&(x>=this.x&&x<this.x+this.width&&y>=this.y&&y<this.y+this.height)}intersects(other,transform){if(!transform){const x02=this.x<other.x?other.x:this.x;if((this.right>other.right?other.right:this.right)<=x02)return!1;const y02=this.y<other.y?other.y:this.y;return(this.bottom>other.bottom?other.bottom:this.bottom)>y02}const x0=this.left,x1=this.right,y0=this.top,y1=this.bottom;if(x1<=x0||y1<=y0)return!1;const lt=tempPoints[0].set(other.left,other.top),lb=tempPoints[1].set(other.left,other.bottom),rt=tempPoints[2].set(other.right,other.top),rb=tempPoints[3].set(other.right,other.bottom);if(rt.x<=lt.x||lb.y<=lt.y)return!1;const s=Math.sign(transform.a*transform.d-transform.b*transform.c);if(0===s||(transform.apply(lt,lt),transform.apply(lb,lb),transform.apply(rt,rt),transform.apply(rb,rb),Math.max(lt.x,lb.x,rt.x,rb.x)<=x0||Math.min(lt.x,lb.x,rt.x,rb.x)>=x1||Math.max(lt.y,lb.y,rt.y,rb.y)<=y0||Math.min(lt.y,lb.y,rt.y,rb.y)>=y1))return!1;const nx=s*(lb.y-lt.y),ny=s*(lt.x-lb.x),n00=nx*x0+ny*y0,n10=nx*x1+ny*y0,n01=nx*x0+ny*y1,n11=nx*x1+ny*y1;if(Math.max(n00,n10,n01,n11)<=nx*lt.x+ny*lt.y||Math.min(n00,n10,n01,n11)>=nx*rb.x+ny*rb.y)return!1;const mx=s*(lt.y-rt.y),my=s*(rt.x-lt.x),m00=mx*x0+my*y0,m10=mx*x1+my*y0,m01=mx*x0+my*y1,m11=mx*x1+my*y1;return!(Math.max(m00,m10,m01,m11)<=mx*lt.x+my*lt.y||Math.min(m00,m10,m01,m11)>=mx*rb.x+my*rb.y)}pad(paddingX=0,paddingY=paddingX){return this.x-=paddingX,this.y-=paddingY,this.width+=2*paddingX,this.height+=2*paddingY,this}fit(rectangle){const x1=Math.max(this.x,rectangle.x),x2=Math.min(this.x+this.width,rectangle.x+rectangle.width),y1=Math.max(this.y,rectangle.y),y2=Math.min(this.y+this.height,rectangle.y+rectangle.height);return this.x=x1,this.width=Math.max(x2-x1,0),this.y=y1,this.height=Math.max(y2-y1,0),this}ceil(resolution=1,eps=.001){const x2=Math.ceil((this.x+this.width-eps)*resolution)/resolution,y2=Math.ceil((this.y+this.height-eps)*resolution)/resolution;return this.x=Math.floor((this.x+eps)*resolution)/resolution,this.y=Math.floor((this.y+eps)*resolution)/resolution,this.width=x2-this.x,this.height=y2-this.y,this}enlarge(rectangle){const x1=Math.min(this.x,rectangle.x),x2=Math.max(this.x+this.width,rectangle.x+rectangle.width),y1=Math.min(this.y,rectangle.y),y2=Math.max(this.y+this.height,rectangle.y+rectangle.height);return this.x=x1,this.width=x2-x1,this.y=y1,this.height=y2-y1,this}}Rectangle.prototype.toString=function(){return`[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`};class Circle{constructor(x=0,y=0,radius=0){this.x=x,this.y=y,this.radius=radius,this.type=SHAPES.CIRC}clone(){return new Circle(this.x,this.y,this.radius)}contains(x,y){if(this.radius<=0)return!1;const r2=this.radius*this.radius;let dx=this.x-x,dy=this.y-y;return dx*=dx,dy*=dy,dx+dy<=r2}getBounds(){return new Rectangle(this.x-this.radius,this.y-this.radius,2*this.radius,2*this.radius)}}Circle.prototype.toString=function(){return`[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`};class Ellipse{constructor(x=0,y=0,halfWidth=0,halfHeight=0){this.x=x,this.y=y,this.width=halfWidth,this.height=halfHeight,this.type=SHAPES.ELIP}clone(){return new Ellipse(this.x,this.y,this.width,this.height)}contains(x,y){if(this.width<=0||this.height<=0)return!1;let normx=(x-this.x)/this.width,normy=(y-this.y)/this.height;return normx*=normx,normy*=normy,normx+normy<=1}getBounds(){return new Rectangle(this.x-this.width,this.y-this.height,this.width,this.height)}}Ellipse.prototype.toString=function(){return`[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`};class Polygon{constructor(...points){let flat=Array.isArray(points[0])?points[0]:points;if("number"!=typeof flat[0]){const p=[];for(let i=0,il=flat.length;i<il;i++)p.push(flat[i].x,flat[i].y);flat=p}this.points=flat,this.type=SHAPES.POLY,this.closeStroke=!0}clone(){const points=this.points.slice(),polygon=new Polygon(points);return polygon.closeStroke=this.closeStroke,polygon}contains(x,y){let inside=!1;const length=this.points.length/2;for(let i=0,j=length-1;i<length;j=i++){const xi=this.points[2*i],yi=this.points[2*i+1],xj=this.points[2*j],yj=this.points[2*j+1];yi>y!=yj>y&&x<(y-yi)/(yj-yi)*(xj-xi)+xi&&(inside=!inside)}return inside}}Polygon.prototype.toString=function(){return`[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce(((pointsDesc,currentPoint)=>`${pointsDesc}, ${currentPoint}`),"")}]`};class RoundedRectangle{constructor(x=0,y=0,width=0,height=0,radius=20){this.x=x,this.y=y,this.width=width,this.height=height,this.radius=radius,this.type=SHAPES.RREC}clone(){return new RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)}contains(x,y){if(this.width<=0||this.height<=0)return!1;if(x>=this.x&&x<=this.x+this.width&&y>=this.y&&y<=this.y+this.height){const radius=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(y>=this.y+radius&&y<=this.y+this.height-radius||x>=this.x+radius&&x<=this.x+this.width-radius)return!0;let dx=x-(this.x+radius),dy=y-(this.y+radius);const radius2=radius*radius;if(dx*dx+dy*dy<=radius2||(dx=x-(this.x+this.width-radius),dx*dx+dy*dy<=radius2)||(dy=y-(this.y+this.height-radius),dx*dx+dy*dy<=radius2)||(dx=x-(this.x+radius),dx*dx+dy*dy<=radius2))return!0}return!1}}RoundedRectangle.prototype.toString=function(){return`[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`};class Matrix{constructor(a=1,b=0,c=0,d=1,tx=0,ty=0){this.array=null,this.a=a,this.b=b,this.c=c,this.d=d,this.tx=tx,this.ty=ty}fromArray(array){this.a=array[0],this.b=array[1],this.c=array[3],this.d=array[4],this.tx=array[2],this.ty=array[5]}set(a,b,c,d,tx,ty){return this.a=a,this.b=b,this.c=c,this.d=d,this.tx=tx,this.ty=ty,this}toArray(transpose,out){this.array||(this.array=new Float32Array(9));const array=out||this.array;return transpose?(array[0]=this.a,array[1]=this.b,array[2]=0,array[3]=this.c,array[4]=this.d,array[5]=0,array[6]=this.tx,array[7]=this.ty,array[8]=1):(array[0]=this.a,array[1]=this.c,array[2]=this.tx,array[3]=this.b,array[4]=this.d,array[5]=this.ty,array[6]=0,array[7]=0,array[8]=1),array}apply(pos,newPos){newPos=newPos||new Point;const x=pos.x,y=pos.y;return newPos.x=this.a*x+this.c*y+this.tx,newPos.y=this.b*x+this.d*y+this.ty,newPos}applyInverse(pos,newPos){newPos=newPos||new Point;const id=1/(this.a*this.d+this.c*-this.b),x=pos.x,y=pos.y;return newPos.x=this.d*id*x+-this.c*id*y+(this.ty*this.c-this.tx*this.d)*id,newPos.y=this.a*id*y+-this.b*id*x+(-this.ty*this.a+this.tx*this.b)*id,newPos}translate(x,y){return this.tx+=x,this.ty+=y,this}scale(x,y){return this.a*=x,this.d*=y,this.c*=x,this.b*=y,this.tx*=x,this.ty*=y,this}rotate(angle){const cos=Math.cos(angle),sin=Math.sin(angle),a1=this.a,c1=this.c,tx1=this.tx;return this.a=a1*cos-this.b*sin,this.b=a1*sin+this.b*cos,this.c=c1*cos-this.d*sin,this.d=c1*sin+this.d*cos,this.tx=tx1*cos-this.ty*sin,this.ty=tx1*sin+this.ty*cos,this}append(matrix){const a1=this.a,b1=this.b,c1=this.c,d1=this.d;return this.a=matrix.a*a1+matrix.b*c1,this.b=matrix.a*b1+matrix.b*d1,this.c=matrix.c*a1+matrix.d*c1,this.d=matrix.c*b1+matrix.d*d1,this.tx=matrix.tx*a1+matrix.ty*c1+this.tx,this.ty=matrix.tx*b1+matrix.ty*d1+this.ty,this}setTransform(x,y,pivotX,pivotY,scaleX,scaleY,rotation,skewX,skewY){return this.a=Math.cos(rotation+skewY)*scaleX,this.b=Math.sin(rotation+skewY)*scaleX,this.c=-Math.sin(rotation-skewX)*scaleY,this.d=Math.cos(rotation-skewX)*scaleY,this.tx=x-(pivotX*this.a+pivotY*this.c),this.ty=y-(pivotX*this.b+pivotY*this.d),this}prepend(matrix){const tx1=this.tx;if(1!==matrix.a||0!==matrix.b||0!==matrix.c||1!==matrix.d){const a1=this.a,c1=this.c;this.a=a1*matrix.a+this.b*matrix.c,this.b=a1*matrix.b+this.b*matrix.d,this.c=c1*matrix.a+this.d*matrix.c,this.d=c1*matrix.b+this.d*matrix.d}return this.tx=tx1*matrix.a+this.ty*matrix.c+matrix.tx,this.ty=tx1*matrix.b+this.ty*matrix.d+matrix.ty,this}decompose(transform){const a=this.a,b=this.b,c=this.c,d=this.d,pivot=transform.pivot,skewX=-Math.atan2(-c,d),skewY=Math.atan2(b,a),delta=Math.abs(skewX+skewY);return delta<1e-5||Math.abs(PI_2-delta)<1e-5?(transform.rotation=skewY,transform.skew.x=transform.skew.y=0):(transform.rotation=0,transform.skew.x=skewX,transform.skew.y=skewY),transform.scale.x=Math.sqrt(a*a+b*b),transform.scale.y=Math.sqrt(c*c+d*d),transform.position.x=this.tx+(pivot.x*a+pivot.y*c),transform.position.y=this.ty+(pivot.x*b+pivot.y*d),transform}invert(){const a1=this.a,b1=this.b,c1=this.c,d1=this.d,tx1=this.tx,n=a1*d1-b1*c1;return this.a=d1/n,this.b=-b1/n,this.c=-c1/n,this.d=a1/n,this.tx=(c1*this.ty-d1*tx1)/n,this.ty=-(a1*this.ty-b1*tx1)/n,this}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const matrix=new Matrix;return matrix.a=this.a,matrix.b=this.b,matrix.c=this.c,matrix.d=this.d,matrix.tx=this.tx,matrix.ty=this.ty,matrix}copyTo(matrix){return matrix.a=this.a,matrix.b=this.b,matrix.c=this.c,matrix.d=this.d,matrix.tx=this.tx,matrix.ty=this.ty,matrix}copyFrom(matrix){return this.a=matrix.a,this.b=matrix.b,this.c=matrix.c,this.d=matrix.d,this.tx=matrix.tx,this.ty=matrix.ty,this}static get IDENTITY(){return new Matrix}static get TEMP_MATRIX(){return new Matrix}}Matrix.prototype.toString=function(){return`[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`};const ux=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],uy=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],vx=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],vy=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],rotationCayley=[],rotationMatrices=[],signum=Math.sign;!function init(){for(let i=0;i<16;i++){const row=[];rotationCayley.push(row);for(let j=0;j<16;j++){const _ux=signum(ux[i]*ux[j]+vx[i]*uy[j]),_uy=signum(uy[i]*ux[j]+vy[i]*uy[j]),_vx=signum(ux[i]*vx[j]+vx[i]*vy[j]),_vy=signum(uy[i]*vx[j]+vy[i]*vy[j]);for(let k=0;k<16;k++)if(ux[k]===_ux&&uy[k]===_uy&&vx[k]===_vx&&vy[k]===_vy){row.push(k);break}}}for(let i=0;i<16;i++){const mat=new Matrix;mat.set(ux[i],uy[i],vx[i],vy[i],0,0),rotationMatrices.push(mat)}}();const groupD8={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:ind=>ux[ind],uY:ind=>uy[ind],vX:ind=>vx[ind],vY:ind=>vy[ind],inv:rotation=>8&rotation?15&rotation:7&-rotation,add:(rotationSecond,rotationFirst)=>rotationCayley[rotationSecond][rotationFirst],sub:(rotationSecond,rotationFirst)=>rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],rotate180:rotation=>4^rotation,isVertical:rotation=>2==(3&rotation),byDirection:(dx,dy)=>2*Math.abs(dx)<=Math.abs(dy)?dy>=0?groupD8.S:groupD8.N:2*Math.abs(dy)<=Math.abs(dx)?dx>0?groupD8.E:groupD8.W:dy>0?dx>0?groupD8.SE:groupD8.SW:dx>0?groupD8.NE:groupD8.NW,matrixAppendRotationInv:(matrix,rotation,tx=0,ty=0)=>{const mat=rotationMatrices[groupD8.inv(rotation)];mat.tx=tx,mat.ty=ty,matrix.append(mat)}};class ObservablePoint{constructor(cb,scope,x=0,y=0){this._x=x,this._y=y,this.cb=cb,this.scope=scope}clone(cb=this.cb,scope=this.scope){return new ObservablePoint(cb,scope,this._x,this._y)}set(x=0,y=x){return(this._x!==x||this._y!==y)&&(this._x=x,this._y=y,this.cb.call(this.scope)),this}copyFrom(p){return(this._x!==p.x||this._y!==p.y)&&(this._x=p.x,this._y=p.y,this.cb.call(this.scope)),this}copyTo(p){return p.set(this._x,this._y),p}equals(p){return p.x===this._x&&p.y===this._y}get x(){return this._x}set x(value){this._x!==value&&(this._x=value,this.cb.call(this.scope))}get y(){return this._y}set y(value){this._y!==value&&(this._y=value,this.cb.call(this.scope))}}ObservablePoint.prototype.toString=function(){return`[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`};const _Transform=class{constructor(){this.worldTransform=new Matrix,this.localTransform=new Matrix,this.position=new ObservablePoint(this.onChange,this,0,0),this.scale=new ObservablePoint(this.onChange,this,1,1),this.pivot=new ObservablePoint(this.onChange,this,0,0),this.skew=new ObservablePoint(this.updateSkew,this,0,0),this._rotation=0,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._localID=0,this._currentLocalID=0,this._worldID=0,this._parentID=0}onChange(){this._localID++}updateSkew(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this._localID++}updateLocalTransform(){const lt=this.localTransform;this._localID!==this._currentLocalID&&(lt.a=this._cx*this.scale.x,lt.b=this._sx*this.scale.x,lt.c=this._cy*this.scale.y,lt.d=this._sy*this.scale.y,lt.tx=this.position.x-(this.pivot.x*lt.a+this.pivot.y*lt.c),lt.ty=this.position.y-(this.pivot.x*lt.b+this.pivot.y*lt.d),this._currentLocalID=this._localID,this._parentID=-1)}updateTransform(parentTransform){const lt=this.localTransform;if(this._localID!==this._currentLocalID&&(lt.a=this._cx*this.scale.x,lt.b=this._sx*this.scale.x,lt.c=this._cy*this.scale.y,lt.d=this._sy*this.scale.y,lt.tx=this.position.x-(this.pivot.x*lt.a+this.pivot.y*lt.c),lt.ty=this.position.y-(this.pivot.x*lt.b+this.pivot.y*lt.d),this._currentLocalID=this._localID,this._parentID=-1),this._parentID!==parentTransform._worldID){const pt=parentTransform.worldTransform,wt=this.worldTransform;wt.a=lt.a*pt.a+lt.b*pt.c,wt.b=lt.a*pt.b+lt.b*pt.d,wt.c=lt.c*pt.a+lt.d*pt.c,wt.d=lt.c*pt.b+lt.d*pt.d,wt.tx=lt.tx*pt.a+lt.ty*pt.c+pt.tx,wt.ty=lt.tx*pt.b+lt.ty*pt.d+pt.ty,this._parentID=parentTransform._worldID,this._worldID++}}setFromMatrix(matrix){matrix.decompose(this),this._localID++}get rotation(){return this._rotation}set rotation(value){this._rotation!==value&&(this._rotation=value,this.updateSkew())}};_Transform.IDENTITY=new _Transform;let Transform=_Transform;Transform.prototype.toString=function(){return`[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`};const uniformParsers=[{test:data=>"float"===data.type&&1===data.size&&!data.isArray,code:name=>`\n            if(uv["${name}"] !== ud["${name}"].value)\n            {\n                ud["${name}"].value = uv["${name}"]\n                gl.uniform1f(ud["${name}"].location, uv["${name}"])\n            }\n            `},{test:(data,uniform)=>!("sampler2D"!==data.type&&"samplerCube"!==data.type&&"sampler2DArray"!==data.type||1!==data.size||data.isArray||null!=uniform&&void 0===uniform.castToBaseTexture),code:name=>`t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${name}"], t);\n\n            if(ud["${name}"].value !== t)\n            {\n                ud["${name}"].value = t;\n                gl.uniform1i(ud["${name}"].location, t);\n; // eslint-disable-line max-len\n            }`},{test:(data,uniform)=>"mat3"===data.type&&1===data.size&&!data.isArray&&void 0!==uniform.a,code:name=>`\n            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));\n            `,codeUbo:name=>`\n                var ${name}_matrix = uv.${name}.toArray(true);\n\n                data[offset] = ${name}_matrix[0];\n                data[offset+1] = ${name}_matrix[1];\n                data[offset+2] = ${name}_matrix[2];\n        \n                data[offset + 4] = ${name}_matrix[3];\n                data[offset + 5] = ${name}_matrix[4];\n                data[offset + 6] = ${name}_matrix[5];\n        \n                data[offset + 8] = ${name}_matrix[6];\n                data[offset + 9] = ${name}_matrix[7];\n                data[offset + 10] = ${name}_matrix[8];\n            `},{test:(data,uniform)=>"vec2"===data.type&&1===data.size&&!data.isArray&&void 0!==uniform.x,code:name=>`\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${name}"].location, v.x, v.y);\n                }`,codeUbo:name=>`\n                v = uv.${name};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `},{test:data=>"vec2"===data.type&&1===data.size&&!data.isArray,code:name=>`\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);\n                }\n            `},{test:(data,uniform)=>"vec4"===data.type&&1===data.size&&!data.isArray&&void 0!==uniform.width,code:name=>`\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)\n                }`,codeUbo:name=>`\n                    v = uv.${name};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `},{test:(data,uniform)=>"vec4"===data.type&&1===data.size&&!data.isArray&&void 0!==uniform.red,code:name=>`\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)\n                }`,codeUbo:name=>`\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `},{test:(data,uniform)=>"vec3"===data.type&&1===data.size&&!data.isArray&&void 0!==uniform.red,code:name=>`\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)\n                }`,codeUbo:name=>`\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `},{test:data=>"vec4"===data.type&&1===data.size&&!data.isArray,code:name=>`\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])\n                }`}],GLSL_TO_SINGLE_SETTERS_CACHED={float:"\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",vec2:"\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",vec3:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",vec4:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",int:"\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",ivec2:"\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",ivec3:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",ivec4:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",uint:"\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",uvec2:"\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",uvec3:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",uvec4:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",bool:"\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",bvec2:"\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",bvec3:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",bvec4:"\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",mat2:"gl.uniformMatrix2fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",sampler2D:"\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",samplerCube:"\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",sampler2DArray:"\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }"},GLSL_TO_ARRAY_SETTERS={float:"gl.uniform1fv(location, v)",vec2:"gl.uniform2fv(location, v)",vec3:"gl.uniform3fv(location, v)",vec4:"gl.uniform4fv(location, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat2:"gl.uniformMatrix2fv(location, false, v)",int:"gl.uniform1iv(location, v)",ivec2:"gl.uniform2iv(location, v)",ivec3:"gl.uniform3iv(location, v)",ivec4:"gl.uniform4iv(location, v)",uint:"gl.uniform1uiv(location, v)",uvec2:"gl.uniform2uiv(location, v)",uvec3:"gl.uniform3uiv(location, v)",uvec4:"gl.uniform4uiv(location, v)",bool:"gl.uniform1iv(location, v)",bvec2:"gl.uniform2iv(location, v)",bvec3:"gl.uniform3iv(location, v)",bvec4:"gl.uniform4iv(location, v)",sampler2D:"gl.uniform1iv(location, v)",samplerCube:"gl.uniform1iv(location, v)",sampler2DArray:"gl.uniform1iv(location, v)"};const unknownContext={};let maxFragmentPrecision,context=unknownContext;function getMaxFragmentPrecision(){if(!maxFragmentPrecision){maxFragmentPrecision=PRECISION.MEDIUM;const gl=function getTestContext(){if(context===unknownContext||context?.isContextLost()){const canvas=settings.ADAPTER.createCanvas();let gl;settings.PREFER_ENV>=ENV.WEBGL2&&(gl=canvas.getContext("webgl2",{})),gl||(gl=canvas.getContext("webgl",{})||canvas.getContext("experimental-webgl",{}),gl?gl.getExtension("WEBGL_draw_buffers"):gl=null),context=gl}return context}();gl&&gl.getShaderPrecisionFormat&&(maxFragmentPrecision=gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision?PRECISION.HIGH:PRECISION.MEDIUM)}return maxFragmentPrecision}const GLSL_TO_SIZE={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,uint:1,uvec2:2,uvec3:3,uvec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1};function mapSize(type){return GLSL_TO_SIZE[type]}let GL_TABLE=null;const GL_TO_GLSL_TYPES={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"};function mapType(gl,type){if(!GL_TABLE){const typeNames=Object.keys(GL_TO_GLSL_TYPES);GL_TABLE={};for(let i=0;i<typeNames.length;++i){const tn=typeNames[i];GL_TABLE[gl[tn]]=GL_TO_GLSL_TYPES[tn]}}return GL_TABLE[type]}function setPrecision(src,requestedPrecision,maxSupportedPrecision){if("precision"!==src.substring(0,9)){let precision=requestedPrecision;return requestedPrecision===PRECISION.HIGH&&maxSupportedPrecision!==PRECISION.HIGH&&(precision=PRECISION.MEDIUM),`precision ${precision} float;\n${src}`}return maxSupportedPrecision!==PRECISION.HIGH&&"precision highp"===src.substring(0,15)?src.replace("precision highp","precision mediump"):src}let Program_UID=0;const nameCache={},_Program=class _Program2{constructor(vertexSrc,fragmentSrc,name="pixi-shader",extra={}){this.extra={},this.id=Program_UID++,this.vertexSrc=vertexSrc||_Program2.defaultVertexSrc,this.fragmentSrc=fragmentSrc||_Program2.defaultFragmentSrc,this.vertexSrc=this.vertexSrc.trim(),this.fragmentSrc=this.fragmentSrc.trim(),this.extra=extra,"#version"!==this.vertexSrc.substring(0,8)&&(name=name.replace(/\s+/g,"-"),nameCache[name]?(nameCache[name]++,name+=`-${nameCache[name]}`):nameCache[name]=1,this.vertexSrc=`#define SHADER_NAME ${name}\n${this.vertexSrc}`,this.fragmentSrc=`#define SHADER_NAME ${name}\n${this.fragmentSrc}`,this.vertexSrc=setPrecision(this.vertexSrc,_Program2.defaultVertexPrecision,PRECISION.HIGH),this.fragmentSrc=setPrecision(this.fragmentSrc,_Program2.defaultFragmentPrecision,getMaxFragmentPrecision())),this.glPrograms={},this.syncUniforms=null}static get defaultVertexSrc(){return"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"}static get defaultFragmentSrc(){return"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"}static from(vertexSrc,fragmentSrc,name){const key=vertexSrc+fragmentSrc;let program=ProgramCache[key];return program||(ProgramCache[key]=program=new _Program2(vertexSrc,fragmentSrc,name)),program}};_Program.defaultVertexPrecision=PRECISION.HIGH,_Program.defaultFragmentPrecision=isMobile_isMobile.apple.device?PRECISION.HIGH:PRECISION.MEDIUM;let Program=_Program,UniformGroup_UID=0;class UniformGroup{constructor(uniforms,isStatic,isUbo){this.group=!0,this.syncUniforms={},this.dirtyId=0,this.id=UniformGroup_UID++,this.static=!!isStatic,this.ubo=!!isUbo,uniforms instanceof Buffer?(this.buffer=uniforms,this.buffer.type=BUFFER_TYPE.UNIFORM_BUFFER,this.autoManage=!1,this.ubo=!0):(this.uniforms=uniforms,this.ubo&&(this.buffer=new Buffer(new Float32Array(1)),this.buffer.type=BUFFER_TYPE.UNIFORM_BUFFER,this.autoManage=!0))}update(){this.dirtyId++,!this.autoManage&&this.buffer&&this.buffer.update()}add(name,uniforms,_static){if(this.ubo)throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");this.uniforms[name]=new UniformGroup(uniforms,_static)}static from(uniforms,_static,_ubo){return new UniformGroup(uniforms,_static,_ubo)}static uboFrom(uniforms,_static){return new UniformGroup(uniforms,_static??!0,!0)}}class Shader{constructor(program,uniforms){this.uniformBindCount=0,this.program=program,this.uniformGroup=uniforms?uniforms instanceof UniformGroup?uniforms:new UniformGroup(uniforms):new UniformGroup({}),this.disposeRunner=new Runner_Runner("disposeShader")}checkUniformExists(name,group){if(group.uniforms[name])return!0;for(const i in group.uniforms){const uniform=group.uniforms[i];if(!0===uniform.group&&this.checkUniformExists(name,uniform))return!0}return!1}destroy(){this.uniformGroup=null,this.disposeRunner.emit(this),this.disposeRunner.destroy()}get uniforms(){return this.uniformGroup.uniforms}static from(vertexSrc,fragmentSrc,uniforms){const program=Program.from(vertexSrc,fragmentSrc);return new Shader(program,uniforms)}}class BatchShaderGenerator{constructor(vertexSrc,fragTemplate){if(this.vertexSrc=vertexSrc,this.fragTemplate=fragTemplate,this.programCache={},this.defaultGroupCache={},!fragTemplate.includes("%count%"))throw new Error('Fragment template must contain "%count%".');if(!fragTemplate.includes("%forloop%"))throw new Error('Fragment template must contain "%forloop%".')}generateShader(maxTextures){if(!this.programCache[maxTextures]){const sampleValues=new Int32Array(maxTextures);for(let i=0;i<maxTextures;i++)sampleValues[i]=i;this.defaultGroupCache[maxTextures]=UniformGroup.from({uSamplers:sampleValues},!0);let fragmentSrc=this.fragTemplate;fragmentSrc=fragmentSrc.replace(/%count%/gi,`${maxTextures}`),fragmentSrc=fragmentSrc.replace(/%forloop%/gi,this.generateSampleSrc(maxTextures)),this.programCache[maxTextures]=new Program(this.vertexSrc,fragmentSrc)}const uniforms={tint:new Float32Array([1,1,1,1]),translationMatrix:new Matrix,default:this.defaultGroupCache[maxTextures]};return new Shader(this.programCache[maxTextures],uniforms)}generateSampleSrc(maxTextures){let src="";src+="\n",src+="\n";for(let i=0;i<maxTextures;i++)i>0&&(src+="\nelse "),i<maxTextures-1&&(src+=`if(vTextureId < ${i}.5)`),src+="\n{",src+=`\n\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`,src+="\n}";return src+="\n",src+="\n",src}}class BatchTextureArray{constructor(){this.elements=[],this.ids=[],this.count=0}clear(){for(let i=0;i<this.count;i++)this.elements[i]=null;this.count=0}}class ObjectRenderer{constructor(renderer){this.renderer=renderer}flush(){}destroy(){this.renderer=null}start(){}stop(){this.flush()}render(_object){}}const _BatchRenderer=class _BatchRenderer2 extends ObjectRenderer{constructor(renderer){super(renderer),this.setShaderGenerator(),this.geometryClass=BatchGeometry,this.vertexSize=6,this.state=State.for2d(),this.size=4*_BatchRenderer2.defaultBatchSize,this._vertexCount=0,this._indexCount=0,this._bufferedElements=[],this._bufferedTextures=[],this._bufferSize=0,this._shader=null,this._packedGeometries=[],this._packedGeometryPoolSize=2,this._flushId=0,this._aBuffers={},this._iBuffers={},this.maxTextures=1,this.renderer.on("prerender",this.onPrerender,this),renderer.runners.contextChange.add(this),this._dcIndex=0,this._aIndex=0,this._iIndex=0,this._attributeBuffer=null,this._indexBuffer=null,this._tempBoundTextures=[]}static get defaultMaxTextures(){return this._defaultMaxTextures=this._defaultMaxTextures??function maxRecommendedTextures(max){let allowMax=!0;const navigator=settings.ADAPTER.getNavigator();if(isMobile_isMobile.tablet||isMobile_isMobile.phone){if(isMobile_isMobile.apple.device){const match=navigator.userAgent.match(/OS (\d+)_(\d+)?/);match&&parseInt(match[1],10)<11&&(allowMax=!1)}if(isMobile_isMobile.android.device){const match=navigator.userAgent.match(/Android\s([0-9.]*)/);match&&parseInt(match[1],10)<7&&(allowMax=!1)}}return allowMax?max:4}(32),this._defaultMaxTextures}static set defaultMaxTextures(value){this._defaultMaxTextures=value}static get canUploadSameBuffer(){return this._canUploadSameBuffer=this._canUploadSameBuffer??function canUploadSameBuffer(){return!isMobile_isMobile.apple.device}(),this._canUploadSameBuffer}static set canUploadSameBuffer(value){this._canUploadSameBuffer=value}get MAX_TEXTURES(){return deprecation("7.1.0","BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),this.maxTextures}static get defaultVertexSrc(){return"precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n"}static get defaultFragmentTemplate(){return"varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n"}setShaderGenerator({vertex=_BatchRenderer2.defaultVertexSrc,fragment=_BatchRenderer2.defaultFragmentTemplate}={}){this.shaderGenerator=new BatchShaderGenerator(vertex,fragment)}contextChange(){const gl=this.renderer.gl;settings.PREFER_ENV===ENV.WEBGL_LEGACY?this.maxTextures=1:(this.maxTextures=Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),_BatchRenderer2.defaultMaxTextures),this.maxTextures=function checkMaxIfStatementsInShader(maxIfs,gl){if(0===maxIfs)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const shader=gl.createShader(gl.FRAGMENT_SHADER);for(;;){const fragmentSrc=fragTemplate.replace(/%forloop%/gi,generateIfTestSrc(maxIfs));if(gl.shaderSource(shader,fragmentSrc),gl.compileShader(shader),gl.getShaderParameter(shader,gl.COMPILE_STATUS))break;maxIfs=maxIfs/2|0}return maxIfs}(this.maxTextures,gl)),this._shader=this.shaderGenerator.generateShader(this.maxTextures);for(let i=0;i<this._packedGeometryPoolSize;i++)this._packedGeometries[i]=new this.geometryClass;this.initFlushBuffers()}initFlushBuffers(){const{_drawCallPool,_textureArrayPool}=_BatchRenderer2,MAX_SPRITES=this.size/4,MAX_TA=Math.floor(MAX_SPRITES/this.maxTextures)+1;for(;_drawCallPool.length<MAX_SPRITES;)_drawCallPool.push(new BatchDrawCall);for(;_textureArrayPool.length<MAX_TA;)_textureArrayPool.push(new BatchTextureArray);for(let i=0;i<this.maxTextures;i++)this._tempBoundTextures[i]=null}onPrerender(){this._flushId=0}render(element){element._texture.valid&&(this._vertexCount+element.vertexData.length/2>this.size&&this.flush(),this._vertexCount+=element.vertexData.length/2,this._indexCount+=element.indices.length,this._bufferedTextures[this._bufferSize]=element._texture.baseTexture,this._bufferedElements[this._bufferSize++]=element)}buildTexturesAndDrawCalls(){const{_bufferedTextures:textures,maxTextures}=this,textureArrays=_BatchRenderer2._textureArrayPool,batch=this.renderer.batch,boundTextures=this._tempBoundTextures,touch=this.renderer.textureGC.count;let TICK=++BaseTexture._globalBatch,countTexArrays=0,texArray=textureArrays[0],start=0;batch.copyBoundTextures(boundTextures,maxTextures);for(let i=0;i<this._bufferSize;++i){const tex=textures[i];textures[i]=null,tex._batchEnabled!==TICK&&(texArray.count>=maxTextures&&(batch.boundArray(texArray,boundTextures,TICK,maxTextures),this.buildDrawCalls(texArray,start,i),start=i,texArray=textureArrays[++countTexArrays],++TICK),tex._batchEnabled=TICK,tex.touched=touch,texArray.elements[texArray.count++]=tex)}texArray.count>0&&(batch.boundArray(texArray,boundTextures,TICK,maxTextures),this.buildDrawCalls(texArray,start,this._bufferSize),++countTexArrays,++TICK);for(let i=0;i<boundTextures.length;i++)boundTextures[i]=null;BaseTexture._globalBatch=TICK}buildDrawCalls(texArray,start,finish){const{_bufferedElements:elements,_attributeBuffer,_indexBuffer,vertexSize}=this,drawCalls=_BatchRenderer2._drawCallPool;let dcIndex=this._dcIndex,aIndex=this._aIndex,iIndex=this._iIndex,drawCall=drawCalls[dcIndex];drawCall.start=this._iIndex,drawCall.texArray=texArray;for(let i=start;i<finish;++i){const sprite=elements[i],tex=sprite._texture.baseTexture,spriteBlendMode=premultiplyBlendMode[tex.alphaMode?1:0][sprite.blendMode];elements[i]=null,start<i&&drawCall.blend!==spriteBlendMode&&(drawCall.size=iIndex-drawCall.start,start=i,drawCall=drawCalls[++dcIndex],drawCall.texArray=texArray,drawCall.start=iIndex),this.packInterleavedGeometry(sprite,_attributeBuffer,_indexBuffer,aIndex,iIndex),aIndex+=sprite.vertexData.length/2*vertexSize,iIndex+=sprite.indices.length,drawCall.blend=spriteBlendMode}start<finish&&(drawCall.size=iIndex-drawCall.start,++dcIndex),this._dcIndex=dcIndex,this._aIndex=aIndex,this._iIndex=iIndex}bindAndClearTexArray(texArray){const textureSystem=this.renderer.texture;for(let j=0;j<texArray.count;j++)textureSystem.bind(texArray.elements[j],texArray.ids[j]),texArray.elements[j]=null;texArray.count=0}updateGeometry(){const{_packedGeometries:packedGeometries,_attributeBuffer:attributeBuffer,_indexBuffer:indexBuffer}=this;_BatchRenderer2.canUploadSameBuffer?(packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData),packedGeometries[this._flushId]._indexBuffer.update(indexBuffer),this.renderer.geometry.updateBuffers()):(this._packedGeometryPoolSize<=this._flushId&&(this._packedGeometryPoolSize++,packedGeometries[this._flushId]=new this.geometryClass),packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData),packedGeometries[this._flushId]._indexBuffer.update(indexBuffer),this.renderer.geometry.bind(packedGeometries[this._flushId]),this.renderer.geometry.updateBuffers(),this._flushId++)}drawBatches(){const dcCount=this._dcIndex,{gl,state:stateSystem}=this.renderer,drawCalls=_BatchRenderer2._drawCallPool;let curTexArray=null;for(let i=0;i<dcCount;i++){const{texArray,type,size,start,blend}=drawCalls[i];curTexArray!==texArray&&(curTexArray=texArray,this.bindAndClearTexArray(texArray)),this.state.blendMode=blend,stateSystem.set(this.state),gl.drawElements(type,size,gl.UNSIGNED_SHORT,2*start)}}flush(){0!==this._vertexCount&&(this._attributeBuffer=this.getAttributeBuffer(this._vertexCount),this._indexBuffer=this.getIndexBuffer(this._indexCount),this._aIndex=0,this._iIndex=0,this._dcIndex=0,this.buildTexturesAndDrawCalls(),this.updateGeometry(),this.drawBatches(),this._bufferSize=0,this._vertexCount=0,this._indexCount=0)}start(){this.renderer.state.set(this.state),this.renderer.texture.ensureSamplerType(this.maxTextures),this.renderer.shader.bind(this._shader),_BatchRenderer2.canUploadSameBuffer&&this.renderer.geometry.bind(this._packedGeometries[this._flushId])}stop(){this.flush()}destroy(){for(let i=0;i<this._packedGeometryPoolSize;i++)this._packedGeometries[i]&&this._packedGeometries[i].destroy();this.renderer.off("prerender",this.onPrerender,this),this._aBuffers=null,this._iBuffers=null,this._packedGeometries=null,this._attributeBuffer=null,this._indexBuffer=null,this._shader&&(this._shader.destroy(),this._shader=null),super.destroy()}getAttributeBuffer(size){const roundedP2=nextPow2(Math.ceil(size/8)),roundedSizeIndex=log2(roundedP2),roundedSize=8*roundedP2;this._aBuffers.length<=roundedSizeIndex&&(this._iBuffers.length=roundedSizeIndex+1);let buffer=this._aBuffers[roundedSize];return buffer||(this._aBuffers[roundedSize]=buffer=new ViewableBuffer(roundedSize*this.vertexSize*4)),buffer}getIndexBuffer(size){const roundedP2=nextPow2(Math.ceil(size/12)),roundedSizeIndex=log2(roundedP2),roundedSize=12*roundedP2;this._iBuffers.length<=roundedSizeIndex&&(this._iBuffers.length=roundedSizeIndex+1);let buffer=this._iBuffers[roundedSizeIndex];return buffer||(this._iBuffers[roundedSizeIndex]=buffer=new Uint16Array(roundedSize)),buffer}packInterleavedGeometry(element,attributeBuffer,indexBuffer,aIndex,iIndex){const{uint32View,float32View}=attributeBuffer,packedVertices=aIndex/this.vertexSize,uvs=element.uvs,indicies=element.indices,vertexData=element.vertexData,textureId=element._texture.baseTexture._batchLocation,alpha=Math.min(element.worldAlpha,1),argb=Color.shared.setValue(element._tintRGB).toPremultiplied(alpha,element._texture.baseTexture.alphaMode>0);for(let i=0;i<vertexData.length;i+=2)float32View[aIndex++]=vertexData[i],float32View[aIndex++]=vertexData[i+1],float32View[aIndex++]=uvs[i],float32View[aIndex++]=uvs[i+1],uint32View[aIndex++]=argb,float32View[aIndex++]=textureId;for(let i=0;i<indicies.length;i++)indexBuffer[iIndex++]=packedVertices+indicies[i]}};_BatchRenderer.defaultBatchSize=4096,_BatchRenderer.extension={name:"batch",type:ExtensionType.RendererPlugin},_BatchRenderer._drawCallPool=[],_BatchRenderer._textureArrayPool=[];let BatchRenderer=_BatchRenderer;extensions.add(BatchRenderer);const _Filter=class _Filter2 extends Shader{constructor(vertexSrc,fragmentSrc,uniforms){super(Program.from(vertexSrc||_Filter2.defaultVertexSrc,fragmentSrc||_Filter2.defaultFragmentSrc),uniforms),this.padding=0,this.resolution=_Filter2.defaultResolution,this.multisample=_Filter2.defaultMultisample,this.enabled=!0,this.autoFit=!0,this.state=new State}apply(filterManager,input,output,clearMode,_currentState){filterManager.applyFilter(this,input,output,clearMode)}get blendMode(){return this.state.blendMode}set blendMode(value){this.state.blendMode=value}get resolution(){return this._resolution}set resolution(value){this._resolution=value}static get defaultVertexSrc(){return"attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"}static get defaultFragmentSrc(){return"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"}};_Filter.defaultResolution=1,_Filter.defaultMultisample=MSAA_QUALITY.NONE;let Filter=_Filter;class BackgroundSystem{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new Color(0),this.alpha=1}init(options){this.clearBeforeRender=options.clearBeforeRender;const{backgroundColor,background,backgroundAlpha}=options,color=background??backgroundColor;void 0!==color&&(this.color=color),this.alpha=backgroundAlpha}get color(){return this._backgroundColor.value}set color(value){this._backgroundColor.setValue(value)}get alpha(){return this._backgroundColor.alpha}set alpha(value){this._backgroundColor.setAlpha(value)}get backgroundColor(){return this._backgroundColor}destroy(){}}BackgroundSystem.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0},BackgroundSystem.extension={type:[ExtensionType.RendererSystem,ExtensionType.CanvasRendererSystem],name:"background"},extensions.add(BackgroundSystem);class BatchSystem{constructor(renderer){this.renderer=renderer,this.emptyRenderer=new ObjectRenderer(renderer),this.currentRenderer=this.emptyRenderer}setObjectRenderer(objectRenderer){this.currentRenderer!==objectRenderer&&(this.currentRenderer.stop(),this.currentRenderer=objectRenderer,this.currentRenderer.start())}flush(){this.setObjectRenderer(this.emptyRenderer)}reset(){this.setObjectRenderer(this.emptyRenderer)}copyBoundTextures(arr,maxTextures){const{boundTextures}=this.renderer.texture;for(let i=maxTextures-1;i>=0;--i)arr[i]=boundTextures[i]||null,arr[i]&&(arr[i]._batchLocation=i)}boundArray(texArray,boundTextures,batchId,maxTextures){const{elements,ids,count}=texArray;let j=0;for(let i=0;i<count;i++){const tex=elements[i],loc=tex._batchLocation;if(loc>=0&&loc<maxTextures&&boundTextures[loc]===tex)ids[i]=loc;else for(;j<maxTextures;){const bound=boundTextures[j];if(!bound||bound._batchEnabled!==batchId||bound._batchLocation!==j){ids[i]=j,tex._batchLocation=j,boundTextures[j]=tex;break}j++}}}destroy(){this.renderer=null}}BatchSystem.extension={type:ExtensionType.RendererSystem,name:"batch"},extensions.add(BatchSystem);let CONTEXT_UID_COUNTER=0;class ContextSystem{constructor(renderer){this.renderer=renderer,this.webGLVersion=1,this.extensions={},this.supports={uint32Indices:!1},this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}contextChange(gl){this.gl=gl,this.renderer.gl=gl,this.renderer.CONTEXT_UID=CONTEXT_UID_COUNTER++}init(options){if(options.context)this.initFromContext(options.context);else{const alpha=this.renderer.background.alpha<1,premultipliedAlpha=options.premultipliedAlpha;this.preserveDrawingBuffer=options.preserveDrawingBuffer,this.useContextAlpha=options.useContextAlpha,this.powerPreference=options.powerPreference,this.initFromOptions({alpha,premultipliedAlpha,antialias:options.antialias,stencil:!0,preserveDrawingBuffer:options.preserveDrawingBuffer,powerPreference:options.powerPreference})}}initFromContext(gl){this.gl=gl,this.validateContext(gl),this.renderer.gl=gl,this.renderer.CONTEXT_UID=CONTEXT_UID_COUNTER++,this.renderer.runners.contextChange.emit(gl);const view=this.renderer.view;void 0!==view.addEventListener&&(view.addEventListener("webglcontextlost",this.handleContextLost,!1),view.addEventListener("webglcontextrestored",this.handleContextRestored,!1))}initFromOptions(options){const gl=this.createContext(this.renderer.view,options);this.initFromContext(gl)}createContext(canvas,options){let gl;if(settings.PREFER_ENV>=ENV.WEBGL2&&(gl=canvas.getContext("webgl2",options)),gl)this.webGLVersion=2;else if(this.webGLVersion=1,gl=canvas.getContext("webgl",options)||canvas.getContext("experimental-webgl",options),!gl)throw new Error("This browser does not support WebGL. Try using the canvas renderer");return this.gl=gl,this.getExtensions(),this.gl}getExtensions(){const{gl}=this,common={loseContext:gl.getExtension("WEBGL_lose_context"),anisotropicFiltering:gl.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:gl.getExtension("OES_texture_float_linear"),s3tc:gl.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:gl.getExtension("WEBGL_compressed_texture_etc"),etc1:gl.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:gl.getExtension("WEBGL_compressed_texture_pvrtc")||gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:gl.getExtension("WEBGL_compressed_texture_atc"),astc:gl.getExtension("WEBGL_compressed_texture_astc")};1===this.webGLVersion?Object.assign(this.extensions,common,{drawBuffers:gl.getExtension("WEBGL_draw_buffers"),depthTexture:gl.getExtension("WEBGL_depth_texture"),vertexArrayObject:gl.getExtension("OES_vertex_array_object")||gl.getExtension("MOZ_OES_vertex_array_object")||gl.getExtension("WEBKIT_OES_vertex_array_object"),uint32ElementIndex:gl.getExtension("OES_element_index_uint"),floatTexture:gl.getExtension("OES_texture_float"),floatTextureLinear:gl.getExtension("OES_texture_float_linear"),textureHalfFloat:gl.getExtension("OES_texture_half_float"),textureHalfFloatLinear:gl.getExtension("OES_texture_half_float_linear")}):2===this.webGLVersion&&Object.assign(this.extensions,common,{colorBufferFloat:gl.getExtension("EXT_color_buffer_float")})}handleContextLost(event){event.preventDefault(),setTimeout((()=>{this.gl.isContextLost()&&this.extensions.loseContext&&this.extensions.loseContext.restoreContext()}),0)}handleContextRestored(){this.renderer.runners.contextChange.emit(this.gl)}destroy(){const view=this.renderer.view;this.renderer=null,void 0!==view.removeEventListener&&(view.removeEventListener("webglcontextlost",this.handleContextLost),view.removeEventListener("webglcontextrestored",this.handleContextRestored)),this.gl.useProgram(null),this.extensions.loseContext&&this.extensions.loseContext.loseContext()}postrender(){this.renderer.objectRenderer.renderingToScreen&&this.gl.flush()}validateContext(gl){const attributes=gl.getContextAttributes(),isWebGl2="WebGL2RenderingContext"in globalThis&&gl instanceof globalThis.WebGL2RenderingContext;isWebGl2&&(this.webGLVersion=2),attributes&&!attributes.stencil&&console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");const hasuint32=isWebGl2||!!gl.getExtension("OES_element_index_uint");this.supports.uint32Indices=hasuint32,hasuint32||console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")}}ContextSystem.defaultOptions={context:null,antialias:!1,premultipliedAlpha:!0,preserveDrawingBuffer:!1,powerPreference:"default"},ContextSystem.extension={type:ExtensionType.RendererSystem,name:"context"},extensions.add(ContextSystem);class Framebuffer{constructor(width,height){if(this.width=Math.round(width),this.height=Math.round(height),!this.width||!this.height)throw new Error("Framebuffer width or height is zero");this.stencil=!1,this.depth=!1,this.dirtyId=0,this.dirtyFormat=0,this.dirtySize=0,this.depthTexture=null,this.colorTextures=[],this.glFramebuffers={},this.disposeRunner=new Runner_Runner("disposeFramebuffer"),this.multisample=MSAA_QUALITY.NONE}get colorTexture(){return this.colorTextures[0]}addColorTexture(index=0,texture){return this.colorTextures[index]=texture||new BaseTexture(null,{scaleMode:SCALE_MODES.NEAREST,resolution:1,mipmap:MIPMAP_MODES.OFF,width:this.width,height:this.height}),this.dirtyId++,this.dirtyFormat++,this}addDepthTexture(texture){return this.depthTexture=texture||new BaseTexture(null,{scaleMode:SCALE_MODES.NEAREST,resolution:1,width:this.width,height:this.height,mipmap:MIPMAP_MODES.OFF,format:FORMATS.DEPTH_COMPONENT,type:TYPES.UNSIGNED_SHORT}),this.dirtyId++,this.dirtyFormat++,this}enableDepth(){return this.depth=!0,this.dirtyId++,this.dirtyFormat++,this}enableStencil(){return this.stencil=!0,this.dirtyId++,this.dirtyFormat++,this}resize(width,height){if(width=Math.round(width),height=Math.round(height),!width||!height)throw new Error("Framebuffer width and height must not be zero");if(width!==this.width||height!==this.height){this.width=width,this.height=height,this.dirtyId++,this.dirtySize++;for(let i=0;i<this.colorTextures.length;i++){const texture=this.colorTextures[i],resolution=texture.resolution;texture.setSize(width/resolution,height/resolution)}if(this.depthTexture){const resolution=this.depthTexture.resolution;this.depthTexture.setSize(width/resolution,height/resolution)}}}dispose(){this.disposeRunner.emit(this,!1)}destroyDepthTexture(){this.depthTexture&&(this.depthTexture.destroy(),this.depthTexture=null,++this.dirtyId,++this.dirtyFormat)}}class BaseRenderTexture extends BaseTexture{constructor(options={}){if("number"==typeof options){options={width:arguments[0],height:arguments[1],scaleMode:arguments[2],resolution:arguments[3]}}options.width=options.width??100,options.height=options.height??100,options.multisample??(options.multisample=MSAA_QUALITY.NONE),super(null,options),this.mipmap=MIPMAP_MODES.OFF,this.valid=!0,this._clear=new Color([0,0,0,0]),this.framebuffer=new Framebuffer(this.realWidth,this.realHeight).addColorTexture(0,this),this.framebuffer.multisample=options.multisample,this.maskStack=[],this.filterStack=[{}]}set clearColor(value){this._clear.setValue(value)}get clearColor(){return this._clear.value}get clear(){return this._clear}get multisample(){return this.framebuffer.multisample}set multisample(value){this.framebuffer.multisample=value}resize(desiredWidth,desiredHeight){this.framebuffer.resize(desiredWidth*this.resolution,desiredHeight*this.resolution),this.setRealSize(this.framebuffer.width,this.framebuffer.height)}dispose(){this.framebuffer.dispose(),super.dispose()}destroy(){super.destroy(),this.framebuffer.destroyDepthTexture(),this.framebuffer=null}}class BaseImageResource extends Resource{constructor(source){const sourceAny=source;super(sourceAny.naturalWidth||sourceAny.videoWidth||sourceAny.width,sourceAny.naturalHeight||sourceAny.videoHeight||sourceAny.height),this.source=source,this.noSubImage=!1}static crossOrigin(element,url,crossorigin){void 0!==crossorigin||url.startsWith("data:")?!1!==crossorigin&&(element.crossOrigin="string"==typeof crossorigin?crossorigin:"anonymous"):element.crossOrigin=determineCrossOrigin(url)}upload(renderer,baseTexture,glTexture,source){const gl=renderer.gl,width=baseTexture.realWidth,height=baseTexture.realHeight;if(source=source||this.source,typeof HTMLImageElement<"u"&&source instanceof HTMLImageElement){if(!source.complete||0===source.naturalWidth)return!1}else if(typeof HTMLVideoElement<"u"&&source instanceof HTMLVideoElement&&source.readyState<=1)return!1;return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,baseTexture.alphaMode===ALPHA_MODES.UNPACK),this.noSubImage||baseTexture.target!==gl.TEXTURE_2D||glTexture.width!==width||glTexture.height!==height?(glTexture.width=width,glTexture.height=height,gl.texImage2D(baseTexture.target,0,glTexture.internalFormat,baseTexture.format,glTexture.type,source)):gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,baseTexture.format,glTexture.type,source),!0}update(){if(this.destroyed)return;const source=this.source,width=source.naturalWidth||source.videoWidth||source.width,height=source.naturalHeight||source.videoHeight||source.height;this.resize(width,height),super.update()}dispose(){this.source=null}}class ImageResource extends BaseImageResource{constructor(source,options){if(options=options||{},"string"==typeof source){const imageElement=new Image;BaseImageResource.crossOrigin(imageElement,source,options.crossorigin),imageElement.src=source,source=imageElement}super(source),!source.complete&&this._width&&this._height&&(this._width=0,this._height=0),this.url=source.src,this._process=null,this.preserveBitmap=!1,this.createBitmap=(options.createBitmap??settings.CREATE_IMAGE_BITMAP)&&!!globalThis.createImageBitmap,this.alphaMode="number"==typeof options.alphaMode?options.alphaMode:null,this.bitmap=null,this._load=null,!1!==options.autoLoad&&this.load()}load(createBitmap){return this._load||(void 0!==createBitmap&&(this.createBitmap=createBitmap),this._load=new Promise(((resolve,reject)=>{const source=this.source;this.url=source.src;const completed=()=>{this.destroyed||(source.onload=null,source.onerror=null,this.update(),this._load=null,this.createBitmap?resolve(this.process()):resolve(this))};source.complete&&source.src?completed():(source.onload=completed,source.onerror=event=>{reject(event),this.onError.emit(event)})}))),this._load}process(){const source=this.source;if(null!==this._process)return this._process;if(null!==this.bitmap||!globalThis.createImageBitmap)return Promise.resolve(this);const createImageBitmap=globalThis.createImageBitmap,cors=!source.crossOrigin||"anonymous"===source.crossOrigin;return this._process=fetch(source.src,{mode:cors?"cors":"no-cors"}).then((r=>r.blob())).then((blob=>createImageBitmap(blob,0,0,source.width,source.height,{premultiplyAlpha:null===this.alphaMode||this.alphaMode===ALPHA_MODES.UNPACK?"premultiply":"none"}))).then((bitmap=>this.destroyed?Promise.reject():(this.bitmap=bitmap,this.update(),this._process=null,Promise.resolve(this)))),this._process}upload(renderer,baseTexture,glTexture){if("number"==typeof this.alphaMode&&(baseTexture.alphaMode=this.alphaMode),!this.createBitmap)return super.upload(renderer,baseTexture,glTexture);if(!this.bitmap&&(this.process(),!this.bitmap))return!1;if(super.upload(renderer,baseTexture,glTexture,this.bitmap),!this.preserveBitmap){let flag=!0;const glTextures=baseTexture._glTextures;for(const key in glTextures){const otherTex=glTextures[key];if(otherTex!==glTexture&&otherTex.dirtyId!==baseTexture.dirtyId){flag=!1;break}}flag&&(this.bitmap.close&&this.bitmap.close(),this.bitmap=null)}return!0}dispose(){this.source.onload=null,this.source.onerror=null,super.dispose(),this.bitmap&&(this.bitmap.close(),this.bitmap=null),this._process=null,this._load=null}static test(source){return typeof HTMLImageElement<"u"&&("string"==typeof source||source instanceof HTMLImageElement)}}class TextureUvs{constructor(){this.x0=0,this.y0=0,this.x1=1,this.y1=0,this.x2=1,this.y2=1,this.x3=0,this.y3=1,this.uvsFloat32=new Float32Array(8)}set(frame,baseFrame,rotate){const tw=baseFrame.width,th=baseFrame.height;if(rotate){const w2=frame.width/2/tw,h2=frame.height/2/th,cX=frame.x/tw+w2,cY=frame.y/th+h2;rotate=groupD8.add(rotate,groupD8.NW),this.x0=cX+w2*groupD8.uX(rotate),this.y0=cY+h2*groupD8.uY(rotate),rotate=groupD8.add(rotate,2),this.x1=cX+w2*groupD8.uX(rotate),this.y1=cY+h2*groupD8.uY(rotate),rotate=groupD8.add(rotate,2),this.x2=cX+w2*groupD8.uX(rotate),this.y2=cY+h2*groupD8.uY(rotate),rotate=groupD8.add(rotate,2),this.x3=cX+w2*groupD8.uX(rotate),this.y3=cY+h2*groupD8.uY(rotate)}else this.x0=frame.x/tw,this.y0=frame.y/th,this.x1=(frame.x+frame.width)/tw,this.y1=frame.y/th,this.x2=(frame.x+frame.width)/tw,this.y2=(frame.y+frame.height)/th,this.x3=frame.x/tw,this.y3=(frame.y+frame.height)/th;this.uvsFloat32[0]=this.x0,this.uvsFloat32[1]=this.y0,this.uvsFloat32[2]=this.x1,this.uvsFloat32[3]=this.y1,this.uvsFloat32[4]=this.x2,this.uvsFloat32[5]=this.y2,this.uvsFloat32[6]=this.x3,this.uvsFloat32[7]=this.y3}}TextureUvs.prototype.toString=function(){return`[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`};const DEFAULT_UVS=new TextureUvs;function removeAllHandlers(tex){tex.destroy=function(){},tex.on=function(){},tex.once=function(){},tex.emit=function(){}}class Texture extends(eventemitter3_default()){constructor(baseTexture,frame,orig,trim,rotate,anchor,borders){if(super(),this.noFrame=!1,frame||(this.noFrame=!0,frame=new Rectangle(0,0,1,1)),baseTexture instanceof Texture&&(baseTexture=baseTexture.baseTexture),this.baseTexture=baseTexture,this._frame=frame,this.trim=trim,this.valid=!1,this.destroyed=!1,this._uvs=DEFAULT_UVS,this.uvMatrix=null,this.orig=orig||frame,this._rotate=Number(rotate||0),!0===rotate)this._rotate=2;else if(this._rotate%2!=0)throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");this.defaultAnchor=anchor?new Point(anchor.x,anchor.y):new Point(0,0),this.defaultBorders=borders,this._updateID=0,this.textureCacheIds=[],baseTexture.valid?this.noFrame?baseTexture.valid&&this.onBaseTextureUpdated(baseTexture):this.frame=frame:baseTexture.once("loaded",this.onBaseTextureUpdated,this),this.noFrame&&baseTexture.on("update",this.onBaseTextureUpdated,this)}update(){this.baseTexture.resource&&this.baseTexture.resource.update()}onBaseTextureUpdated(baseTexture){if(this.noFrame){if(!this.baseTexture.valid)return;this._frame.width=baseTexture.width,this._frame.height=baseTexture.height,this.valid=!0,this.updateUvs()}else this.frame=this._frame;this.emit("update",this)}destroy(destroyBase){if(this.baseTexture){if(destroyBase){const{resource}=this.baseTexture;resource?.url&&TextureCache[resource.url]&&Texture.removeFromCache(resource.url),this.baseTexture.destroy()}this.baseTexture.off("loaded",this.onBaseTextureUpdated,this),this.baseTexture.off("update",this.onBaseTextureUpdated,this),this.baseTexture=null}this._frame=null,this._uvs=null,this.trim=null,this.orig=null,this.valid=!1,Texture.removeFromCache(this),this.textureCacheIds=null,this.destroyed=!0,this.emit("destroyed",this),this.removeAllListeners()}clone(){const clonedFrame=this._frame.clone(),clonedOrig=this._frame===this.orig?clonedFrame:this.orig.clone(),clonedTexture=new Texture(this.baseTexture,!this.noFrame&&clonedFrame,clonedOrig,this.trim?.clone(),this.rotate,this.defaultAnchor,this.defaultBorders);return this.noFrame&&(clonedTexture._frame=clonedFrame),clonedTexture}updateUvs(){this._uvs===DEFAULT_UVS&&(this._uvs=new TextureUvs),this._uvs.set(this._frame,this.baseTexture,this.rotate),this._updateID++}static from(source,options={},strict=settings.STRICT_TEXTURE_CACHE){const isFrame="string"==typeof source;let cacheId=null;if(isFrame)cacheId=source;else if(source instanceof BaseTexture){if(!source.cacheId){const prefix=options?.pixiIdPrefix||"pixiid";source.cacheId=`${prefix}-${uid()}`,BaseTexture.addToCache(source,source.cacheId)}cacheId=source.cacheId}else{if(!source._pixiId){const prefix=options?.pixiIdPrefix||"pixiid";source._pixiId=`${prefix}_${uid()}`}cacheId=source._pixiId}let texture=TextureCache[cacheId];if(isFrame&&strict&&!texture)throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);return texture||source instanceof BaseTexture?!texture&&source instanceof BaseTexture&&(texture=new Texture(source),Texture.addToCache(texture,cacheId)):(options.resolution||(options.resolution=getResolutionOfUrl(source)),texture=new Texture(new BaseTexture(source,options)),texture.baseTexture.cacheId=cacheId,BaseTexture.addToCache(texture.baseTexture,cacheId),Texture.addToCache(texture,cacheId)),texture}static fromURL(url,options){const resourceOptions=Object.assign({autoLoad:!1},options?.resourceOptions),texture=Texture.from(url,Object.assign({resourceOptions},options),!1),resource=texture.baseTexture.resource;return texture.baseTexture.valid?Promise.resolve(texture):resource.load().then((()=>Promise.resolve(texture)))}static fromBuffer(buffer,width,height,options){return new Texture(BaseTexture.fromBuffer(buffer,width,height,options))}static fromLoader(source,imageUrl,name,options){const baseTexture=new BaseTexture(source,Object.assign({scaleMode:BaseTexture.defaultOptions.scaleMode,resolution:getResolutionOfUrl(imageUrl)},options)),{resource}=baseTexture;resource instanceof ImageResource&&(resource.url=imageUrl);const texture=new Texture(baseTexture);return name||(name=imageUrl),BaseTexture.addToCache(texture.baseTexture,name),Texture.addToCache(texture,name),name!==imageUrl&&(BaseTexture.addToCache(texture.baseTexture,imageUrl),Texture.addToCache(texture,imageUrl)),texture.baseTexture.valid?Promise.resolve(texture):new Promise((resolve=>{texture.baseTexture.once("loaded",(()=>resolve(texture)))}))}static addToCache(texture,id){id&&(texture.textureCacheIds.includes(id)||texture.textureCacheIds.push(id),TextureCache[id]&&TextureCache[id]!==texture&&console.warn(`Texture added to the cache with an id [${id}] that already had an entry`),TextureCache[id]=texture)}static removeFromCache(texture){if("string"==typeof texture){const textureFromCache=TextureCache[texture];if(textureFromCache){const index=textureFromCache.textureCacheIds.indexOf(texture);return index>-1&&textureFromCache.textureCacheIds.splice(index,1),delete TextureCache[texture],textureFromCache}}else if(texture?.textureCacheIds){for(let i=0;i<texture.textureCacheIds.length;++i)TextureCache[texture.textureCacheIds[i]]===texture&&delete TextureCache[texture.textureCacheIds[i]];return texture.textureCacheIds.length=0,texture}return null}get resolution(){return this.baseTexture.resolution}get frame(){return this._frame}set frame(frame){this._frame=frame,this.noFrame=!1;const{x,y,width,height}=frame,xNotFit=x+width>this.baseTexture.width,yNotFit=y+height>this.baseTexture.height;if(xNotFit||yNotFit){const relationship=xNotFit&&yNotFit?"and":"or",errorX=`X: ${x} + ${width} = ${x+width} > ${this.baseTexture.width}`,errorY=`Y: ${y} + ${height} = ${y+height} > ${this.baseTexture.height}`;throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`)}this.valid=width&&height&&this.baseTexture.valid,!this.trim&&!this.rotate&&(this.orig=frame),this.valid&&this.updateUvs()}get rotate(){return this._rotate}set rotate(rotate){this._rotate=rotate,this.valid&&this.updateUvs()}get width(){return this.orig.width}get height(){return this.orig.height}castToBaseTexture(){return this.baseTexture}static get EMPTY(){return Texture._EMPTY||(Texture._EMPTY=new Texture(new BaseTexture),removeAllHandlers(Texture._EMPTY),removeAllHandlers(Texture._EMPTY.baseTexture)),Texture._EMPTY}static get WHITE(){if(!Texture._WHITE){const canvas=settings.ADAPTER.createCanvas(16,16),context=canvas.getContext("2d");canvas.width=16,canvas.height=16,context.fillStyle="white",context.fillRect(0,0,16,16),Texture._WHITE=new Texture(BaseTexture.from(canvas)),removeAllHandlers(Texture._WHITE),removeAllHandlers(Texture._WHITE.baseTexture)}return Texture._WHITE}}class RenderTexture extends Texture{constructor(baseRenderTexture,frame){super(baseRenderTexture,frame),this.valid=!0,this.filterFrame=null,this.filterPoolKey=null,this.updateUvs()}get framebuffer(){return this.baseTexture.framebuffer}get multisample(){return this.framebuffer.multisample}set multisample(value){this.framebuffer.multisample=value}resize(desiredWidth,desiredHeight,resizeBaseTexture=!0){const resolution=this.baseTexture.resolution,width=Math.round(desiredWidth*resolution)/resolution,height=Math.round(desiredHeight*resolution)/resolution;this.valid=width>0&&height>0,this._frame.width=this.orig.width=width,this._frame.height=this.orig.height=height,resizeBaseTexture&&this.baseTexture.resize(width,height),this.updateUvs()}setResolution(resolution){const{baseTexture}=this;baseTexture.resolution!==resolution&&(baseTexture.setResolution(resolution),this.resize(baseTexture.width,baseTexture.height,!1))}static create(options){return new RenderTexture(new BaseRenderTexture(options))}}class RenderTexturePool{constructor(textureOptions){this.texturePool={},this.textureOptions=textureOptions||{},this.enableFullScreen=!1,this._pixelsWidth=0,this._pixelsHeight=0}createTexture(realWidth,realHeight,multisample=MSAA_QUALITY.NONE){const baseRenderTexture=new BaseRenderTexture(Object.assign({width:realWidth,height:realHeight,resolution:1,multisample},this.textureOptions));return new RenderTexture(baseRenderTexture)}getOptimalTexture(minWidth,minHeight,resolution=1,multisample=MSAA_QUALITY.NONE){let key;minWidth=Math.max(Math.ceil(minWidth*resolution-1e-6),1),minHeight=Math.max(Math.ceil(minHeight*resolution-1e-6),1),this.enableFullScreen&&minWidth===this._pixelsWidth&&minHeight===this._pixelsHeight?key=multisample>1?-multisample:-1:(key=((65535&(minWidth=nextPow2(minWidth)))<<16|65535&(minHeight=nextPow2(minHeight)))>>>0,multisample>1&&(key+=4294967296*multisample)),this.texturePool[key]||(this.texturePool[key]=[]);let renderTexture=this.texturePool[key].pop();return renderTexture||(renderTexture=this.createTexture(minWidth,minHeight,multisample)),renderTexture.filterPoolKey=key,renderTexture.setResolution(resolution),renderTexture}getFilterTexture(input,resolution,multisample){const filterTexture=this.getOptimalTexture(input.width,input.height,resolution||input.resolution,multisample||MSAA_QUALITY.NONE);return filterTexture.filterFrame=input.filterFrame,filterTexture}returnTexture(renderTexture){const key=renderTexture.filterPoolKey;renderTexture.filterFrame=null,this.texturePool[key].push(renderTexture)}returnFilterTexture(renderTexture){this.returnTexture(renderTexture)}clear(destroyTextures){if(destroyTextures=!1!==destroyTextures)for(const i in this.texturePool){const textures=this.texturePool[i];if(textures)for(let j=0;j<textures.length;j++)textures[j].destroy(!0)}this.texturePool={}}setScreenSize(size){if(size.width!==this._pixelsWidth||size.height!==this._pixelsHeight){this.enableFullScreen=size.width>0&&size.height>0;for(const i in this.texturePool){if(!(Number(i)<0))continue;const textures=this.texturePool[i];if(textures)for(let j=0;j<textures.length;j++)textures[j].destroy(!0);this.texturePool[i]=[]}this._pixelsWidth=size.width,this._pixelsHeight=size.height}}}RenderTexturePool.SCREEN_KEY=-1;class Quad extends Geometry{constructor(){super(),this.addAttribute("aVertexPosition",new Float32Array([0,0,1,0,1,1,0,1])).addIndex([0,1,3,2])}}class QuadUv extends Geometry{constructor(){super(),this.vertices=new Float32Array([-1,-1,1,-1,1,1,-1,1]),this.uvs=new Float32Array([0,0,1,0,1,1,0,1]),this.vertexBuffer=new Buffer(this.vertices),this.uvBuffer=new Buffer(this.uvs),this.addAttribute("aVertexPosition",this.vertexBuffer).addAttribute("aTextureCoord",this.uvBuffer).addIndex([0,1,2,0,2,3])}map(targetTextureFrame,destinationFrame){let x=0,y=0;return this.uvs[0]=x,this.uvs[1]=y,this.uvs[2]=x+destinationFrame.width/targetTextureFrame.width,this.uvs[3]=y,this.uvs[4]=x+destinationFrame.width/targetTextureFrame.width,this.uvs[5]=y+destinationFrame.height/targetTextureFrame.height,this.uvs[6]=x,this.uvs[7]=y+destinationFrame.height/targetTextureFrame.height,x=destinationFrame.x,y=destinationFrame.y,this.vertices[0]=x,this.vertices[1]=y,this.vertices[2]=x+destinationFrame.width,this.vertices[3]=y,this.vertices[4]=x+destinationFrame.width,this.vertices[5]=y+destinationFrame.height,this.vertices[6]=x,this.vertices[7]=y+destinationFrame.height,this.invalidate(),this}invalidate(){return this.vertexBuffer._updateID++,this.uvBuffer._updateID++,this}}class FilterState{constructor(){this.renderTexture=null,this.target=null,this.legacy=!1,this.resolution=1,this.multisample=MSAA_QUALITY.NONE,this.sourceFrame=new Rectangle,this.destinationFrame=new Rectangle,this.bindingSourceFrame=new Rectangle,this.bindingDestinationFrame=new Rectangle,this.filters=[],this.transform=null}clear(){this.target=null,this.filters=null,this.renderTexture=null}}const FilterSystem_tempPoints=[new Point,new Point,new Point,new Point],tempMatrix=new Matrix;class FilterSystem{constructor(renderer){this.renderer=renderer,this.defaultFilterStack=[{}],this.texturePool=new RenderTexturePool,this.statePool=[],this.quad=new Quad,this.quadUv=new QuadUv,this.tempRect=new Rectangle,this.activeState={},this.globalUniforms=new UniformGroup({outputFrame:new Rectangle,inputSize:new Float32Array(4),inputPixel:new Float32Array(4),inputClamp:new Float32Array(4),resolution:1,filterArea:new Float32Array(4),filterClamp:new Float32Array(4)},!0),this.forceClear=!1,this.useMaxPadding=!1}init(){this.texturePool.setScreenSize(this.renderer.view)}push(target,filters){const renderer=this.renderer,filterStack=this.defaultFilterStack,state=this.statePool.pop()||new FilterState,renderTextureSystem=renderer.renderTexture;let currentResolution,currentMultisample;if(renderTextureSystem.current){const renderTexture=renderTextureSystem.current;currentResolution=renderTexture.resolution,currentMultisample=renderTexture.multisample}else currentResolution=renderer.resolution,currentMultisample=renderer.multisample;let resolution=filters[0].resolution||currentResolution,multisample=filters[0].multisample??currentMultisample,padding=filters[0].padding,autoFit=filters[0].autoFit,legacy=filters[0].legacy??!0;for(let i=1;i<filters.length;i++){const filter=filters[i];resolution=Math.min(resolution,filter.resolution||currentResolution),multisample=Math.min(multisample,filter.multisample??currentMultisample),padding=this.useMaxPadding?Math.max(padding,filter.padding):padding+filter.padding,autoFit=autoFit&&filter.autoFit,legacy=legacy||(filter.legacy??!0)}1===filterStack.length&&(this.defaultFilterStack[0].renderTexture=renderTextureSystem.current),filterStack.push(state),state.resolution=resolution,state.multisample=multisample,state.legacy=legacy,state.target=target,state.sourceFrame.copyFrom(target.filterArea||target.getBounds(!0)),state.sourceFrame.pad(padding);const sourceFrameProjected=this.tempRect.copyFrom(renderTextureSystem.sourceFrame);renderer.projection.transform&&this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(),sourceFrameProjected),autoFit?(state.sourceFrame.fit(sourceFrameProjected),(state.sourceFrame.width<=0||state.sourceFrame.height<=0)&&(state.sourceFrame.width=0,state.sourceFrame.height=0)):state.sourceFrame.intersects(sourceFrameProjected)||(state.sourceFrame.width=0,state.sourceFrame.height=0),this.roundFrame(state.sourceFrame,renderTextureSystem.current?renderTextureSystem.current.resolution:renderer.resolution,renderTextureSystem.sourceFrame,renderTextureSystem.destinationFrame,renderer.projection.transform),state.renderTexture=this.getOptimalFilterTexture(state.sourceFrame.width,state.sourceFrame.height,resolution,multisample),state.filters=filters,state.destinationFrame.width=state.renderTexture.width,state.destinationFrame.height=state.renderTexture.height;const destinationFrame=this.tempRect;destinationFrame.x=0,destinationFrame.y=0,destinationFrame.width=state.sourceFrame.width,destinationFrame.height=state.sourceFrame.height,state.renderTexture.filterFrame=state.sourceFrame,state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame),state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame),state.transform=renderer.projection.transform,renderer.projection.transform=null,renderTextureSystem.bind(state.renderTexture,state.sourceFrame,destinationFrame),renderer.framebuffer.clear(0,0,0,0)}pop(){const filterStack=this.defaultFilterStack,state=filterStack.pop(),filters=state.filters;this.activeState=state;const globalUniforms=this.globalUniforms.uniforms;globalUniforms.outputFrame=state.sourceFrame,globalUniforms.resolution=state.resolution;const inputSize=globalUniforms.inputSize,inputPixel=globalUniforms.inputPixel,inputClamp=globalUniforms.inputClamp;if(inputSize[0]=state.destinationFrame.width,inputSize[1]=state.destinationFrame.height,inputSize[2]=1/inputSize[0],inputSize[3]=1/inputSize[1],inputPixel[0]=Math.round(inputSize[0]*state.resolution),inputPixel[1]=Math.round(inputSize[1]*state.resolution),inputPixel[2]=1/inputPixel[0],inputPixel[3]=1/inputPixel[1],inputClamp[0]=.5*inputPixel[2],inputClamp[1]=.5*inputPixel[3],inputClamp[2]=state.sourceFrame.width*inputSize[2]-.5*inputPixel[2],inputClamp[3]=state.sourceFrame.height*inputSize[3]-.5*inputPixel[3],state.legacy){const filterArea=globalUniforms.filterArea;filterArea[0]=state.destinationFrame.width,filterArea[1]=state.destinationFrame.height,filterArea[2]=state.sourceFrame.x,filterArea[3]=state.sourceFrame.y,globalUniforms.filterClamp=globalUniforms.inputClamp}this.globalUniforms.update();const lastState=filterStack[filterStack.length-1];if(this.renderer.framebuffer.blit(),1===filters.length)filters[0].apply(this,state.renderTexture,lastState.renderTexture,CLEAR_MODES.BLEND,state),this.returnFilterTexture(state.renderTexture);else{let flip=state.renderTexture,flop=this.getOptimalFilterTexture(flip.width,flip.height,state.resolution);flop.filterFrame=flip.filterFrame;let i=0;for(i=0;i<filters.length-1;++i){1===i&&state.multisample>1&&(flop=this.getOptimalFilterTexture(flip.width,flip.height,state.resolution),flop.filterFrame=flip.filterFrame),filters[i].apply(this,flip,flop,CLEAR_MODES.CLEAR,state);const t=flip;flip=flop,flop=t}filters[i].apply(this,flip,lastState.renderTexture,CLEAR_MODES.BLEND,state),i>1&&state.multisample>1&&this.returnFilterTexture(state.renderTexture),this.returnFilterTexture(flip),this.returnFilterTexture(flop)}state.clear(),this.statePool.push(state)}bindAndClear(filterTexture,clearMode=CLEAR_MODES.CLEAR){const{renderTexture:renderTextureSystem,state:stateSystem}=this.renderer;if(filterTexture===this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?this.renderer.projection.transform=this.activeState.transform:this.renderer.projection.transform=null,filterTexture?.filterFrame){const destinationFrame=this.tempRect;destinationFrame.x=0,destinationFrame.y=0,destinationFrame.width=filterTexture.filterFrame.width,destinationFrame.height=filterTexture.filterFrame.height,renderTextureSystem.bind(filterTexture,filterTexture.filterFrame,destinationFrame)}else filterTexture!==this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?renderTextureSystem.bind(filterTexture):this.renderer.renderTexture.bind(filterTexture,this.activeState.bindingSourceFrame,this.activeState.bindingDestinationFrame);const autoClear=1&stateSystem.stateId||this.forceClear;(clearMode===CLEAR_MODES.CLEAR||clearMode===CLEAR_MODES.BLIT&&autoClear)&&this.renderer.framebuffer.clear(0,0,0,0)}applyFilter(filter,input,output,clearMode){const renderer=this.renderer;renderer.state.set(filter.state),this.bindAndClear(output,clearMode),filter.uniforms.uSampler=input,filter.uniforms.filterGlobals=this.globalUniforms,renderer.shader.bind(filter),filter.legacy=!!filter.program.attributeData.aTextureCoord,filter.legacy?(this.quadUv.map(input._frame,input.filterFrame),renderer.geometry.bind(this.quadUv),renderer.geometry.draw(DRAW_MODES.TRIANGLES)):(renderer.geometry.bind(this.quad),renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP))}calculateSpriteMatrix(outputMatrix,sprite){const{sourceFrame,destinationFrame}=this.activeState,{orig}=sprite._texture,mappedMatrix=outputMatrix.set(destinationFrame.width,0,0,destinationFrame.height,sourceFrame.x,sourceFrame.y),worldTransform=sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);return worldTransform.invert(),mappedMatrix.prepend(worldTransform),mappedMatrix.scale(1/orig.width,1/orig.height),mappedMatrix.translate(sprite.anchor.x,sprite.anchor.y),mappedMatrix}destroy(){this.renderer=null,this.texturePool.clear(!1)}getOptimalFilterTexture(minWidth,minHeight,resolution=1,multisample=MSAA_QUALITY.NONE){return this.texturePool.getOptimalTexture(minWidth,minHeight,resolution,multisample)}getFilterTexture(input,resolution,multisample){if("number"==typeof input){const swap=input;input=resolution,resolution=swap}input=input||this.activeState.renderTexture;const filterTexture=this.texturePool.getOptimalTexture(input.width,input.height,resolution||input.resolution,multisample||MSAA_QUALITY.NONE);return filterTexture.filterFrame=input.filterFrame,filterTexture}returnFilterTexture(renderTexture){this.texturePool.returnTexture(renderTexture)}emptyPool(){this.texturePool.clear(!0)}resize(){this.texturePool.setScreenSize(this.renderer.view)}transformAABB(matrix,rect){const lt=FilterSystem_tempPoints[0],lb=FilterSystem_tempPoints[1],rt=FilterSystem_tempPoints[2],rb=FilterSystem_tempPoints[3];lt.set(rect.left,rect.top),lb.set(rect.left,rect.bottom),rt.set(rect.right,rect.top),rb.set(rect.right,rect.bottom),matrix.apply(lt,lt),matrix.apply(lb,lb),matrix.apply(rt,rt),matrix.apply(rb,rb);const x0=Math.min(lt.x,lb.x,rt.x,rb.x),y0=Math.min(lt.y,lb.y,rt.y,rb.y),x1=Math.max(lt.x,lb.x,rt.x,rb.x),y1=Math.max(lt.y,lb.y,rt.y,rb.y);rect.x=x0,rect.y=y0,rect.width=x1-x0,rect.height=y1-y0}roundFrame(frame,resolution,bindingSourceFrame,bindingDestinationFrame,transform){if(!(frame.width<=0||frame.height<=0||bindingSourceFrame.width<=0||bindingSourceFrame.height<=0)){if(transform){const{a,b,c,d}=transform;if((Math.abs(b)>1e-4||Math.abs(c)>1e-4)&&(Math.abs(a)>1e-4||Math.abs(d)>1e-4))return}(transform=transform?tempMatrix.copyFrom(transform):tempMatrix.identity()).translate(-bindingSourceFrame.x,-bindingSourceFrame.y).scale(bindingDestinationFrame.width/bindingSourceFrame.width,bindingDestinationFrame.height/bindingSourceFrame.height).translate(bindingDestinationFrame.x,bindingDestinationFrame.y),this.transformAABB(transform,frame),frame.ceil(resolution),this.transformAABB(transform.invert(),frame)}}}FilterSystem.extension={type:ExtensionType.RendererSystem,name:"filter"},extensions.add(FilterSystem);class GLFramebuffer{constructor(framebuffer){this.framebuffer=framebuffer,this.stencil=null,this.dirtyId=-1,this.dirtyFormat=-1,this.dirtySize=-1,this.multisample=MSAA_QUALITY.NONE,this.msaaBuffer=null,this.blitFramebuffer=null,this.mipLevel=0}}const tempRectangle=new Rectangle;class FramebufferSystem{constructor(renderer){this.renderer=renderer,this.managedFramebuffers=[],this.unknownFramebuffer=new Framebuffer(10,10),this.msaaSamples=null}contextChange(){this.disposeAll(!0);const gl=this.gl=this.renderer.gl;if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.current=this.unknownFramebuffer,this.viewport=new Rectangle,this.hasMRT=!0,this.writeDepthTexture=!0,1===this.renderer.context.webGLVersion){let nativeDrawBuffersExtension=this.renderer.context.extensions.drawBuffers,nativeDepthTextureExtension=this.renderer.context.extensions.depthTexture;settings.PREFER_ENV===ENV.WEBGL_LEGACY&&(nativeDrawBuffersExtension=null,nativeDepthTextureExtension=null),nativeDrawBuffersExtension?gl.drawBuffers=activeTextures=>nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures):(this.hasMRT=!1,gl.drawBuffers=()=>{}),nativeDepthTextureExtension||(this.writeDepthTexture=!1)}else this.msaaSamples=gl.getInternalformatParameter(gl.RENDERBUFFER,gl.RGBA8,gl.SAMPLES)}bind(framebuffer,frame,mipLevel=0){const{gl}=this;if(framebuffer){const fbo=framebuffer.glFramebuffers[this.CONTEXT_UID]||this.initFramebuffer(framebuffer);this.current!==framebuffer&&(this.current=framebuffer,gl.bindFramebuffer(gl.FRAMEBUFFER,fbo.framebuffer)),fbo.mipLevel!==mipLevel&&(framebuffer.dirtyId++,framebuffer.dirtyFormat++,fbo.mipLevel=mipLevel),fbo.dirtyId!==framebuffer.dirtyId&&(fbo.dirtyId=framebuffer.dirtyId,fbo.dirtyFormat!==framebuffer.dirtyFormat?(fbo.dirtyFormat=framebuffer.dirtyFormat,fbo.dirtySize=framebuffer.dirtySize,this.updateFramebuffer(framebuffer,mipLevel)):fbo.dirtySize!==framebuffer.dirtySize&&(fbo.dirtySize=framebuffer.dirtySize,this.resizeFramebuffer(framebuffer)));for(let i=0;i<framebuffer.colorTextures.length;i++){const tex=framebuffer.colorTextures[i];this.renderer.texture.unbind(tex.parentTextureArray||tex)}if(framebuffer.depthTexture&&this.renderer.texture.unbind(framebuffer.depthTexture),frame){const mipWidth=frame.width>>mipLevel,mipHeight=frame.height>>mipLevel,scale=mipWidth/frame.width;this.setViewport(frame.x*scale,frame.y*scale,mipWidth,mipHeight)}else{const mipWidth=framebuffer.width>>mipLevel,mipHeight=framebuffer.height>>mipLevel;this.setViewport(0,0,mipWidth,mipHeight)}}else this.current&&(this.current=null,gl.bindFramebuffer(gl.FRAMEBUFFER,null)),frame?this.setViewport(frame.x,frame.y,frame.width,frame.height):this.setViewport(0,0,this.renderer.width,this.renderer.height)}setViewport(x,y,width,height){const v=this.viewport;x=Math.round(x),y=Math.round(y),width=Math.round(width),height=Math.round(height),(v.width!==width||v.height!==height||v.x!==x||v.y!==y)&&(v.x=x,v.y=y,v.width=width,v.height=height,this.gl.viewport(x,y,width,height))}get size(){return this.current?{x:0,y:0,width:this.current.width,height:this.current.height}:{x:0,y:0,width:this.renderer.width,height:this.renderer.height}}clear(r,g,b,a,mask=BUFFER_BITS.COLOR|BUFFER_BITS.DEPTH){const{gl}=this;gl.clearColor(r,g,b,a),gl.clear(mask)}initFramebuffer(framebuffer){const{gl}=this,fbo=new GLFramebuffer(gl.createFramebuffer());return fbo.multisample=this.detectSamples(framebuffer.multisample),framebuffer.glFramebuffers[this.CONTEXT_UID]=fbo,this.managedFramebuffers.push(framebuffer),framebuffer.disposeRunner.add(this),fbo}resizeFramebuffer(framebuffer){const{gl}=this,fbo=framebuffer.glFramebuffers[this.CONTEXT_UID];if(fbo.stencil){let stencilFormat;gl.bindRenderbuffer(gl.RENDERBUFFER,fbo.stencil),stencilFormat=1===this.renderer.context.webGLVersion?gl.DEPTH_STENCIL:framebuffer.depth&&framebuffer.stencil?gl.DEPTH24_STENCIL8:framebuffer.depth?gl.DEPTH_COMPONENT24:gl.STENCIL_INDEX8,fbo.msaaBuffer?gl.renderbufferStorageMultisample(gl.RENDERBUFFER,fbo.multisample,stencilFormat,framebuffer.width,framebuffer.height):gl.renderbufferStorage(gl.RENDERBUFFER,stencilFormat,framebuffer.width,framebuffer.height)}const colorTextures=framebuffer.colorTextures;let count=colorTextures.length;gl.drawBuffers||(count=Math.min(count,1));for(let i=0;i<count;i++){const texture=colorTextures[i],parentTexture=texture.parentTextureArray||texture;this.renderer.texture.bind(parentTexture,0),0===i&&fbo.msaaBuffer&&(gl.bindRenderbuffer(gl.RENDERBUFFER,fbo.msaaBuffer),gl.renderbufferStorageMultisample(gl.RENDERBUFFER,fbo.multisample,parentTexture._glTextures[this.CONTEXT_UID].internalFormat,framebuffer.width,framebuffer.height))}framebuffer.depthTexture&&this.writeDepthTexture&&this.renderer.texture.bind(framebuffer.depthTexture,0)}updateFramebuffer(framebuffer,mipLevel){const{gl}=this,fbo=framebuffer.glFramebuffers[this.CONTEXT_UID],colorTextures=framebuffer.colorTextures;let count=colorTextures.length;gl.drawBuffers||(count=Math.min(count,1)),fbo.multisample>1&&this.canMultisampleFramebuffer(framebuffer)?fbo.msaaBuffer=fbo.msaaBuffer||gl.createRenderbuffer():fbo.msaaBuffer&&(gl.deleteRenderbuffer(fbo.msaaBuffer),fbo.msaaBuffer=null,fbo.blitFramebuffer&&(fbo.blitFramebuffer.dispose(),fbo.blitFramebuffer=null));const activeTextures=[];for(let i=0;i<count;i++){const texture=colorTextures[i],parentTexture=texture.parentTextureArray||texture;this.renderer.texture.bind(parentTexture,0),0===i&&fbo.msaaBuffer?(gl.bindRenderbuffer(gl.RENDERBUFFER,fbo.msaaBuffer),gl.renderbufferStorageMultisample(gl.RENDERBUFFER,fbo.multisample,parentTexture._glTextures[this.CONTEXT_UID].internalFormat,framebuffer.width,framebuffer.height),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.RENDERBUFFER,fbo.msaaBuffer)):(gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,texture.target,parentTexture._glTextures[this.CONTEXT_UID].texture,mipLevel),activeTextures.push(gl.COLOR_ATTACHMENT0+i))}if(activeTextures.length>1&&gl.drawBuffers(activeTextures),framebuffer.depthTexture&&this.writeDepthTexture){const depthTexture=framebuffer.depthTexture;this.renderer.texture.bind(depthTexture,0),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.TEXTURE_2D,depthTexture._glTextures[this.CONTEXT_UID].texture,mipLevel)}if(!framebuffer.stencil&&!framebuffer.depth||framebuffer.depthTexture&&this.writeDepthTexture)fbo.stencil&&(gl.deleteRenderbuffer(fbo.stencil),fbo.stencil=null);else{let stencilAttachment,stencilFormat;fbo.stencil=fbo.stencil||gl.createRenderbuffer(),1===this.renderer.context.webGLVersion?(stencilAttachment=gl.DEPTH_STENCIL_ATTACHMENT,stencilFormat=gl.DEPTH_STENCIL):framebuffer.depth&&framebuffer.stencil?(stencilAttachment=gl.DEPTH_STENCIL_ATTACHMENT,stencilFormat=gl.DEPTH24_STENCIL8):framebuffer.depth?(stencilAttachment=gl.DEPTH_ATTACHMENT,stencilFormat=gl.DEPTH_COMPONENT24):(stencilAttachment=gl.STENCIL_ATTACHMENT,stencilFormat=gl.STENCIL_INDEX8),gl.bindRenderbuffer(gl.RENDERBUFFER,fbo.stencil),fbo.msaaBuffer?gl.renderbufferStorageMultisample(gl.RENDERBUFFER,fbo.multisample,stencilFormat,framebuffer.width,framebuffer.height):gl.renderbufferStorage(gl.RENDERBUFFER,stencilFormat,framebuffer.width,framebuffer.height),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,stencilAttachment,gl.RENDERBUFFER,fbo.stencil)}}canMultisampleFramebuffer(framebuffer){return 1!==this.renderer.context.webGLVersion&&framebuffer.colorTextures.length<=1&&!framebuffer.depthTexture}detectSamples(samples){const{msaaSamples}=this;let res=MSAA_QUALITY.NONE;if(samples<=1||null===msaaSamples)return res;for(let i=0;i<msaaSamples.length;i++)if(msaaSamples[i]<=samples){res=msaaSamples[i];break}return 1===res&&(res=MSAA_QUALITY.NONE),res}blit(framebuffer,sourcePixels,destPixels){const{current,renderer,gl,CONTEXT_UID}=this;if(2!==renderer.context.webGLVersion||!current)return;const fbo=current.glFramebuffers[CONTEXT_UID];if(!fbo)return;if(!framebuffer){if(!fbo.msaaBuffer)return;const colorTexture=current.colorTextures[0];if(!colorTexture)return;fbo.blitFramebuffer||(fbo.blitFramebuffer=new Framebuffer(current.width,current.height),fbo.blitFramebuffer.addColorTexture(0,colorTexture)),(framebuffer=fbo.blitFramebuffer).colorTextures[0]!==colorTexture&&(framebuffer.colorTextures[0]=colorTexture,framebuffer.dirtyId++,framebuffer.dirtyFormat++),(framebuffer.width!==current.width||framebuffer.height!==current.height)&&(framebuffer.width=current.width,framebuffer.height=current.height,framebuffer.dirtyId++,framebuffer.dirtySize++)}sourcePixels||((sourcePixels=tempRectangle).width=current.width,sourcePixels.height=current.height),destPixels||(destPixels=sourcePixels);const sameSize=sourcePixels.width===destPixels.width&&sourcePixels.height===destPixels.height;this.bind(framebuffer),gl.bindFramebuffer(gl.READ_FRAMEBUFFER,fbo.framebuffer),gl.blitFramebuffer(sourcePixels.left,sourcePixels.top,sourcePixels.right,sourcePixels.bottom,destPixels.left,destPixels.top,destPixels.right,destPixels.bottom,gl.COLOR_BUFFER_BIT,sameSize?gl.NEAREST:gl.LINEAR),gl.bindFramebuffer(gl.READ_FRAMEBUFFER,framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer)}disposeFramebuffer(framebuffer,contextLost){const fbo=framebuffer.glFramebuffers[this.CONTEXT_UID],gl=this.gl;if(!fbo)return;delete framebuffer.glFramebuffers[this.CONTEXT_UID];const index=this.managedFramebuffers.indexOf(framebuffer);index>=0&&this.managedFramebuffers.splice(index,1),framebuffer.disposeRunner.remove(this),contextLost||(gl.deleteFramebuffer(fbo.framebuffer),fbo.msaaBuffer&&gl.deleteRenderbuffer(fbo.msaaBuffer),fbo.stencil&&gl.deleteRenderbuffer(fbo.stencil)),fbo.blitFramebuffer&&this.disposeFramebuffer(fbo.blitFramebuffer,contextLost)}disposeAll(contextLost){const list=this.managedFramebuffers;this.managedFramebuffers=[];for(let i=0;i<list.length;i++)this.disposeFramebuffer(list[i],contextLost)}forceStencil(){const framebuffer=this.current;if(!framebuffer)return;const fbo=framebuffer.glFramebuffers[this.CONTEXT_UID];if(!fbo||fbo.stencil&&framebuffer.stencil)return;framebuffer.stencil=!0;const w=framebuffer.width,h=framebuffer.height,gl=this.gl,stencil=fbo.stencil=gl.createRenderbuffer();let stencilAttachment,stencilFormat;gl.bindRenderbuffer(gl.RENDERBUFFER,stencil),1===this.renderer.context.webGLVersion?(stencilAttachment=gl.DEPTH_STENCIL_ATTACHMENT,stencilFormat=gl.DEPTH_STENCIL):framebuffer.depth?(stencilAttachment=gl.DEPTH_STENCIL_ATTACHMENT,stencilFormat=gl.DEPTH24_STENCIL8):(stencilAttachment=gl.STENCIL_ATTACHMENT,stencilFormat=gl.STENCIL_INDEX8),fbo.msaaBuffer?gl.renderbufferStorageMultisample(gl.RENDERBUFFER,fbo.multisample,stencilFormat,w,h):gl.renderbufferStorage(gl.RENDERBUFFER,stencilFormat,w,h),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,stencilAttachment,gl.RENDERBUFFER,stencil)}reset(){this.current=this.unknownFramebuffer,this.viewport=new Rectangle}destroy(){this.renderer=null}}FramebufferSystem.extension={type:ExtensionType.RendererSystem,name:"framebuffer"},extensions.add(FramebufferSystem);const GeometrySystem_byteSizeMap={5126:4,5123:2,5121:1};class GeometrySystem{constructor(renderer){this.renderer=renderer,this._activeGeometry=null,this._activeVao=null,this.hasVao=!0,this.hasInstance=!0,this.canUseUInt32ElementIndex=!1,this.managedGeometries={}}contextChange(){this.disposeAll(!0);const gl=this.gl=this.renderer.gl,context=this.renderer.context;if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,2!==context.webGLVersion){let nativeVaoExtension=this.renderer.context.extensions.vertexArrayObject;settings.PREFER_ENV===ENV.WEBGL_LEGACY&&(nativeVaoExtension=null),nativeVaoExtension?(gl.createVertexArray=()=>nativeVaoExtension.createVertexArrayOES(),gl.bindVertexArray=vao=>nativeVaoExtension.bindVertexArrayOES(vao),gl.deleteVertexArray=vao=>nativeVaoExtension.deleteVertexArrayOES(vao)):(this.hasVao=!1,gl.createVertexArray=()=>null,gl.bindVertexArray=()=>null,gl.deleteVertexArray=()=>null)}if(2!==context.webGLVersion){const instanceExt=gl.getExtension("ANGLE_instanced_arrays");instanceExt?(gl.vertexAttribDivisor=(a,b)=>instanceExt.vertexAttribDivisorANGLE(a,b),gl.drawElementsInstanced=(a,b,c,d,e)=>instanceExt.drawElementsInstancedANGLE(a,b,c,d,e),gl.drawArraysInstanced=(a,b,c,d)=>instanceExt.drawArraysInstancedANGLE(a,b,c,d)):this.hasInstance=!1}this.canUseUInt32ElementIndex=2===context.webGLVersion||!!context.extensions.uint32ElementIndex}bind(geometry,shader){shader=shader||this.renderer.shader.shader;const{gl}=this;let vaos=geometry.glVertexArrayObjects[this.CONTEXT_UID],incRefCount=!1;vaos||(this.managedGeometries[geometry.id]=geometry,geometry.disposeRunner.add(this),geometry.glVertexArrayObjects[this.CONTEXT_UID]=vaos={},incRefCount=!0);const vao=vaos[shader.program.id]||this.initGeometryVao(geometry,shader,incRefCount);this._activeGeometry=geometry,this._activeVao!==vao&&(this._activeVao=vao,this.hasVao?gl.bindVertexArray(vao):this.activateVao(geometry,shader.program)),this.updateBuffers()}reset(){this.unbind()}updateBuffers(){const geometry=this._activeGeometry,bufferSystem=this.renderer.buffer;for(let i=0;i<geometry.buffers.length;i++){const buffer=geometry.buffers[i];bufferSystem.update(buffer)}}checkCompatibility(geometry,program){const geometryAttributes=geometry.attributes,shaderAttributes=program.attributeData;for(const j in shaderAttributes)if(!geometryAttributes[j])throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`)}getSignature(geometry,program){const attribs=geometry.attributes,shaderAttributes=program.attributeData,strings=["g",geometry.id];for(const i in attribs)shaderAttributes[i]&&strings.push(i,shaderAttributes[i].location);return strings.join("-")}initGeometryVao(geometry,shader,incRefCount=!0){const gl=this.gl,CONTEXT_UID=this.CONTEXT_UID,bufferSystem=this.renderer.buffer,program=shader.program;program.glPrograms[CONTEXT_UID]||this.renderer.shader.generateProgram(shader),this.checkCompatibility(geometry,program);const signature=this.getSignature(geometry,program),vaoObjectHash=geometry.glVertexArrayObjects[this.CONTEXT_UID];let vao=vaoObjectHash[signature];if(vao)return vaoObjectHash[program.id]=vao,vao;const buffers=geometry.buffers,attributes=geometry.attributes,tempStride={},tempStart={};for(const j in buffers)tempStride[j]=0,tempStart[j]=0;for(const j in attributes)!attributes[j].size&&program.attributeData[j]?attributes[j].size=program.attributeData[j].size:attributes[j].size||console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`),tempStride[attributes[j].buffer]+=attributes[j].size*GeometrySystem_byteSizeMap[attributes[j].type];for(const j in attributes){const attribute=attributes[j],attribSize=attribute.size;void 0===attribute.stride&&(tempStride[attribute.buffer]===attribSize*GeometrySystem_byteSizeMap[attribute.type]?attribute.stride=0:attribute.stride=tempStride[attribute.buffer]),void 0===attribute.start&&(attribute.start=tempStart[attribute.buffer],tempStart[attribute.buffer]+=attribSize*GeometrySystem_byteSizeMap[attribute.type])}vao=gl.createVertexArray(),gl.bindVertexArray(vao);for(let i=0;i<buffers.length;i++){const buffer=buffers[i];bufferSystem.bind(buffer),incRefCount&&buffer._glBuffers[CONTEXT_UID].refCount++}return this.activateVao(geometry,program),vaoObjectHash[program.id]=vao,vaoObjectHash[signature]=vao,gl.bindVertexArray(null),bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER),vao}disposeGeometry(geometry,contextLost){if(!this.managedGeometries[geometry.id])return;delete this.managedGeometries[geometry.id];const vaos=geometry.glVertexArrayObjects[this.CONTEXT_UID],gl=this.gl,buffers=geometry.buffers,bufferSystem=this.renderer?.buffer;if(geometry.disposeRunner.remove(this),vaos){if(bufferSystem)for(let i=0;i<buffers.length;i++){const buf=buffers[i]._glBuffers[this.CONTEXT_UID];buf&&(buf.refCount--,0===buf.refCount&&!contextLost&&bufferSystem.dispose(buffers[i],contextLost))}if(!contextLost)for(const vaoId in vaos)if("g"===vaoId[0]){const vao=vaos[vaoId];this._activeVao===vao&&this.unbind(),gl.deleteVertexArray(vao)}delete geometry.glVertexArrayObjects[this.CONTEXT_UID]}}disposeAll(contextLost){const all=Object.keys(this.managedGeometries);for(let i=0;i<all.length;i++)this.disposeGeometry(this.managedGeometries[all[i]],contextLost)}activateVao(geometry,program){const gl=this.gl,CONTEXT_UID=this.CONTEXT_UID,bufferSystem=this.renderer.buffer,buffers=geometry.buffers,attributes=geometry.attributes;geometry.indexBuffer&&bufferSystem.bind(geometry.indexBuffer);let lastBuffer=null;for(const j in attributes){const attribute=attributes[j],buffer=buffers[attribute.buffer],glBuffer=buffer._glBuffers[CONTEXT_UID];if(program.attributeData[j]){lastBuffer!==glBuffer&&(bufferSystem.bind(buffer),lastBuffer=glBuffer);const location=program.attributeData[j].location;if(gl.enableVertexAttribArray(location),gl.vertexAttribPointer(location,attribute.size,attribute.type||gl.FLOAT,attribute.normalized,attribute.stride,attribute.start),attribute.instance){if(!this.hasInstance)throw new Error("geometry error, GPU Instancing is not supported on this device");gl.vertexAttribDivisor(location,attribute.divisor)}}}}draw(type,size,start,instanceCount){const{gl}=this,geometry=this._activeGeometry;if(geometry.indexBuffer){const byteSize=geometry.indexBuffer.data.BYTES_PER_ELEMENT,glType=2===byteSize?gl.UNSIGNED_SHORT:gl.UNSIGNED_INT;2===byteSize||4===byteSize&&this.canUseUInt32ElementIndex?geometry.instanced?gl.drawElementsInstanced(type,size||geometry.indexBuffer.data.length,glType,(start||0)*byteSize,instanceCount||1):gl.drawElements(type,size||geometry.indexBuffer.data.length,glType,(start||0)*byteSize):console.warn("unsupported index buffer type: uint32")}else geometry.instanced?gl.drawArraysInstanced(type,start,size||geometry.getSize(),instanceCount||1):gl.drawArrays(type,start,size||geometry.getSize());return this}unbind(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null}destroy(){this.renderer=null}}GeometrySystem.extension={type:ExtensionType.RendererSystem,name:"geometry"},extensions.add(GeometrySystem);const tempMat=new Matrix;class TextureMatrix{constructor(texture,clampMargin){this._texture=texture,this.mapCoord=new Matrix,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,this.clampMargin=typeof clampMargin>"u"?.5:clampMargin,this.isSimple=!1}get texture(){return this._texture}set texture(value){this._texture=value,this._textureID=-1}multiplyUvs(uvs,out){void 0===out&&(out=uvs);const mat=this.mapCoord;for(let i=0;i<uvs.length;i+=2){const x=uvs[i],y=uvs[i+1];out[i]=x*mat.a+y*mat.c+mat.tx,out[i+1]=x*mat.b+y*mat.d+mat.ty}return out}update(forceUpdate){const tex=this._texture;if(!tex||!tex.valid||!forceUpdate&&this._textureID===tex._updateID)return!1;this._textureID=tex._updateID,this._updateID++;const uvs=tex._uvs;this.mapCoord.set(uvs.x1-uvs.x0,uvs.y1-uvs.y0,uvs.x3-uvs.x0,uvs.y3-uvs.y0,uvs.x0,uvs.y0);const orig=tex.orig,trim=tex.trim;trim&&(tempMat.set(orig.width/trim.width,0,0,orig.height/trim.height,-trim.x/trim.width,-trim.y/trim.height),this.mapCoord.append(tempMat));const texBase=tex.baseTexture,frame=this.uClampFrame,margin=this.clampMargin/texBase.resolution,offset=this.clampOffset;return frame[0]=(tex._frame.x+margin+offset)/texBase.width,frame[1]=(tex._frame.y+margin+offset)/texBase.height,frame[2]=(tex._frame.x+tex._frame.width-margin+offset)/texBase.width,frame[3]=(tex._frame.y+tex._frame.height-margin+offset)/texBase.height,this.uClampOffset[0]=offset/texBase.realWidth,this.uClampOffset[1]=offset/texBase.realHeight,this.isSimple=tex._frame.width===texBase.width&&tex._frame.height===texBase.height&&0===tex.rotate,!0}}class SpriteMaskFilter extends Filter{constructor(vertexSrc,fragmentSrc,uniforms){let sprite=null;"string"!=typeof vertexSrc&&void 0===fragmentSrc&&void 0===uniforms&&(sprite=vertexSrc,vertexSrc=void 0,fragmentSrc=void 0,uniforms=void 0),super(vertexSrc||"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n",fragmentSrc||"varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n",uniforms),this.maskSprite=sprite,this.maskMatrix=new Matrix}get maskSprite(){return this._maskSprite}set maskSprite(value){this._maskSprite=value,this._maskSprite&&(this._maskSprite.renderable=!1)}apply(filterManager,input,output,clearMode){const maskSprite=this._maskSprite,tex=maskSprite._texture;tex.valid&&(tex.uvMatrix||(tex.uvMatrix=new TextureMatrix(tex,0)),tex.uvMatrix.update(),this.uniforms.npmAlpha=tex.baseTexture.alphaMode?0:1,this.uniforms.mask=tex,this.uniforms.otherMatrix=filterManager.calculateSpriteMatrix(this.maskMatrix,maskSprite).prepend(tex.uvMatrix.mapCoord),this.uniforms.alpha=maskSprite.worldAlpha,this.uniforms.maskClamp=tex.uvMatrix.uClampFrame,filterManager.applyFilter(this,input,output,clearMode))}}class MaskData{constructor(maskObject=null){this.type=MASK_TYPES.NONE,this.autoDetect=!0,this.maskObject=maskObject||null,this.pooled=!1,this.isMaskData=!0,this.resolution=null,this.multisample=Filter.defaultMultisample,this.enabled=!0,this.colorMask=15,this._filters=null,this._stencilCounter=0,this._scissorCounter=0,this._scissorRect=null,this._scissorRectLocal=null,this._colorMask=15,this._target=null}get filter(){return this._filters?this._filters[0]:null}set filter(value){value?this._filters?this._filters[0]=value:this._filters=[value]:this._filters=null}reset(){this.pooled&&(this.maskObject=null,this.type=MASK_TYPES.NONE,this.autoDetect=!0),this._target=null,this._scissorRectLocal=null}copyCountersOrReset(maskAbove){maskAbove?(this._stencilCounter=maskAbove._stencilCounter,this._scissorCounter=maskAbove._scissorCounter,this._scissorRect=maskAbove._scissorRect):(this._stencilCounter=0,this._scissorCounter=0,this._scissorRect=null)}}class MaskSystem{constructor(renderer){this.renderer=renderer,this.enableScissor=!0,this.alphaMaskPool=[],this.maskDataPool=[],this.maskStack=[],this.alphaMaskIndex=0}setMaskStack(maskStack){this.maskStack=maskStack,this.renderer.scissor.setMaskStack(maskStack),this.renderer.stencil.setMaskStack(maskStack)}push(target,maskDataOrTarget){let maskData=maskDataOrTarget;if(!maskData.isMaskData){const d=this.maskDataPool.pop()||new MaskData;d.pooled=!0,d.maskObject=maskDataOrTarget,maskData=d}const maskAbove=0!==this.maskStack.length?this.maskStack[this.maskStack.length-1]:null;if(maskData.copyCountersOrReset(maskAbove),maskData._colorMask=maskAbove?maskAbove._colorMask:15,maskData.autoDetect&&this.detect(maskData),maskData._target=target,maskData.type!==MASK_TYPES.SPRITE&&this.maskStack.push(maskData),maskData.enabled)switch(maskData.type){case MASK_TYPES.SCISSOR:this.renderer.scissor.push(maskData);break;case MASK_TYPES.STENCIL:this.renderer.stencil.push(maskData);break;case MASK_TYPES.SPRITE:maskData.copyCountersOrReset(null),this.pushSpriteMask(maskData);break;case MASK_TYPES.COLOR:this.pushColorMask(maskData)}maskData.type===MASK_TYPES.SPRITE&&this.maskStack.push(maskData)}pop(target){const maskData=this.maskStack.pop();if(maskData&&maskData._target===target){if(maskData.enabled)switch(maskData.type){case MASK_TYPES.SCISSOR:this.renderer.scissor.pop(maskData);break;case MASK_TYPES.STENCIL:this.renderer.stencil.pop(maskData.maskObject);break;case MASK_TYPES.SPRITE:this.popSpriteMask(maskData);break;case MASK_TYPES.COLOR:this.popColorMask(maskData)}if(maskData.reset(),maskData.pooled&&this.maskDataPool.push(maskData),0!==this.maskStack.length){const maskCurrent=this.maskStack[this.maskStack.length-1];maskCurrent.type===MASK_TYPES.SPRITE&&maskCurrent._filters&&(maskCurrent._filters[0].maskSprite=maskCurrent.maskObject)}}}detect(maskData){const maskObject=maskData.maskObject;maskObject?maskObject.isSprite?maskData.type=MASK_TYPES.SPRITE:this.enableScissor&&this.renderer.scissor.testScissor(maskData)?maskData.type=MASK_TYPES.SCISSOR:maskData.type=MASK_TYPES.STENCIL:maskData.type=MASK_TYPES.COLOR}pushSpriteMask(maskData){const{maskObject}=maskData,target=maskData._target;let alphaMaskFilter=maskData._filters;alphaMaskFilter||(alphaMaskFilter=this.alphaMaskPool[this.alphaMaskIndex],alphaMaskFilter||(alphaMaskFilter=this.alphaMaskPool[this.alphaMaskIndex]=[new SpriteMaskFilter])),alphaMaskFilter[0].resolution=maskData.resolution,alphaMaskFilter[0].multisample=maskData.multisample,alphaMaskFilter[0].maskSprite=maskObject;const stashFilterArea=target.filterArea;target.filterArea=maskObject.getBounds(!0),this.renderer.filter.push(target,alphaMaskFilter),target.filterArea=stashFilterArea,maskData._filters||this.alphaMaskIndex++}popSpriteMask(maskData){this.renderer.filter.pop(),maskData._filters?maskData._filters[0].maskSprite=null:(this.alphaMaskIndex--,this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite=null)}pushColorMask(maskData){const currColorMask=maskData._colorMask,nextColorMask=maskData._colorMask=currColorMask&maskData.colorMask;nextColorMask!==currColorMask&&this.renderer.gl.colorMask(0!=(1&nextColorMask),0!=(2&nextColorMask),0!=(4&nextColorMask),0!=(8&nextColorMask))}popColorMask(maskData){const currColorMask=maskData._colorMask,nextColorMask=this.maskStack.length>0?this.maskStack[this.maskStack.length-1]._colorMask:15;nextColorMask!==currColorMask&&this.renderer.gl.colorMask(0!=(1&nextColorMask),0!=(2&nextColorMask),0!=(4&nextColorMask),0!=(8&nextColorMask))}destroy(){this.renderer=null}}MaskSystem.extension={type:ExtensionType.RendererSystem,name:"mask"},extensions.add(MaskSystem);class AbstractMaskSystem{constructor(renderer){this.renderer=renderer,this.maskStack=[],this.glConst=0}getStackLength(){return this.maskStack.length}setMaskStack(maskStack){const{gl}=this.renderer,curStackLen=this.getStackLength();this.maskStack=maskStack;const newStackLen=this.getStackLength();newStackLen!==curStackLen&&(0===newStackLen?gl.disable(this.glConst):(gl.enable(this.glConst),this._useCurrent()))}_useCurrent(){}destroy(){this.renderer=null,this.maskStack=null}}const ScissorSystem_tempMatrix=new Matrix,rectPool=[],_ScissorSystem=class _ScissorSystem2 extends AbstractMaskSystem{constructor(renderer){super(renderer),this.glConst=settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST}getStackLength(){const maskData=this.maskStack[this.maskStack.length-1];return maskData?maskData._scissorCounter:0}calcScissorRect(maskData){if(maskData._scissorRectLocal)return;const prevData=maskData._scissorRect,{maskObject}=maskData,{renderer}=this,renderTextureSystem=renderer.renderTexture,rect=maskObject.getBounds(!0,rectPool.pop()??new Rectangle);this.roundFrameToPixels(rect,renderTextureSystem.current?renderTextureSystem.current.resolution:renderer.resolution,renderTextureSystem.sourceFrame,renderTextureSystem.destinationFrame,renderer.projection.transform),prevData&&rect.fit(prevData),maskData._scissorRectLocal=rect}static isMatrixRotated(matrix){if(!matrix)return!1;const{a,b,c,d}=matrix;return(Math.abs(b)>1e-4||Math.abs(c)>1e-4)&&(Math.abs(a)>1e-4||Math.abs(d)>1e-4)}testScissor(maskData){const{maskObject}=maskData;if(!maskObject.isFastRect||!maskObject.isFastRect()||_ScissorSystem2.isMatrixRotated(maskObject.worldTransform)||_ScissorSystem2.isMatrixRotated(this.renderer.projection.transform))return!1;this.calcScissorRect(maskData);const rect=maskData._scissorRectLocal;return rect.width>0&&rect.height>0}roundFrameToPixels(frame,resolution,bindingSourceFrame,bindingDestinationFrame,transform){_ScissorSystem2.isMatrixRotated(transform)||((transform=transform?ScissorSystem_tempMatrix.copyFrom(transform):ScissorSystem_tempMatrix.identity()).translate(-bindingSourceFrame.x,-bindingSourceFrame.y).scale(bindingDestinationFrame.width/bindingSourceFrame.width,bindingDestinationFrame.height/bindingSourceFrame.height).translate(bindingDestinationFrame.x,bindingDestinationFrame.y),this.renderer.filter.transformAABB(transform,frame),frame.fit(bindingDestinationFrame),frame.x=Math.round(frame.x*resolution),frame.y=Math.round(frame.y*resolution),frame.width=Math.round(frame.width*resolution),frame.height=Math.round(frame.height*resolution))}push(maskData){maskData._scissorRectLocal||this.calcScissorRect(maskData);const{gl}=this.renderer;maskData._scissorRect||gl.enable(gl.SCISSOR_TEST),maskData._scissorCounter++,maskData._scissorRect=maskData._scissorRectLocal,this._useCurrent()}pop(maskData){const{gl}=this.renderer;maskData&&rectPool.push(maskData._scissorRectLocal),this.getStackLength()>0?this._useCurrent():gl.disable(gl.SCISSOR_TEST)}_useCurrent(){const rect=this.maskStack[this.maskStack.length-1]._scissorRect;let y;y=this.renderer.renderTexture.current?rect.y:this.renderer.height-rect.height-rect.y,this.renderer.gl.scissor(rect.x,y,rect.width,rect.height)}};_ScissorSystem.extension={type:ExtensionType.RendererSystem,name:"scissor"};let ScissorSystem=_ScissorSystem;extensions.add(ScissorSystem);class StencilSystem extends AbstractMaskSystem{constructor(renderer){super(renderer),this.glConst=settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST}getStackLength(){const maskData=this.maskStack[this.maskStack.length-1];return maskData?maskData._stencilCounter:0}push(maskData){const maskObject=maskData.maskObject,{gl}=this.renderer,prevMaskCount=maskData._stencilCounter;0===prevMaskCount&&(this.renderer.framebuffer.forceStencil(),gl.clearStencil(0),gl.clear(gl.STENCIL_BUFFER_BIT),gl.enable(gl.STENCIL_TEST)),maskData._stencilCounter++;const colorMask=maskData._colorMask;0!==colorMask&&(maskData._colorMask=0,gl.colorMask(!1,!1,!1,!1)),gl.stencilFunc(gl.EQUAL,prevMaskCount,4294967295),gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR),maskObject.renderable=!0,maskObject.render(this.renderer),this.renderer.batch.flush(),maskObject.renderable=!1,0!==colorMask&&(maskData._colorMask=colorMask,gl.colorMask(0!=(1&colorMask),0!=(2&colorMask),0!=(4&colorMask),0!=(8&colorMask))),this._useCurrent()}pop(maskObject){const gl=this.renderer.gl;if(0===this.getStackLength())gl.disable(gl.STENCIL_TEST);else{const maskData=0!==this.maskStack.length?this.maskStack[this.maskStack.length-1]:null,colorMask=maskData?maskData._colorMask:15;0!==colorMask&&(maskData._colorMask=0,gl.colorMask(!1,!1,!1,!1)),gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR),maskObject.renderable=!0,maskObject.render(this.renderer),this.renderer.batch.flush(),maskObject.renderable=!1,0!==colorMask&&(maskData._colorMask=colorMask,gl.colorMask(0!=(1&colorMask),0!=(2&colorMask),0!=(4&colorMask),0!=(8&colorMask))),this._useCurrent()}}_useCurrent(){const gl=this.renderer.gl;gl.stencilFunc(gl.EQUAL,this.getStackLength(),4294967295),gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP)}}StencilSystem.extension={type:ExtensionType.RendererSystem,name:"stencil"},extensions.add(StencilSystem);class PluginSystem{constructor(renderer){this.renderer=renderer,this.plugins={},Object.defineProperties(this.plugins,{extract:{enumerable:!1,get:()=>(deprecation("7.0.0","renderer.plugins.extract has moved to renderer.extract"),renderer.extract)},prepare:{enumerable:!1,get:()=>(deprecation("7.0.0","renderer.plugins.prepare has moved to renderer.prepare"),renderer.prepare)},interaction:{enumerable:!1,get:()=>(deprecation("7.0.0","renderer.plugins.interaction has been deprecated, use renderer.events"),renderer.events)}})}init(){const staticMap=this.rendererPlugins;for(const o in staticMap)this.plugins[o]=new staticMap[o](this.renderer)}destroy(){for(const o in this.plugins)this.plugins[o].destroy(),this.plugins[o]=null}}PluginSystem.extension={type:[ExtensionType.RendererSystem,ExtensionType.CanvasRendererSystem],name:"_plugin"},extensions.add(PluginSystem);class ProjectionSystem{constructor(renderer){this.renderer=renderer,this.destinationFrame=null,this.sourceFrame=null,this.defaultFrame=null,this.projectionMatrix=new Matrix,this.transform=null}update(destinationFrame,sourceFrame,resolution,root){this.destinationFrame=destinationFrame||this.destinationFrame||this.defaultFrame,this.sourceFrame=sourceFrame||this.sourceFrame||destinationFrame,this.calculateProjection(this.destinationFrame,this.sourceFrame,resolution,root),this.transform&&this.projectionMatrix.append(this.transform);const renderer=this.renderer;renderer.globalUniforms.uniforms.projectionMatrix=this.projectionMatrix,renderer.globalUniforms.update(),renderer.shader.shader&&renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals)}calculateProjection(_destinationFrame,sourceFrame,_resolution,root){const pm=this.projectionMatrix,sign=root?-1:1;pm.identity(),pm.a=1/sourceFrame.width*2,pm.d=sign*(1/sourceFrame.height*2),pm.tx=-1-sourceFrame.x*pm.a,pm.ty=-sign-sourceFrame.y*pm.d}setTransform(_matrix){}destroy(){this.renderer=null}}ProjectionSystem.extension={type:ExtensionType.RendererSystem,name:"projection"},extensions.add(ProjectionSystem);const tempTransform=new Transform,tempRect=new Rectangle;class GenerateTextureSystem{constructor(renderer){this.renderer=renderer,this._tempMatrix=new Matrix}generateTexture(displayObject,options){const{region:manualRegion,...textureOptions}=options||{},region=manualRegion?.copyTo(tempRect)||displayObject.getLocalBounds(tempRect,!0),resolution=textureOptions.resolution||this.renderer.resolution;region.width=Math.max(region.width,1/resolution),region.height=Math.max(region.height,1/resolution),textureOptions.width=region.width,textureOptions.height=region.height,textureOptions.resolution=resolution,textureOptions.multisample??(textureOptions.multisample=this.renderer.multisample);const renderTexture=RenderTexture.create(textureOptions);this._tempMatrix.tx=-region.x,this._tempMatrix.ty=-region.y;const transform=displayObject.transform;return displayObject.transform=tempTransform,this.renderer.render(displayObject,{renderTexture,transform:this._tempMatrix,skipUpdateTransform:!!displayObject.parent,blit:!0}),displayObject.transform=transform,renderTexture}destroy(){}}GenerateTextureSystem.extension={type:[ExtensionType.RendererSystem,ExtensionType.CanvasRendererSystem],name:"textureGenerator"},extensions.add(GenerateTextureSystem);const RenderTextureSystem_tempRect=new Rectangle,tempRect2=new Rectangle;class RenderTextureSystem{constructor(renderer){this.renderer=renderer,this.defaultMaskStack=[],this.current=null,this.sourceFrame=new Rectangle,this.destinationFrame=new Rectangle,this.viewportFrame=new Rectangle}contextChange(){const attributes=this.renderer?.gl.getContextAttributes();this._rendererPremultipliedAlpha=!!(attributes&&attributes.alpha&&attributes.premultipliedAlpha)}bind(renderTexture=null,sourceFrame,destinationFrame){const renderer=this.renderer;let baseTexture,framebuffer,resolution;this.current=renderTexture,renderTexture?(baseTexture=renderTexture.baseTexture,resolution=baseTexture.resolution,sourceFrame||(RenderTextureSystem_tempRect.width=renderTexture.frame.width,RenderTextureSystem_tempRect.height=renderTexture.frame.height,sourceFrame=RenderTextureSystem_tempRect),destinationFrame||(tempRect2.x=renderTexture.frame.x,tempRect2.y=renderTexture.frame.y,tempRect2.width=sourceFrame.width,tempRect2.height=sourceFrame.height,destinationFrame=tempRect2),framebuffer=baseTexture.framebuffer):(resolution=renderer.resolution,sourceFrame||(RenderTextureSystem_tempRect.width=renderer._view.screen.width,RenderTextureSystem_tempRect.height=renderer._view.screen.height,sourceFrame=RenderTextureSystem_tempRect),destinationFrame||((destinationFrame=RenderTextureSystem_tempRect).width=sourceFrame.width,destinationFrame.height=sourceFrame.height));const viewportFrame=this.viewportFrame;viewportFrame.x=destinationFrame.x*resolution,viewportFrame.y=destinationFrame.y*resolution,viewportFrame.width=destinationFrame.width*resolution,viewportFrame.height=destinationFrame.height*resolution,renderTexture||(viewportFrame.y=renderer.view.height-(viewportFrame.y+viewportFrame.height)),viewportFrame.ceil(),this.renderer.framebuffer.bind(framebuffer,viewportFrame),this.renderer.projection.update(destinationFrame,sourceFrame,resolution,!framebuffer),renderTexture?this.renderer.mask.setMaskStack(baseTexture.maskStack):this.renderer.mask.setMaskStack(this.defaultMaskStack),this.sourceFrame.copyFrom(sourceFrame),this.destinationFrame.copyFrom(destinationFrame)}clear(clearColor,mask){const fallbackColor=this.current?this.current.baseTexture.clear:this.renderer.background.backgroundColor,color=Color.shared.setValue(clearColor||fallbackColor);(this.current&&this.current.baseTexture.alphaMode>0||!this.current&&this._rendererPremultipliedAlpha)&&color.premultiply(color.alpha);const destinationFrame=this.destinationFrame,baseFrame=this.current?this.current.baseTexture:this.renderer._view.screen,clearMask=destinationFrame.width!==baseFrame.width||destinationFrame.height!==baseFrame.height;if(clearMask){let{x,y,width,height}=this.viewportFrame;x=Math.round(x),y=Math.round(y),width=Math.round(width),height=Math.round(height),this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),this.renderer.gl.scissor(x,y,width,height)}this.renderer.framebuffer.clear(color.red,color.green,color.blue,color.alpha,mask),clearMask&&this.renderer.scissor.pop()}resize(){this.bind(null)}reset(){this.bind(null)}destroy(){this.renderer=null}}RenderTextureSystem.extension={type:ExtensionType.RendererSystem,name:"renderTexture"},extensions.add(RenderTextureSystem);class GLProgram{constructor(program,uniformData){this.program=program,this.uniformData=uniformData,this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBufferBindings={}}destroy(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBufferBindings=null,this.program=null}}function compileShader(gl,type,src){const shader=gl.createShader(type);return gl.shaderSource(shader,src),gl.compileShader(shader),shader}function booleanArray(size){const array=new Array(size);for(let i=0;i<array.length;i++)array[i]=!1;return array}function defaultValue(type,size){switch(type){case"float":case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"vec2":return new Float32Array(2*size);case"vec3":return new Float32Array(3*size);case"vec4":return new Float32Array(4*size);case"ivec2":return new Int32Array(2*size);case"ivec3":return new Int32Array(3*size);case"ivec4":return new Int32Array(4*size);case"uvec2":return new Uint32Array(2*size);case"uvec3":return new Uint32Array(3*size);case"uvec4":return new Uint32Array(4*size);case"bool":return!1;case"bvec2":return booleanArray(2*size);case"bvec3":return booleanArray(3*size);case"bvec4":return booleanArray(4*size);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}function logPrettyShaderError(gl,shader){const shaderSrc=gl.getShaderSource(shader).split("\n").map(((line,index)=>`${index}: ${line}`)),shaderLog=gl.getShaderInfoLog(shader),splitShader=shaderLog.split("\n"),dedupe={},lineNumbers=splitShader.map((line=>parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1")))).filter((n=>!(!n||dedupe[n])&&(dedupe[n]=!0,!0))),logArgs=[""];lineNumbers.forEach((number=>{shaderSrc[number-1]=`%c${shaderSrc[number-1]}%c`,logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")}));const fragmentSourceToLog=shaderSrc.join("\n");logArgs[0]=fragmentSourceToLog,console.error(shaderLog),console.groupCollapsed("click to view full shader code"),console.warn(...logArgs),console.groupEnd()}function generateProgram(gl,program){const glVertShader=compileShader(gl,gl.VERTEX_SHADER,program.vertexSrc),glFragShader=compileShader(gl,gl.FRAGMENT_SHADER,program.fragmentSrc),webGLProgram=gl.createProgram();gl.attachShader(webGLProgram,glVertShader),gl.attachShader(webGLProgram,glFragShader);const transformFeedbackVaryings=program.extra?.transformFeedbackVaryings;if(transformFeedbackVaryings&&("function"!=typeof gl.transformFeedbackVaryings?console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given."):gl.transformFeedbackVaryings(webGLProgram,transformFeedbackVaryings.names,"separate"===transformFeedbackVaryings.bufferMode?gl.SEPARATE_ATTRIBS:gl.INTERLEAVED_ATTRIBS)),gl.linkProgram(webGLProgram),gl.getProgramParameter(webGLProgram,gl.LINK_STATUS)||function logProgramError(gl,program,vertexShader,fragmentShader){gl.getProgramParameter(program,gl.LINK_STATUS)||(gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS)||logPrettyShaderError(gl,vertexShader),gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS)||logPrettyShaderError(gl,fragmentShader),console.error("PixiJS Error: Could not initialize shader."),""!==gl.getProgramInfoLog(program)&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",gl.getProgramInfoLog(program)))}(gl,webGLProgram,glVertShader,glFragShader),program.attributeData=function getAttributeData(program,gl){const attributes={},totalAttributes=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(let i=0;i<totalAttributes;i++){const attribData=gl.getActiveAttrib(program,i);if(attribData.name.startsWith("gl_"))continue;const type=mapType(gl,attribData.type),data={type,name:attribData.name,size:mapSize(type),location:gl.getAttribLocation(program,attribData.name)};attributes[attribData.name]=data}return attributes}(webGLProgram,gl),program.uniformData=function getUniformData(program,gl){const uniforms={},totalUniforms=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(let i=0;i<totalUniforms;i++){const uniformData=gl.getActiveUniform(program,i),name=uniformData.name.replace(/\[.*?\]$/,""),isArray=!!uniformData.name.match(/\[.*?\]$/),type=mapType(gl,uniformData.type);uniforms[name]={name,index:i,type,size:uniformData.size,isArray,value:defaultValue(type,uniformData.size)}}return uniforms}(webGLProgram,gl),!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)){const keys=Object.keys(program.attributeData);keys.sort(((a,b)=>a>b?1:-1));for(let i=0;i<keys.length;i++)program.attributeData[keys[i]].location=i,gl.bindAttribLocation(webGLProgram,i,keys[i]);gl.linkProgram(webGLProgram)}gl.deleteShader(glVertShader),gl.deleteShader(glFragShader);const uniformData={};for(const i in program.uniformData){const data=program.uniformData[i];uniformData[i]={location:gl.getUniformLocation(webGLProgram,i),value:defaultValue(data.type,data.size)}}return new GLProgram(webGLProgram,uniformData)}function uboUpdate(_ud,_uv,_renderer,_syncData,buffer){_renderer.buffer.update(buffer)}const UBO_TO_SINGLE_SETTERS={float:"\n        data[offset] = v;\n    ",vec2:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",vec3:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",vec4:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",mat2:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",mat3:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",mat4:"\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "},GLSL_TO_STD40_SIZE={float:4,vec2:8,vec3:12,vec4:16,int:4,ivec2:8,ivec3:12,ivec4:16,uint:4,uvec2:8,uvec3:12,uvec4:16,bool:4,bvec2:8,bvec3:12,bvec4:16,mat2:32,mat3:48,mat4:64};function generateUniformBufferSync(group,uniformData){if(!group.autoManage)return{size:0,syncFunc:uboUpdate};const usedUniformDatas=function getUBOData(uniforms,uniformData){const usedUniformDatas=[];for(const i in uniforms)uniformData[i]&&usedUniformDatas.push(uniformData[i]);return usedUniformDatas.sort(((a,b)=>a.index-b.index)),usedUniformDatas}(group.uniforms,uniformData),{uboElements,size}=function createUBOElements(uniformData){const uboElements=uniformData.map((data=>({data,offset:0,dataLen:0,dirty:0})));let size=0,chunkSize=0,offset=0;for(let i=0;i<uboElements.length;i++){const uboElement=uboElements[i];if(size=GLSL_TO_STD40_SIZE[uboElement.data.type],uboElement.data.size>1&&(size=Math.max(size,16)*uboElement.data.size),uboElement.dataLen=size,chunkSize%size!=0&&chunkSize<16){const lineUpValue=chunkSize%size%16;chunkSize+=lineUpValue,offset+=lineUpValue}chunkSize+size>16?(offset=16*Math.ceil(offset/16),uboElement.offset=offset,offset+=size,chunkSize=size):(uboElement.offset=offset,chunkSize+=size,offset+=size)}return offset=16*Math.ceil(offset/16),{uboElements,size:offset}}(usedUniformDatas),funcFragments=["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];for(let i=0;i<uboElements.length;i++){const uboElement=uboElements[i],uniform=group.uniforms[uboElement.data.name],name=uboElement.data.name;let parsed=!1;for(let j=0;j<uniformParsers.length;j++){const uniformParser=uniformParsers[j];if(uniformParser.codeUbo&&uniformParser.test(uboElement.data,uniform)){funcFragments.push(`offset = ${uboElement.offset/4};`,uniformParsers[j].codeUbo(uboElement.data.name,uniform)),parsed=!0;break}}if(!parsed)if(uboElement.data.size>1){const size2=mapSize(uboElement.data.type),rowSize=Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type]/16,1),elementSize=size2/rowSize,remainder=(4-elementSize%4)%4;funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset/4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size*rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `)}else{const template=UBO_TO_SINGLE_SETTERS[uboElement.data.type];funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset/4};\n                ${template};\n                `)}}return funcFragments.push("\n       renderer.buffer.update(buffer);\n    "),{size,syncFunc:new Function("ud","uv","renderer","syncData","buffer",funcFragments.join("\n"))}}let unsafeEval;let ShaderSystem_UID=0;const defaultSyncData={textureCount:0,uboCount:0};class ShaderSystem{constructor(renderer){this.destroyed=!1,this.renderer=renderer,this.systemCheck(),this.gl=null,this.shader=null,this.program=null,this.cache={},this._uboCache={},this.id=ShaderSystem_UID++}systemCheck(){if(!function unsafeEvalSupported(){if("boolean"==typeof unsafeEval)return unsafeEval;try{unsafeEval=!0===new Function("param1","param2","param3","return param1[param2] === param3;")({a:"b"},"a","b")}catch{unsafeEval=!1}return unsafeEval}())throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")}contextChange(gl){this.gl=gl,this.reset()}bind(shader,dontSync){shader.disposeRunner.add(this),shader.uniforms.globals=this.renderer.globalUniforms;const program=shader.program,glProgram=program.glPrograms[this.renderer.CONTEXT_UID]||this.generateProgram(shader);return this.shader=shader,this.program!==program&&(this.program=program,this.gl.useProgram(glProgram.program)),dontSync||(defaultSyncData.textureCount=0,defaultSyncData.uboCount=0,this.syncUniformGroup(shader.uniformGroup,defaultSyncData)),glProgram}setUniforms(uniforms){const shader=this.shader.program,glProgram=shader.glPrograms[this.renderer.CONTEXT_UID];shader.syncUniforms(glProgram.uniformData,uniforms,this.renderer)}syncUniformGroup(group,syncData){const glProgram=this.getGlProgram();(!group.static||group.dirtyId!==glProgram.uniformDirtyGroups[group.id])&&(glProgram.uniformDirtyGroups[group.id]=group.dirtyId,this.syncUniforms(group,glProgram,syncData))}syncUniforms(group,glProgram,syncData){(group.syncUniforms[this.shader.program.id]||this.createSyncGroups(group))(glProgram.uniformData,group.uniforms,this.renderer,syncData)}createSyncGroups(group){const id=this.getSignature(group,this.shader.program.uniformData,"u");return this.cache[id]||(this.cache[id]=function generateUniformsSync(group,uniformData){const funcFragments=["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];for(const i in group.uniforms){const data=uniformData[i];if(!data){!0===group.uniforms[i]?.group&&(group.uniforms[i].ubo?funcFragments.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');\n                    `):funcFragments.push(`\n                        renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                    `));continue}const uniform=group.uniforms[i];let parsed=!1;for(let j=0;j<uniformParsers.length;j++)if(uniformParsers[j].test(data,uniform)){funcFragments.push(uniformParsers[j].code(i,uniform)),parsed=!0;break}if(!parsed){const template=(1!==data.size||data.isArray?GLSL_TO_ARRAY_SETTERS:GLSL_TO_SINGLE_SETTERS_CACHED)[data.type].replace("location",`ud["${i}"].location`);funcFragments.push(`\n            cu = ud["${i}"];\n            cv = cu.value;\n            v = uv["${i}"];\n            ${template};`)}}return new Function("ud","uv","renderer","syncData",funcFragments.join("\n"))}(group,this.shader.program.uniformData)),group.syncUniforms[this.shader.program.id]=this.cache[id],group.syncUniforms[this.shader.program.id]}syncUniformBufferGroup(group,name){const glProgram=this.getGlProgram();if(!group.static||0!==group.dirtyId||!glProgram.uniformGroups[group.id]){group.dirtyId=0;const syncFunc=glProgram.uniformGroups[group.id]||this.createSyncBufferGroup(group,glProgram,name);group.buffer.update(),syncFunc(glProgram.uniformData,group.uniforms,this.renderer,defaultSyncData,group.buffer)}this.renderer.buffer.bindBufferBase(group.buffer,glProgram.uniformBufferBindings[name])}createSyncBufferGroup(group,glProgram,name){const{gl}=this.renderer;this.renderer.buffer.bind(group.buffer);const uniformBlockIndex=this.gl.getUniformBlockIndex(glProgram.program,name);glProgram.uniformBufferBindings[name]=this.shader.uniformBindCount,gl.uniformBlockBinding(glProgram.program,uniformBlockIndex,this.shader.uniformBindCount),this.shader.uniformBindCount++;const id=this.getSignature(group,this.shader.program.uniformData,"ubo");let uboData=this._uboCache[id];if(uboData||(uboData=this._uboCache[id]=generateUniformBufferSync(group,this.shader.program.uniformData)),group.autoManage){const data=new Float32Array(uboData.size/4);group.buffer.update(data)}return glProgram.uniformGroups[group.id]=uboData.syncFunc,glProgram.uniformGroups[group.id]}getSignature(group,uniformData,preFix){const uniforms=group.uniforms,strings=[`${preFix}-`];for(const i in uniforms)strings.push(i),uniformData[i]&&strings.push(uniformData[i].type);return strings.join("-")}getGlProgram(){return this.shader?this.shader.program.glPrograms[this.renderer.CONTEXT_UID]:null}generateProgram(shader){const gl=this.gl,program=shader.program,glProgram=generateProgram(gl,program);return program.glPrograms[this.renderer.CONTEXT_UID]=glProgram,glProgram}reset(){this.program=null,this.shader=null}disposeShader(shader){this.shader===shader&&(this.shader=null)}destroy(){this.renderer=null,this.destroyed=!0}}ShaderSystem.extension={type:ExtensionType.RendererSystem,name:"shader"},extensions.add(ShaderSystem);class StartupSystem{constructor(renderer){this.renderer=renderer}run(options){const{renderer}=this;renderer.runners.init.emit(renderer.options),options.hello&&console.log(`PixiJS 7.3.1 - ${renderer.rendererLogId} - https://pixijs.com`),renderer.resize(renderer.screen.width,renderer.screen.height)}destroy(){}}StartupSystem.defaultOptions={hello:!1},StartupSystem.extension={type:[ExtensionType.RendererSystem,ExtensionType.CanvasRendererSystem],name:"startup"},extensions.add(StartupSystem);const _StateSystem=class _StateSystem2{constructor(){this.gl=null,this.stateId=0,this.polygonOffset=0,this.blendMode=BLEND_MODES.NONE,this._blendEq=!1,this.map=[],this.map[0]=this.setBlend,this.map[1]=this.setOffset,this.map[2]=this.setCullFace,this.map[3]=this.setDepthTest,this.map[4]=this.setFrontFace,this.map[5]=this.setDepthMask,this.checks=[],this.defaultState=new State,this.defaultState.blend=!0}contextChange(gl){this.gl=gl,this.blendModes=function mapWebGLBlendModesToPixi(gl,array=[]){return array[BLEND_MODES.NORMAL]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.ADD]=[gl.ONE,gl.ONE],array[BLEND_MODES.MULTIPLY]=[gl.DST_COLOR,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.SCREEN]=[gl.ONE,gl.ONE_MINUS_SRC_COLOR,gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.OVERLAY]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.DARKEN]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.LIGHTEN]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.COLOR_DODGE]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.COLOR_BURN]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.HARD_LIGHT]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.SOFT_LIGHT]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.DIFFERENCE]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.EXCLUSION]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.HUE]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.SATURATION]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.COLOR]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.LUMINOSITY]=[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.NONE]=[0,0],array[BLEND_MODES.NORMAL_NPM]=[gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.ADD_NPM]=[gl.SRC_ALPHA,gl.ONE,gl.ONE,gl.ONE],array[BLEND_MODES.SCREEN_NPM]=[gl.SRC_ALPHA,gl.ONE_MINUS_SRC_COLOR,gl.ONE,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.SRC_IN]=[gl.DST_ALPHA,gl.ZERO],array[BLEND_MODES.SRC_OUT]=[gl.ONE_MINUS_DST_ALPHA,gl.ZERO],array[BLEND_MODES.SRC_ATOP]=[gl.DST_ALPHA,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.DST_OVER]=[gl.ONE_MINUS_DST_ALPHA,gl.ONE],array[BLEND_MODES.DST_IN]=[gl.ZERO,gl.SRC_ALPHA],array[BLEND_MODES.DST_OUT]=[gl.ZERO,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.DST_ATOP]=[gl.ONE_MINUS_DST_ALPHA,gl.SRC_ALPHA],array[BLEND_MODES.XOR]=[gl.ONE_MINUS_DST_ALPHA,gl.ONE_MINUS_SRC_ALPHA],array[BLEND_MODES.SUBTRACT]=[gl.ONE,gl.ONE,gl.ONE,gl.ONE,gl.FUNC_REVERSE_SUBTRACT,gl.FUNC_ADD],array}(gl),this.set(this.defaultState),this.reset()}set(state){if(state=state||this.defaultState,this.stateId!==state.data){let diff=this.stateId^state.data,i=0;for(;diff;)1&diff&&this.map[i].call(this,!!(state.data&1<<i)),diff>>=1,i++;this.stateId=state.data}for(let i=0;i<this.checks.length;i++)this.checks[i](this,state)}forceState(state){state=state||this.defaultState;for(let i=0;i<this.map.length;i++)this.map[i].call(this,!!(state.data&1<<i));for(let i=0;i<this.checks.length;i++)this.checks[i](this,state);this.stateId=state.data}setBlend(value){this.updateCheck(_StateSystem2.checkBlendMode,value),this.gl[value?"enable":"disable"](this.gl.BLEND)}setOffset(value){this.updateCheck(_StateSystem2.checkPolygonOffset,value),this.gl[value?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}setDepthTest(value){this.gl[value?"enable":"disable"](this.gl.DEPTH_TEST)}setDepthMask(value){this.gl.depthMask(value)}setCullFace(value){this.gl[value?"enable":"disable"](this.gl.CULL_FACE)}setFrontFace(value){this.gl.frontFace(this.gl[value?"CW":"CCW"])}setBlendMode(value){if(value===this.blendMode)return;this.blendMode=value;const mode=this.blendModes[value],gl=this.gl;2===mode.length?gl.blendFunc(mode[0],mode[1]):gl.blendFuncSeparate(mode[0],mode[1],mode[2],mode[3]),6===mode.length?(this._blendEq=!0,gl.blendEquationSeparate(mode[4],mode[5])):this._blendEq&&(this._blendEq=!1,gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD))}setPolygonOffset(value,scale){this.gl.polygonOffset(value,scale)}reset(){this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode=-1,this.setBlendMode(0)}updateCheck(func,value){const index=this.checks.indexOf(func);value&&-1===index?this.checks.push(func):!value&&-1!==index&&this.checks.splice(index,1)}static checkBlendMode(system,state){system.setBlendMode(state.blendMode)}static checkPolygonOffset(system,state){system.setPolygonOffset(1,state.polygonOffset)}destroy(){this.gl=null}};_StateSystem.extension={type:ExtensionType.RendererSystem,name:"state"};let StateSystem=_StateSystem;extensions.add(StateSystem);class SystemManager extends(eventemitter3_default()){constructor(){super(...arguments),this.runners={},this._systemsHash={}}setup(config){this.addRunners(...config.runners);const priority=(config.priority??[]).filter((key=>config.systems[key])),orderByPriority=[...priority,...Object.keys(config.systems).filter((key=>!priority.includes(key)))];for(const i of orderByPriority)this.addSystem(config.systems[i],i)}addRunners(...runnerIds){runnerIds.forEach((runnerId=>{this.runners[runnerId]=new Runner_Runner(runnerId)}))}addSystem(ClassRef,name){const system=new ClassRef(this);if(this[name])throw new Error(`Whoops! The name "${name}" is already in use`);this[name]=system,this._systemsHash[name]=system;for(const i in this.runners)this.runners[i].add(system);return this}emitWithCustomOptions(runner,options){const systemHashKeys=Object.keys(this._systemsHash);runner.items.forEach((system=>{const systemName=systemHashKeys.find((systemId=>this._systemsHash[systemId]===system));system[runner.name](options[systemName])}))}destroy(){Object.values(this.runners).forEach((runner=>{runner.destroy()})),this._systemsHash={}}}const _TextureGCSystem=class _TextureGCSystem2{constructor(renderer){this.renderer=renderer,this.count=0,this.checkCount=0,this.maxIdle=_TextureGCSystem2.defaultMaxIdle,this.checkCountMax=_TextureGCSystem2.defaultCheckCountMax,this.mode=_TextureGCSystem2.defaultMode}postrender(){this.renderer.objectRenderer.renderingToScreen&&(this.count++,this.mode!==GC_MODES.MANUAL&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const tm=this.renderer.texture,managedTextures=tm.managedTextures;let wasRemoved=!1;for(let i=0;i<managedTextures.length;i++){const texture=managedTextures[i];texture.resource&&this.count-texture.touched>this.maxIdle&&(tm.destroyTexture(texture,!0),managedTextures[i]=null,wasRemoved=!0)}if(wasRemoved){let j=0;for(let i=0;i<managedTextures.length;i++)null!==managedTextures[i]&&(managedTextures[j++]=managedTextures[i]);managedTextures.length=j}}unload(displayObject){const tm=this.renderer.texture,texture=displayObject._texture;texture&&!texture.framebuffer&&tm.destroyTexture(texture);for(let i=displayObject.children.length-1;i>=0;i--)this.unload(displayObject.children[i])}destroy(){this.renderer=null}};_TextureGCSystem.defaultMode=GC_MODES.AUTO,_TextureGCSystem.defaultMaxIdle=3600,_TextureGCSystem.defaultCheckCountMax=600,_TextureGCSystem.extension={type:ExtensionType.RendererSystem,name:"textureGC"};let TextureGCSystem=_TextureGCSystem;extensions.add(TextureGCSystem);class GLTexture{constructor(texture){this.texture=texture,this.width=-1,this.height=-1,this.dirtyId=-1,this.dirtyStyleId=-1,this.mipmap=!1,this.wrapMode=33071,this.type=TYPES.UNSIGNED_BYTE,this.internalFormat=FORMATS.RGBA,this.samplerType=0}}class TextureSystem{constructor(renderer){this.renderer=renderer,this.boundTextures=[],this.currentLocation=-1,this.managedTextures=[],this._unknownBoundTextures=!1,this.unknownTexture=new BaseTexture,this.hasIntegerTextures=!1}contextChange(){const gl=this.gl=this.renderer.gl;this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.webGLVersion=this.renderer.context.webGLVersion,this.internalFormats=function mapTypeAndFormatToInternalFormat(gl){let table;return table="WebGL2RenderingContext"in globalThis&&gl instanceof globalThis.WebGL2RenderingContext?{[TYPES.UNSIGNED_BYTE]:{[FORMATS.RGBA]:gl.RGBA8,[FORMATS.RGB]:gl.RGB8,[FORMATS.RG]:gl.RG8,[FORMATS.RED]:gl.R8,[FORMATS.RGBA_INTEGER]:gl.RGBA8UI,[FORMATS.RGB_INTEGER]:gl.RGB8UI,[FORMATS.RG_INTEGER]:gl.RG8UI,[FORMATS.RED_INTEGER]:gl.R8UI,[FORMATS.ALPHA]:gl.ALPHA,[FORMATS.LUMINANCE]:gl.LUMINANCE,[FORMATS.LUMINANCE_ALPHA]:gl.LUMINANCE_ALPHA},[TYPES.BYTE]:{[FORMATS.RGBA]:gl.RGBA8_SNORM,[FORMATS.RGB]:gl.RGB8_SNORM,[FORMATS.RG]:gl.RG8_SNORM,[FORMATS.RED]:gl.R8_SNORM,[FORMATS.RGBA_INTEGER]:gl.RGBA8I,[FORMATS.RGB_INTEGER]:gl.RGB8I,[FORMATS.RG_INTEGER]:gl.RG8I,[FORMATS.RED_INTEGER]:gl.R8I},[TYPES.UNSIGNED_SHORT]:{[FORMATS.RGBA_INTEGER]:gl.RGBA16UI,[FORMATS.RGB_INTEGER]:gl.RGB16UI,[FORMATS.RG_INTEGER]:gl.RG16UI,[FORMATS.RED_INTEGER]:gl.R16UI,[FORMATS.DEPTH_COMPONENT]:gl.DEPTH_COMPONENT16},[TYPES.SHORT]:{[FORMATS.RGBA_INTEGER]:gl.RGBA16I,[FORMATS.RGB_INTEGER]:gl.RGB16I,[FORMATS.RG_INTEGER]:gl.RG16I,[FORMATS.RED_INTEGER]:gl.R16I},[TYPES.UNSIGNED_INT]:{[FORMATS.RGBA_INTEGER]:gl.RGBA32UI,[FORMATS.RGB_INTEGER]:gl.RGB32UI,[FORMATS.RG_INTEGER]:gl.RG32UI,[FORMATS.RED_INTEGER]:gl.R32UI,[FORMATS.DEPTH_COMPONENT]:gl.DEPTH_COMPONENT24},[TYPES.INT]:{[FORMATS.RGBA_INTEGER]:gl.RGBA32I,[FORMATS.RGB_INTEGER]:gl.RGB32I,[FORMATS.RG_INTEGER]:gl.RG32I,[FORMATS.RED_INTEGER]:gl.R32I},[TYPES.FLOAT]:{[FORMATS.RGBA]:gl.RGBA32F,[FORMATS.RGB]:gl.RGB32F,[FORMATS.RG]:gl.RG32F,[FORMATS.RED]:gl.R32F,[FORMATS.DEPTH_COMPONENT]:gl.DEPTH_COMPONENT32F},[TYPES.HALF_FLOAT]:{[FORMATS.RGBA]:gl.RGBA16F,[FORMATS.RGB]:gl.RGB16F,[FORMATS.RG]:gl.RG16F,[FORMATS.RED]:gl.R16F},[TYPES.UNSIGNED_SHORT_5_6_5]:{[FORMATS.RGB]:gl.RGB565},[TYPES.UNSIGNED_SHORT_4_4_4_4]:{[FORMATS.RGBA]:gl.RGBA4},[TYPES.UNSIGNED_SHORT_5_5_5_1]:{[FORMATS.RGBA]:gl.RGB5_A1},[TYPES.UNSIGNED_INT_2_10_10_10_REV]:{[FORMATS.RGBA]:gl.RGB10_A2,[FORMATS.RGBA_INTEGER]:gl.RGB10_A2UI},[TYPES.UNSIGNED_INT_10F_11F_11F_REV]:{[FORMATS.RGB]:gl.R11F_G11F_B10F},[TYPES.UNSIGNED_INT_5_9_9_9_REV]:{[FORMATS.RGB]:gl.RGB9_E5},[TYPES.UNSIGNED_INT_24_8]:{[FORMATS.DEPTH_STENCIL]:gl.DEPTH24_STENCIL8},[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]:{[FORMATS.DEPTH_STENCIL]:gl.DEPTH32F_STENCIL8}}:{[TYPES.UNSIGNED_BYTE]:{[FORMATS.RGBA]:gl.RGBA,[FORMATS.RGB]:gl.RGB,[FORMATS.ALPHA]:gl.ALPHA,[FORMATS.LUMINANCE]:gl.LUMINANCE,[FORMATS.LUMINANCE_ALPHA]:gl.LUMINANCE_ALPHA},[TYPES.UNSIGNED_SHORT_5_6_5]:{[FORMATS.RGB]:gl.RGB},[TYPES.UNSIGNED_SHORT_4_4_4_4]:{[FORMATS.RGBA]:gl.RGBA},[TYPES.UNSIGNED_SHORT_5_5_5_1]:{[FORMATS.RGBA]:gl.RGBA}},table}(gl),this.samplerTypes=function mapInternalFormatToSamplerType(gl){let table;return table="WebGL2RenderingContext"in globalThis&&gl instanceof globalThis.WebGL2RenderingContext?{[gl.RGB]:SAMPLER_TYPES.FLOAT,[gl.RGBA]:SAMPLER_TYPES.FLOAT,[gl.ALPHA]:SAMPLER_TYPES.FLOAT,[gl.LUMINANCE]:SAMPLER_TYPES.FLOAT,[gl.LUMINANCE_ALPHA]:SAMPLER_TYPES.FLOAT,[gl.R8]:SAMPLER_TYPES.FLOAT,[gl.R8_SNORM]:SAMPLER_TYPES.FLOAT,[gl.RG8]:SAMPLER_TYPES.FLOAT,[gl.RG8_SNORM]:SAMPLER_TYPES.FLOAT,[gl.RGB8]:SAMPLER_TYPES.FLOAT,[gl.RGB8_SNORM]:SAMPLER_TYPES.FLOAT,[gl.RGB565]:SAMPLER_TYPES.FLOAT,[gl.RGBA4]:SAMPLER_TYPES.FLOAT,[gl.RGB5_A1]:SAMPLER_TYPES.FLOAT,[gl.RGBA8]:SAMPLER_TYPES.FLOAT,[gl.RGBA8_SNORM]:SAMPLER_TYPES.FLOAT,[gl.RGB10_A2]:SAMPLER_TYPES.FLOAT,[gl.RGB10_A2UI]:SAMPLER_TYPES.FLOAT,[gl.SRGB8]:SAMPLER_TYPES.FLOAT,[gl.SRGB8_ALPHA8]:SAMPLER_TYPES.FLOAT,[gl.R16F]:SAMPLER_TYPES.FLOAT,[gl.RG16F]:SAMPLER_TYPES.FLOAT,[gl.RGB16F]:SAMPLER_TYPES.FLOAT,[gl.RGBA16F]:SAMPLER_TYPES.FLOAT,[gl.R32F]:SAMPLER_TYPES.FLOAT,[gl.RG32F]:SAMPLER_TYPES.FLOAT,[gl.RGB32F]:SAMPLER_TYPES.FLOAT,[gl.RGBA32F]:SAMPLER_TYPES.FLOAT,[gl.R11F_G11F_B10F]:SAMPLER_TYPES.FLOAT,[gl.RGB9_E5]:SAMPLER_TYPES.FLOAT,[gl.R8I]:SAMPLER_TYPES.INT,[gl.R8UI]:SAMPLER_TYPES.UINT,[gl.R16I]:SAMPLER_TYPES.INT,[gl.R16UI]:SAMPLER_TYPES.UINT,[gl.R32I]:SAMPLER_TYPES.INT,[gl.R32UI]:SAMPLER_TYPES.UINT,[gl.RG8I]:SAMPLER_TYPES.INT,[gl.RG8UI]:SAMPLER_TYPES.UINT,[gl.RG16I]:SAMPLER_TYPES.INT,[gl.RG16UI]:SAMPLER_TYPES.UINT,[gl.RG32I]:SAMPLER_TYPES.INT,[gl.RG32UI]:SAMPLER_TYPES.UINT,[gl.RGB8I]:SAMPLER_TYPES.INT,[gl.RGB8UI]:SAMPLER_TYPES.UINT,[gl.RGB16I]:SAMPLER_TYPES.INT,[gl.RGB16UI]:SAMPLER_TYPES.UINT,[gl.RGB32I]:SAMPLER_TYPES.INT,[gl.RGB32UI]:SAMPLER_TYPES.UINT,[gl.RGBA8I]:SAMPLER_TYPES.INT,[gl.RGBA8UI]:SAMPLER_TYPES.UINT,[gl.RGBA16I]:SAMPLER_TYPES.INT,[gl.RGBA16UI]:SAMPLER_TYPES.UINT,[gl.RGBA32I]:SAMPLER_TYPES.INT,[gl.RGBA32UI]:SAMPLER_TYPES.UINT,[gl.DEPTH_COMPONENT16]:SAMPLER_TYPES.FLOAT,[gl.DEPTH_COMPONENT24]:SAMPLER_TYPES.FLOAT,[gl.DEPTH_COMPONENT32F]:SAMPLER_TYPES.FLOAT,[gl.DEPTH_STENCIL]:SAMPLER_TYPES.FLOAT,[gl.DEPTH24_STENCIL8]:SAMPLER_TYPES.FLOAT,[gl.DEPTH32F_STENCIL8]:SAMPLER_TYPES.FLOAT}:{[gl.RGB]:SAMPLER_TYPES.FLOAT,[gl.RGBA]:SAMPLER_TYPES.FLOAT,[gl.ALPHA]:SAMPLER_TYPES.FLOAT,[gl.LUMINANCE]:SAMPLER_TYPES.FLOAT,[gl.LUMINANCE_ALPHA]:SAMPLER_TYPES.FLOAT,[gl.DEPTH_STENCIL]:SAMPLER_TYPES.FLOAT},table}(gl);const maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);this.boundTextures.length=maxTextures;for(let i=0;i<maxTextures;i++)this.boundTextures[i]=null;this.emptyTextures={};const emptyTexture2D=new GLTexture(gl.createTexture());gl.bindTexture(gl.TEXTURE_2D,emptyTexture2D.texture),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array(4)),this.emptyTextures[gl.TEXTURE_2D]=emptyTexture2D,this.emptyTextures[gl.TEXTURE_CUBE_MAP]=new GLTexture(gl.createTexture()),gl.bindTexture(gl.TEXTURE_CUBE_MAP,this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);for(let i=0;i<6;i++)gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MAG_FILTER,gl.LINEAR),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MIN_FILTER,gl.LINEAR);for(let i=0;i<this.boundTextures.length;i++)this.bind(null,i)}bind(texture,location=0){const{gl}=this;if(texture=texture?.castToBaseTexture(),texture?.valid&&!texture.parentTextureArray){texture.touched=this.renderer.textureGC.count;const glTexture=texture._glTextures[this.CONTEXT_UID]||this.initTexture(texture);this.boundTextures[location]!==texture&&(this.currentLocation!==location&&(this.currentLocation=location,gl.activeTexture(gl.TEXTURE0+location)),gl.bindTexture(texture.target,glTexture.texture)),glTexture.dirtyId!==texture.dirtyId?(this.currentLocation!==location&&(this.currentLocation=location,gl.activeTexture(gl.TEXTURE0+location)),this.updateTexture(texture)):glTexture.dirtyStyleId!==texture.dirtyStyleId&&this.updateTextureStyle(texture),this.boundTextures[location]=texture}else this.currentLocation!==location&&(this.currentLocation=location,gl.activeTexture(gl.TEXTURE0+location)),gl.bindTexture(gl.TEXTURE_2D,this.emptyTextures[gl.TEXTURE_2D].texture),this.boundTextures[location]=null}reset(){this._unknownBoundTextures=!0,this.hasIntegerTextures=!1,this.currentLocation=-1;for(let i=0;i<this.boundTextures.length;i++)this.boundTextures[i]=this.unknownTexture}unbind(texture){const{gl,boundTextures}=this;if(this._unknownBoundTextures){this._unknownBoundTextures=!1;for(let i=0;i<boundTextures.length;i++)boundTextures[i]===this.unknownTexture&&this.bind(null,i)}for(let i=0;i<boundTextures.length;i++)boundTextures[i]===texture&&(this.currentLocation!==i&&(gl.activeTexture(gl.TEXTURE0+i),this.currentLocation=i),gl.bindTexture(texture.target,this.emptyTextures[texture.target].texture),boundTextures[i]=null)}ensureSamplerType(maxTextures){const{boundTextures,hasIntegerTextures,CONTEXT_UID}=this;if(hasIntegerTextures)for(let i=maxTextures-1;i>=0;--i){const tex=boundTextures[i];tex&&tex._glTextures[CONTEXT_UID].samplerType!==SAMPLER_TYPES.FLOAT&&this.renderer.texture.unbind(tex)}}initTexture(texture){const glTexture=new GLTexture(this.gl.createTexture());return glTexture.dirtyId=-1,texture._glTextures[this.CONTEXT_UID]=glTexture,this.managedTextures.push(texture),texture.on("dispose",this.destroyTexture,this),glTexture}initTextureType(texture,glTexture){glTexture.internalFormat=this.internalFormats[texture.type]?.[texture.format]??texture.format,glTexture.samplerType=this.samplerTypes[glTexture.internalFormat]??SAMPLER_TYPES.FLOAT,2===this.webGLVersion&&texture.type===TYPES.HALF_FLOAT?glTexture.type=this.gl.HALF_FLOAT:glTexture.type=texture.type}updateTexture(texture){const glTexture=texture._glTextures[this.CONTEXT_UID];if(!glTexture)return;const renderer=this.renderer;if(this.initTextureType(texture,glTexture),texture.resource?.upload(renderer,texture,glTexture))glTexture.samplerType!==SAMPLER_TYPES.FLOAT&&(this.hasIntegerTextures=!0);else{const width=texture.realWidth,height=texture.realHeight,gl=renderer.gl;(glTexture.width!==width||glTexture.height!==height||glTexture.dirtyId<0)&&(glTexture.width=width,glTexture.height=height,gl.texImage2D(texture.target,0,glTexture.internalFormat,width,height,0,texture.format,glTexture.type,null))}texture.dirtyStyleId!==glTexture.dirtyStyleId&&this.updateTextureStyle(texture),glTexture.dirtyId=texture.dirtyId}destroyTexture(texture,skipRemove){const{gl}=this;if((texture=texture.castToBaseTexture())._glTextures[this.CONTEXT_UID]&&(this.unbind(texture),gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture),texture.off("dispose",this.destroyTexture,this),delete texture._glTextures[this.CONTEXT_UID],!skipRemove)){const i=this.managedTextures.indexOf(texture);-1!==i&&removeItems(this.managedTextures,i,1)}}updateTextureStyle(texture){const glTexture=texture._glTextures[this.CONTEXT_UID];glTexture&&(texture.mipmap!==MIPMAP_MODES.POW2&&2===this.webGLVersion||texture.isPowerOfTwo?glTexture.mipmap=texture.mipmap>=1:glTexture.mipmap=!1,2===this.webGLVersion||texture.isPowerOfTwo?glTexture.wrapMode=texture.wrapMode:glTexture.wrapMode=WRAP_MODES.CLAMP,texture.resource?.style(this.renderer,texture,glTexture)||this.setStyle(texture,glTexture),glTexture.dirtyStyleId=texture.dirtyStyleId)}setStyle(texture,glTexture){const gl=this.gl;if(glTexture.mipmap&&texture.mipmap!==MIPMAP_MODES.ON_MANUAL&&gl.generateMipmap(texture.target),gl.texParameteri(texture.target,gl.TEXTURE_WRAP_S,glTexture.wrapMode),gl.texParameteri(texture.target,gl.TEXTURE_WRAP_T,glTexture.wrapMode),glTexture.mipmap){gl.texParameteri(texture.target,gl.TEXTURE_MIN_FILTER,texture.scaleMode===SCALE_MODES.LINEAR?gl.LINEAR_MIPMAP_LINEAR:gl.NEAREST_MIPMAP_NEAREST);const anisotropicExt=this.renderer.context.extensions.anisotropicFiltering;if(anisotropicExt&&texture.anisotropicLevel>0&&texture.scaleMode===SCALE_MODES.LINEAR){const level=Math.min(texture.anisotropicLevel,gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));gl.texParameterf(texture.target,anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT,level)}}else gl.texParameteri(texture.target,gl.TEXTURE_MIN_FILTER,texture.scaleMode===SCALE_MODES.LINEAR?gl.LINEAR:gl.NEAREST);gl.texParameteri(texture.target,gl.TEXTURE_MAG_FILTER,texture.scaleMode===SCALE_MODES.LINEAR?gl.LINEAR:gl.NEAREST)}destroy(){this.renderer=null}}TextureSystem.extension={type:ExtensionType.RendererSystem,name:"texture"},extensions.add(TextureSystem);class TransformFeedbackSystem{constructor(renderer){this.renderer=renderer}contextChange(){this.gl=this.renderer.gl,this.CONTEXT_UID=this.renderer.CONTEXT_UID}bind(transformFeedback){const{gl,CONTEXT_UID}=this,glTransformFeedback=transformFeedback._glTransformFeedbacks[CONTEXT_UID]||this.createGLTransformFeedback(transformFeedback);gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,glTransformFeedback)}unbind(){const{gl}=this;gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,null)}beginTransformFeedback(drawMode,shader){const{gl,renderer}=this;shader&&renderer.shader.bind(shader),gl.beginTransformFeedback(drawMode)}endTransformFeedback(){const{gl}=this;gl.endTransformFeedback()}createGLTransformFeedback(tf){const{gl,renderer,CONTEXT_UID}=this,glTransformFeedback=gl.createTransformFeedback();tf._glTransformFeedbacks[CONTEXT_UID]=glTransformFeedback,gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,glTransformFeedback);for(let i=0;i<tf.buffers.length;i++){const buffer=tf.buffers[i];buffer&&(renderer.buffer.update(buffer),buffer._glBuffers[CONTEXT_UID].refCount++,gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER,i,buffer._glBuffers[CONTEXT_UID].buffer||null))}return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,null),tf.disposeRunner.add(this),glTransformFeedback}disposeTransformFeedback(tf,contextLost){const glTF=tf._glTransformFeedbacks[this.CONTEXT_UID],gl=this.gl;tf.disposeRunner.remove(this);const bufferSystem=this.renderer.buffer;if(bufferSystem)for(let i=0;i<tf.buffers.length;i++){const buffer=tf.buffers[i];if(!buffer)continue;const buf=buffer._glBuffers[this.CONTEXT_UID];buf&&(buf.refCount--,0===buf.refCount&&!contextLost&&bufferSystem.dispose(buffer,contextLost))}glTF&&(contextLost||gl.deleteTransformFeedback(glTF),delete tf._glTransformFeedbacks[this.CONTEXT_UID])}destroy(){this.renderer=null}}TransformFeedbackSystem.extension={type:ExtensionType.RendererSystem,name:"transformFeedback"},extensions.add(TransformFeedbackSystem);class ViewSystem{constructor(renderer){this.renderer=renderer}init(options){this.screen=new Rectangle(0,0,options.width,options.height),this.element=options.view||settings.ADAPTER.createCanvas(),this.resolution=options.resolution||settings.RESOLUTION,this.autoDensity=!!options.autoDensity}resizeView(desiredScreenWidth,desiredScreenHeight){this.element.width=Math.round(desiredScreenWidth*this.resolution),this.element.height=Math.round(desiredScreenHeight*this.resolution);const screenWidth=this.element.width/this.resolution,screenHeight=this.element.height/this.resolution;this.screen.width=screenWidth,this.screen.height=screenHeight,this.autoDensity&&(this.element.style.width=`${screenWidth}px`,this.element.style.height=`${screenHeight}px`),this.renderer.emit("resize",screenWidth,screenHeight),this.renderer.runners.resize.emit(this.screen.width,this.screen.height)}destroy(removeView){removeView&&this.element.parentNode?.removeChild(this.element),this.renderer=null,this.element=null,this.screen=null}}ViewSystem.defaultOptions={width:800,height:600,resolution:void 0,autoDensity:!1},ViewSystem.extension={type:[ExtensionType.RendererSystem,ExtensionType.CanvasRendererSystem],name:"_view"},extensions.add(ViewSystem),settings.PREFER_ENV=ENV.WEBGL2,settings.STRICT_TEXTURE_CACHE=!1,settings.RENDER_OPTIONS={...ContextSystem.defaultOptions,...BackgroundSystem.defaultOptions,...ViewSystem.defaultOptions,...StartupSystem.defaultOptions},Object.defineProperties(settings,{WRAP_MODE:{get:()=>BaseTexture.defaultOptions.wrapMode,set(value){deprecation("7.1.0","settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"),BaseTexture.defaultOptions.wrapMode=value}},SCALE_MODE:{get:()=>BaseTexture.defaultOptions.scaleMode,set(value){deprecation("7.1.0","settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"),BaseTexture.defaultOptions.scaleMode=value}},MIPMAP_TEXTURES:{get:()=>BaseTexture.defaultOptions.mipmap,set(value){deprecation("7.1.0","settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"),BaseTexture.defaultOptions.mipmap=value}},ANISOTROPIC_LEVEL:{get:()=>BaseTexture.defaultOptions.anisotropicLevel,set(value){deprecation("7.1.0","settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"),BaseTexture.defaultOptions.anisotropicLevel=value}},FILTER_RESOLUTION:{get:()=>(deprecation("7.1.0","settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"),Filter.defaultResolution),set(value){Filter.defaultResolution=value}},FILTER_MULTISAMPLE:{get:()=>(deprecation("7.1.0","settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"),Filter.defaultMultisample),set(value){Filter.defaultMultisample=value}},SPRITE_MAX_TEXTURES:{get:()=>BatchRenderer.defaultMaxTextures,set(value){deprecation("7.1.0","settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"),BatchRenderer.defaultMaxTextures=value}},SPRITE_BATCH_SIZE:{get:()=>BatchRenderer.defaultBatchSize,set(value){deprecation("7.1.0","settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"),BatchRenderer.defaultBatchSize=value}},CAN_UPLOAD_SAME_BUFFER:{get:()=>BatchRenderer.canUploadSameBuffer,set(value){deprecation("7.1.0","settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"),BatchRenderer.canUploadSameBuffer=value}},GC_MODE:{get:()=>TextureGCSystem.defaultMode,set(value){deprecation("7.1.0","settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"),TextureGCSystem.defaultMode=value}},GC_MAX_IDLE:{get:()=>TextureGCSystem.defaultMaxIdle,set(value){deprecation("7.1.0","settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"),TextureGCSystem.defaultMaxIdle=value}},GC_MAX_CHECK_COUNT:{get:()=>TextureGCSystem.defaultCheckCountMax,set(value){deprecation("7.1.0","settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"),TextureGCSystem.defaultCheckCountMax=value}},PRECISION_VERTEX:{get:()=>Program.defaultVertexPrecision,set(value){deprecation("7.1.0","settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"),Program.defaultVertexPrecision=value}},PRECISION_FRAGMENT:{get:()=>Program.defaultFragmentPrecision,set(value){deprecation("7.1.0","settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"),Program.defaultFragmentPrecision=value}}});var UPDATE_PRIORITY=(UPDATE_PRIORITY2=>(UPDATE_PRIORITY2[UPDATE_PRIORITY2.INTERACTION=50]="INTERACTION",UPDATE_PRIORITY2[UPDATE_PRIORITY2.HIGH=25]="HIGH",UPDATE_PRIORITY2[UPDATE_PRIORITY2.NORMAL=0]="NORMAL",UPDATE_PRIORITY2[UPDATE_PRIORITY2.LOW=-25]="LOW",UPDATE_PRIORITY2[UPDATE_PRIORITY2.UTILITY=-50]="UTILITY",UPDATE_PRIORITY2))(UPDATE_PRIORITY||{});class TickerListener{constructor(fn,context=null,priority=0,once=!1){this.next=null,this.previous=null,this._destroyed=!1,this.fn=fn,this.context=context,this.priority=priority,this.once=once}match(fn,context=null){return this.fn===fn&&this.context===context}emit(deltaTime){this.fn&&(this.context?this.fn.call(this.context,deltaTime):this.fn(deltaTime));const redirect=this.next;return this.once&&this.destroy(!0),this._destroyed&&(this.next=null),redirect}connect(previous){this.previous=previous,previous.next&&(previous.next.previous=this),this.next=previous.next,previous.next=this}destroy(hard=!1){this._destroyed=!0,this.fn=null,this.context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);const redirect=this.next;return this.next=hard?null:redirect,this.previous=null,redirect}}const _Ticker=class _Ticker2{constructor(){this.autoStart=!1,this.deltaTime=1,this.lastTime=-1,this.speed=1,this.started=!1,this._requestId=null,this._maxElapsedMS=100,this._minElapsedMS=0,this._protected=!1,this._lastFrame=-1,this._head=new TickerListener(null,null,1/0),this.deltaMS=1/_Ticker2.targetFPMS,this.elapsedMS=1/_Ticker2.targetFPMS,this._tick=time=>{this._requestId=null,this.started&&(this.update(time),this.started&&null===this._requestId&&this._head.next&&(this._requestId=requestAnimationFrame(this._tick)))}}_requestIfNeeded(){null===this._requestId&&this._head.next&&(this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))}_cancelIfNeeded(){null!==this._requestId&&(cancelAnimationFrame(this._requestId),this._requestId=null)}_startIfPossible(){this.started?this._requestIfNeeded():this.autoStart&&this.start()}add(fn,context,priority=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(fn,context,priority))}addOnce(fn,context,priority=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(fn,context,priority,!0))}_addListener(listener){let current=this._head.next,previous=this._head;if(current){for(;current;){if(listener.priority>current.priority){listener.connect(previous);break}previous=current,current=current.next}listener.previous||listener.connect(previous)}else listener.connect(previous);return this._startIfPossible(),this}remove(fn,context){let listener=this._head.next;for(;listener;)listener=listener.match(fn,context)?listener.destroy():listener.next;return this._head.next||this._cancelIfNeeded(),this}get count(){if(!this._head)return 0;let count=0,current=this._head;for(;current=current.next;)count++;return count}start(){this.started||(this.started=!0,this._requestIfNeeded())}stop(){this.started&&(this.started=!1,this._cancelIfNeeded())}destroy(){if(!this._protected){this.stop();let listener=this._head.next;for(;listener;)listener=listener.destroy(!0);this._head.destroy(),this._head=null}}update(currentTime=performance.now()){let elapsedMS;if(currentTime>this.lastTime){if(elapsedMS=this.elapsedMS=currentTime-this.lastTime,elapsedMS>this._maxElapsedMS&&(elapsedMS=this._maxElapsedMS),elapsedMS*=this.speed,this._minElapsedMS){const delta=currentTime-this._lastFrame|0;if(delta<this._minElapsedMS)return;this._lastFrame=currentTime-delta%this._minElapsedMS}this.deltaMS=elapsedMS,this.deltaTime=this.deltaMS*_Ticker2.targetFPMS;const head=this._head;let listener=head.next;for(;listener;)listener=listener.emit(this.deltaTime);head.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=currentTime}get FPS(){return 1e3/this.elapsedMS}get minFPS(){return 1e3/this._maxElapsedMS}set minFPS(fps){const minFPS=Math.min(this.maxFPS,fps),minFPMS=Math.min(Math.max(0,minFPS)/1e3,_Ticker2.targetFPMS);this._maxElapsedMS=1/minFPMS}get maxFPS(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0}set maxFPS(fps){if(0===fps)this._minElapsedMS=0;else{const maxFPS=Math.max(this.minFPS,fps);this._minElapsedMS=1/(maxFPS/1e3)}}static get shared(){if(!_Ticker2._shared){const shared=_Ticker2._shared=new _Ticker2;shared.autoStart=!0,shared._protected=!0}return _Ticker2._shared}static get system(){if(!_Ticker2._system){const system=_Ticker2._system=new _Ticker2;system.autoStart=!0,system._protected=!0}return _Ticker2._system}};_Ticker.targetFPMS=.06;let Ticker=_Ticker;Object.defineProperties(settings,{TARGET_FPMS:{get:()=>Ticker.targetFPMS,set(value){deprecation("7.1.0","settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),Ticker.targetFPMS=value}}});var lib_ExtensionType=(ExtensionType2=>(ExtensionType2.Renderer="renderer",ExtensionType2.Application="application",ExtensionType2.RendererSystem="renderer-webgl-system",ExtensionType2.RendererPlugin="renderer-webgl-plugin",ExtensionType2.CanvasRendererSystem="renderer-canvas-system",ExtensionType2.CanvasRendererPlugin="renderer-canvas-plugin",ExtensionType2.Asset="asset",ExtensionType2.LoadParser="load-parser",ExtensionType2.ResolveParser="resolve-parser",ExtensionType2.CacheParser="cache-parser",ExtensionType2.DetectionParser="detection-parser",ExtensionType2))(lib_ExtensionType||{});const lib_normalizeExtension=ext=>{if("function"==typeof ext||"object"==typeof ext&&ext.extension){if(!ext.extension)throw new Error("Extension class must have an extension object");ext={..."object"!=typeof ext.extension?{type:ext.extension}:ext.extension,ref:ext}}if("object"!=typeof ext)throw new Error("Invalid extension type");return"string"==typeof(ext={...ext}).type&&(ext.type=[ext.type]),ext},lib_normalizePriority=(ext,defaultPriority)=>lib_normalizeExtension(ext).priority??defaultPriority,lib_extensions={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...extensions2){return extensions2.map(lib_normalizeExtension).forEach((ext=>{ext.type.forEach((type=>this._removeHandlers[type]?.(ext)))})),this},add(...extensions2){return extensions2.map(lib_normalizeExtension).forEach((ext=>{ext.type.forEach((type=>{const handlers=this._addHandlers,queue=this._queue;handlers[type]?handlers[type](ext):(queue[type]=queue[type]||[],queue[type].push(ext))}))})),this},handle(type,onAdd,onRemove){const addHandlers=this._addHandlers,removeHandlers=this._removeHandlers;if(addHandlers[type]||removeHandlers[type])throw new Error(`Extension type ${type} already has a handler`);addHandlers[type]=onAdd,removeHandlers[type]=onRemove;const queue=this._queue;return queue[type]&&(queue[type].forEach((ext=>onAdd(ext))),delete queue[type]),this},handleByMap(type,map){return this.handle(type,(extension=>{map[extension.name]=extension.ref}),(extension=>{delete map[extension.name]}))},handleByList(type,list,defaultPriority=-1){return this.handle(type,(extension=>{list.includes(extension.ref)||(list.push(extension.ref),list.sort(((a,b)=>lib_normalizePriority(b,defaultPriority)-lib_normalizePriority(a,defaultPriority))))}),(extension=>{const index=list.indexOf(extension.ref);-1!==index&&list.splice(index,1)}))}};class TickerPlugin{static init(options){options=Object.assign({autoStart:!0,sharedTicker:!1},options),Object.defineProperty(this,"ticker",{set(ticker){this._ticker&&this._ticker.remove(this.render,this),this._ticker=ticker,ticker&&ticker.add(this.render,this,UPDATE_PRIORITY.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=options.sharedTicker?Ticker.shared:new Ticker,options.autoStart&&this.start()}static destroy(){if(this._ticker){const oldTicker=this._ticker;this.ticker=null,oldTicker.destroy()}}}TickerPlugin.extension=lib_ExtensionType.Application,lib_extensions.add(TickerPlugin);const renderers=[];extensions.handleByList(ExtensionType.Renderer,renderers);class MultisampleSystem{constructor(renderer){this.renderer=renderer}contextChange(gl){let samples;if(1===this.renderer.context.webGLVersion){const framebuffer=gl.getParameter(gl.FRAMEBUFFER_BINDING);gl.bindFramebuffer(gl.FRAMEBUFFER,null),samples=gl.getParameter(gl.SAMPLES),gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)}else{const framebuffer=gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null),samples=gl.getParameter(gl.SAMPLES),gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,framebuffer)}samples>=MSAA_QUALITY.HIGH?this.multisample=MSAA_QUALITY.HIGH:samples>=MSAA_QUALITY.MEDIUM?this.multisample=MSAA_QUALITY.MEDIUM:samples>=MSAA_QUALITY.LOW?this.multisample=MSAA_QUALITY.LOW:this.multisample=MSAA_QUALITY.NONE}destroy(){}}MultisampleSystem.extension={type:ExtensionType.RendererSystem,name:"_multisample"},extensions.add(MultisampleSystem);class GLBuffer{constructor(buffer){this.buffer=buffer||null,this.updateID=-1,this.byteLength=-1,this.refCount=0}}class BufferSystem{constructor(renderer){this.renderer=renderer,this.managedBuffers={},this.boundBufferBases={}}destroy(){this.renderer=null}contextChange(){this.disposeAll(!0),this.gl=this.renderer.gl,this.CONTEXT_UID=this.renderer.CONTEXT_UID}bind(buffer){const{gl,CONTEXT_UID}=this,glBuffer=buffer._glBuffers[CONTEXT_UID]||this.createGLBuffer(buffer);gl.bindBuffer(buffer.type,glBuffer.buffer)}unbind(type){const{gl}=this;gl.bindBuffer(type,null)}bindBufferBase(buffer,index){const{gl,CONTEXT_UID}=this;if(this.boundBufferBases[index]!==buffer){const glBuffer=buffer._glBuffers[CONTEXT_UID]||this.createGLBuffer(buffer);this.boundBufferBases[index]=buffer,gl.bindBufferBase(gl.UNIFORM_BUFFER,index,glBuffer.buffer)}}bindBufferRange(buffer,index,offset){const{gl,CONTEXT_UID}=this;offset=offset||0;const glBuffer=buffer._glBuffers[CONTEXT_UID]||this.createGLBuffer(buffer);gl.bindBufferRange(gl.UNIFORM_BUFFER,index||0,glBuffer.buffer,256*offset,256)}update(buffer){const{gl,CONTEXT_UID}=this,glBuffer=buffer._glBuffers[CONTEXT_UID]||this.createGLBuffer(buffer);if(buffer._updateID!==glBuffer.updateID)if(glBuffer.updateID=buffer._updateID,gl.bindBuffer(buffer.type,glBuffer.buffer),glBuffer.byteLength>=buffer.data.byteLength)gl.bufferSubData(buffer.type,0,buffer.data);else{const drawType=buffer.static?gl.STATIC_DRAW:gl.DYNAMIC_DRAW;glBuffer.byteLength=buffer.data.byteLength,gl.bufferData(buffer.type,buffer.data,drawType)}}dispose(buffer,contextLost){if(!this.managedBuffers[buffer.id])return;delete this.managedBuffers[buffer.id];const glBuffer=buffer._glBuffers[this.CONTEXT_UID],gl=this.gl;buffer.disposeRunner.remove(this),glBuffer&&(contextLost||gl.deleteBuffer(glBuffer.buffer),delete buffer._glBuffers[this.CONTEXT_UID])}disposeAll(contextLost){const all=Object.keys(this.managedBuffers);for(let i=0;i<all.length;i++)this.dispose(this.managedBuffers[all[i]],contextLost)}createGLBuffer(buffer){const{CONTEXT_UID,gl}=this;return buffer._glBuffers[CONTEXT_UID]=new GLBuffer(gl.createBuffer()),this.managedBuffers[buffer.id]=buffer,buffer.disposeRunner.add(this),buffer._glBuffers[CONTEXT_UID]}}BufferSystem.extension={type:ExtensionType.RendererSystem,name:"buffer"},extensions.add(BufferSystem);class ObjectRendererSystem{constructor(renderer){this.renderer=renderer}render(displayObject,options){const renderer=this.renderer;let renderTexture,clear,transform,skipUpdateTransform;if(options&&(renderTexture=options.renderTexture,clear=options.clear,transform=options.transform,skipUpdateTransform=options.skipUpdateTransform),this.renderingToScreen=!renderTexture,renderer.runners.prerender.emit(),renderer.emit("prerender"),renderer.projection.transform=transform,!renderer.context.isLost){if(renderTexture||(this.lastObjectRendered=displayObject),!skipUpdateTransform){const cacheParent=displayObject.enableTempParent();displayObject.updateTransform(),displayObject.disableTempParent(cacheParent)}renderer.renderTexture.bind(renderTexture),renderer.batch.currentRenderer.start(),(clear??renderer.background.clearBeforeRender)&&renderer.renderTexture.clear(),displayObject.render(renderer),renderer.batch.currentRenderer.flush(),renderTexture&&(options.blit&&renderer.framebuffer.blit(),renderTexture.baseTexture.update()),renderer.runners.postrender.emit(),renderer.projection.transform=null,renderer.emit("postrender")}}destroy(){this.renderer=null,this.lastObjectRendered=null}}ObjectRendererSystem.extension={type:ExtensionType.RendererSystem,name:"objectRenderer"},extensions.add(ObjectRendererSystem);const _Renderer=class _Renderer2 extends SystemManager{constructor(options){super(),this.type=RENDERER_TYPE.WEBGL,options=Object.assign({},settings.RENDER_OPTIONS,options),this.gl=null,this.CONTEXT_UID=0,this.globalUniforms=new UniformGroup({projectionMatrix:new Matrix},!0);const systemConfig={runners:["init","destroy","contextChange","resolutionChange","reset","update","postrender","prerender","resize"],systems:_Renderer2.__systems,priority:["_view","textureGenerator","background","_plugin","startup","context","state","texture","buffer","geometry","framebuffer","transformFeedback","mask","scissor","stencil","projection","textureGC","filter","renderTexture","batch","objectRenderer","_multisample"]};this.setup(systemConfig),"useContextAlpha"in options&&(deprecation("7.0.0","options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"),options.premultipliedAlpha=options.useContextAlpha&&"notMultiplied"!==options.useContextAlpha,options.backgroundAlpha=!1===options.useContextAlpha?1:options.backgroundAlpha),this._plugin.rendererPlugins=_Renderer2.__plugins,this.options=options,this.startup.run(this.options)}static test(options){return!options?.forceCanvas&&isWebGLSupported()}render(displayObject,options){this.objectRenderer.render(displayObject,options)}resize(desiredScreenWidth,desiredScreenHeight){this._view.resizeView(desiredScreenWidth,desiredScreenHeight)}reset(){return this.runners.reset.emit(),this}clear(){this.renderTexture.bind(),this.renderTexture.clear()}destroy(removeView=!1){this.runners.destroy.items.reverse(),this.emitWithCustomOptions(this.runners.destroy,{_view:removeView}),super.destroy()}get plugins(){return this._plugin.plugins}get multisample(){return this._multisample.multisample}get width(){return this._view.element.width}get height(){return this._view.element.height}get resolution(){return this._view.resolution}set resolution(value){this._view.resolution=value,this.runners.resolutionChange.emit(value)}get autoDensity(){return this._view.autoDensity}get view(){return this._view.element}get screen(){return this._view.screen}get lastObjectRendered(){return this.objectRenderer.lastObjectRendered}get renderingToScreen(){return this.objectRenderer.renderingToScreen}get rendererLogId(){return`WebGL ${this.context.webGLVersion}`}get clearBeforeRender(){return deprecation("7.0.0","renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."),this.background.clearBeforeRender}get useContextAlpha(){return deprecation("7.0.0","renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."),this.context.useContextAlpha}get preserveDrawingBuffer(){return deprecation("7.0.0","renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"),this.context.preserveDrawingBuffer}get backgroundColor(){return deprecation("7.0.0","renderer.backgroundColor has been deprecated, use renderer.background.color instead."),this.background.color}set backgroundColor(value){deprecation("7.0.0","renderer.backgroundColor has been deprecated, use renderer.background.color instead."),this.background.color=value}get backgroundAlpha(){return deprecation("7.0.0","renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),this.background.alpha}set backgroundAlpha(value){deprecation("7.0.0","renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),this.background.alpha=value}get powerPreference(){return deprecation("7.0.0","renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"),this.context.powerPreference}generateTexture(displayObject,options){return this.textureGenerator.generateTexture(displayObject,options)}};_Renderer.extension={type:ExtensionType.Renderer,priority:1},_Renderer.__plugins={},_Renderer.__systems={};let Renderer=_Renderer;extensions.handleByMap(ExtensionType.RendererPlugin,Renderer.__plugins),extensions.handleByMap(ExtensionType.RendererSystem,Renderer.__systems),extensions.add(Renderer);class AbstractMultiResource extends Resource{constructor(length,options){const{width,height}=options||{};super(width,height),this.items=[],this.itemDirtyIds=[];for(let i=0;i<length;i++){const partTexture=new BaseTexture;this.items.push(partTexture),this.itemDirtyIds.push(-2)}this.length=length,this._load=null,this.baseTexture=null}initFromArray(resources,options){for(let i=0;i<this.length;i++)resources[i]&&(resources[i].castToBaseTexture?this.addBaseTextureAt(resources[i].castToBaseTexture(),i):resources[i]instanceof Resource?this.addResourceAt(resources[i],i):this.addResourceAt(autoDetectResource(resources[i],options),i))}dispose(){for(let i=0,len=this.length;i<len;i++)this.items[i].destroy();this.items=null,this.itemDirtyIds=null,this._load=null}addResourceAt(resource,index){if(!this.items[index])throw new Error(`Index ${index} is out of bounds`);return resource.valid&&!this.valid&&this.resize(resource.width,resource.height),this.items[index].setResource(resource),this}bind(baseTexture){if(null!==this.baseTexture)throw new Error("Only one base texture per TextureArray is allowed");super.bind(baseTexture);for(let i=0;i<this.length;i++)this.items[i].parentTextureArray=baseTexture,this.items[i].on("update",baseTexture.update,baseTexture)}unbind(baseTexture){super.unbind(baseTexture);for(let i=0;i<this.length;i++)this.items[i].parentTextureArray=null,this.items[i].off("update",baseTexture.update,baseTexture)}load(){if(this._load)return this._load;const promises=this.items.map((item=>item.resource)).filter((item=>item)).map((item=>item.load()));return this._load=Promise.all(promises).then((()=>{const{realWidth,realHeight}=this.items[0];return this.resize(realWidth,realHeight),this.update(),Promise.resolve(this)})),this._load}}const _CubeResource=class _CubeResource2 extends AbstractMultiResource{constructor(source,options){const{width,height,autoLoad,linkBaseTexture}=options||{};if(source&&source.length!==_CubeResource2.SIDES)throw new Error(`Invalid length. Got ${source.length}, expected 6`);super(6,{width,height});for(let i=0;i<_CubeResource2.SIDES;i++)this.items[i].target=TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+i;this.linkBaseTexture=!1!==linkBaseTexture,source&&this.initFromArray(source,options),!1!==autoLoad&&this.load()}bind(baseTexture){super.bind(baseTexture),baseTexture.target=TARGETS.TEXTURE_CUBE_MAP}addBaseTextureAt(baseTexture,index,linkBaseTexture){if(void 0===linkBaseTexture&&(linkBaseTexture=this.linkBaseTexture),!this.items[index])throw new Error(`Index ${index} is out of bounds`);if(!this.linkBaseTexture||baseTexture.parentTextureArray||Object.keys(baseTexture._glTextures).length>0){if(!baseTexture.resource)throw new Error("CubeResource does not support copying of renderTexture.");this.addResourceAt(baseTexture.resource,index)}else baseTexture.target=TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+index,baseTexture.parentTextureArray=this.baseTexture,this.items[index]=baseTexture;return baseTexture.valid&&!this.valid&&this.resize(baseTexture.realWidth,baseTexture.realHeight),this.items[index]=baseTexture,this}upload(renderer,_baseTexture,glTexture){const dirty=this.itemDirtyIds;for(let i=0;i<_CubeResource2.SIDES;i++){const side=this.items[i];(dirty[i]<side.dirtyId||glTexture.dirtyId<_baseTexture.dirtyId)&&(side.valid&&side.resource?(side.resource.upload(renderer,side,glTexture),dirty[i]=side.dirtyId):dirty[i]<-1&&(renderer.gl.texImage2D(side.target,0,glTexture.internalFormat,_baseTexture.realWidth,_baseTexture.realHeight,0,_baseTexture.format,glTexture.type,null),dirty[i]=-1))}return!0}static test(source){return Array.isArray(source)&&source.length===_CubeResource2.SIDES}};_CubeResource.SIDES=6;let CubeResource=_CubeResource;class ImageBitmapResource extends BaseImageResource{constructor(source,options){let baseSource,url,ownsImageBitmap;options=options||{},"string"==typeof source?(baseSource=ImageBitmapResource.EMPTY,url=source,ownsImageBitmap=!0):(baseSource=source,url=null,ownsImageBitmap=!1),super(baseSource),this.url=url,this.crossOrigin=options.crossOrigin??!0,this.alphaMode="number"==typeof options.alphaMode?options.alphaMode:null,this.ownsImageBitmap=options.ownsImageBitmap??ownsImageBitmap,this._load=null,!1!==options.autoLoad&&this.load()}load(){return this._load||(this._load=new Promise((async(resolve,reject)=>{if(null!==this.url)try{const response=await settings.ADAPTER.fetch(this.url,{mode:this.crossOrigin?"cors":"no-cors"});if(this.destroyed)return;const imageBlob=await response.blob();if(this.destroyed)return;const imageBitmap=await createImageBitmap(imageBlob,{premultiplyAlpha:null===this.alphaMode||this.alphaMode===ALPHA_MODES.UNPACK?"premultiply":"none"});if(this.destroyed)return void imageBitmap.close();this.source=imageBitmap,this.update(),resolve(this)}catch(e){if(this.destroyed)return;reject(e),this.onError.emit(e)}else resolve(this)}))),this._load}upload(renderer,baseTexture,glTexture){return this.source instanceof ImageBitmap?("number"==typeof this.alphaMode&&(baseTexture.alphaMode=this.alphaMode),super.upload(renderer,baseTexture,glTexture)):(this.load(),!1)}dispose(){this.ownsImageBitmap&&this.source instanceof ImageBitmap&&this.source.close(),super.dispose(),this._load=null}static test(source){return!!globalThis.createImageBitmap&&typeof ImageBitmap<"u"&&("string"==typeof source||source instanceof ImageBitmap)}static get EMPTY(){return ImageBitmapResource._EMPTY=ImageBitmapResource._EMPTY??settings.ADAPTER.createCanvas(0,0),ImageBitmapResource._EMPTY}}const _SVGResource=class _SVGResource2 extends BaseImageResource{constructor(sourceBase64,options){options=options||{},super(settings.ADAPTER.createCanvas()),this._width=0,this._height=0,this.svg=sourceBase64,this.scale=options.scale||1,this._overrideWidth=options.width,this._overrideHeight=options.height,this._resolve=null,this._crossorigin=options.crossorigin,this._load=null,!1!==options.autoLoad&&this.load()}load(){return this._load||(this._load=new Promise((resolve=>{if(this._resolve=()=>{this.update(),resolve(this)},_SVGResource2.SVG_XML.test(this.svg.trim())){if(!btoa)throw new Error("Your browser doesn't support base64 conversions.");this.svg=`data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`}this._loadSvg()}))),this._load}_loadSvg(){const tempImage=new Image;BaseImageResource.crossOrigin(tempImage,this.svg,this._crossorigin),tempImage.src=this.svg,tempImage.onerror=event=>{this._resolve&&(tempImage.onerror=null,this.onError.emit(event))},tempImage.onload=()=>{if(!this._resolve)return;const svgWidth=tempImage.width,svgHeight=tempImage.height;if(!svgWidth||!svgHeight)throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");let width=svgWidth*this.scale,height=svgHeight*this.scale;(this._overrideWidth||this._overrideHeight)&&(width=this._overrideWidth||this._overrideHeight/svgHeight*svgWidth,height=this._overrideHeight||this._overrideWidth/svgWidth*svgHeight),width=Math.round(width),height=Math.round(height);const canvas=this.source;canvas.width=width,canvas.height=height,canvas._pixiId=`canvas_${uid()}`,canvas.getContext("2d").drawImage(tempImage,0,0,svgWidth,svgHeight,0,0,width,height),this._resolve(),this._resolve=null}}static getSize(svgString){const sizeMatch=_SVGResource2.SVG_SIZE.exec(svgString),size={};return sizeMatch&&(size[sizeMatch[1]]=Math.round(parseFloat(sizeMatch[3])),size[sizeMatch[5]]=Math.round(parseFloat(sizeMatch[7]))),size}dispose(){super.dispose(),this._resolve=null,this._crossorigin=null}static test(source,extension){return"svg"===extension||"string"==typeof source&&source.startsWith("data:image/svg+xml")||"string"==typeof source&&_SVGResource2.SVG_XML.test(source)}};_SVGResource.SVG_XML=/^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,_SVGResource.SVG_SIZE=/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;let SVGResource=_SVGResource;const _VideoResource=class _VideoResource2 extends BaseImageResource{constructor(source,options){if(options=options||{},!(source instanceof HTMLVideoElement)){const videoElement=document.createElement("video");!1!==options.autoLoad&&videoElement.setAttribute("preload","auto"),!1!==options.playsinline&&(videoElement.setAttribute("webkit-playsinline",""),videoElement.setAttribute("playsinline","")),!0===options.muted&&(videoElement.setAttribute("muted",""),videoElement.muted=!0),!0===options.loop&&videoElement.setAttribute("loop",""),!1!==options.autoPlay&&videoElement.setAttribute("autoplay",""),"string"==typeof source&&(source=[source]);const firstSrc=source[0].src||source[0];BaseImageResource.crossOrigin(videoElement,firstSrc,options.crossorigin);for(let i=0;i<source.length;++i){const sourceElement=document.createElement("source");let{src,mime}=source[i];if(src=src||source[i],src.startsWith("data:"))mime=src.slice(5,src.indexOf(";"));else if(!src.startsWith("blob:")){const baseSrc=src.split("?").shift().toLowerCase(),ext=baseSrc.slice(baseSrc.lastIndexOf(".")+1);mime=mime||_VideoResource2.MIME_TYPES[ext]||`video/${ext}`}sourceElement.src=src,mime&&(sourceElement.type=mime),videoElement.appendChild(sourceElement)}source=videoElement}super(source),this.noSubImage=!0,this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=options.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=!1!==options.autoPlay,this._videoFrameRequestCallback=this._videoFrameRequestCallback.bind(this),this._videoFrameRequestCallbackHandle=null,this._load=null,this._resolve=null,this._reject=null,this._onCanPlay=this._onCanPlay.bind(this),this._onError=this._onError.bind(this),this._onPlayStart=this._onPlayStart.bind(this),this._onPlayStop=this._onPlayStop.bind(this),this._onSeeked=this._onSeeked.bind(this),!1!==options.autoLoad&&this.load()}update(_deltaTime=0){if(!this.destroyed){if(this._updateFPS){const elapsedMS=Ticker.shared.elapsedMS*this.source.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-elapsedMS)}(!this._updateFPS||this._msToNextUpdate<=0)&&(super.update(),this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0)}}_videoFrameRequestCallback(){this.update(),this.destroyed?this._videoFrameRequestCallbackHandle=null:this._videoFrameRequestCallbackHandle=this.source.requestVideoFrameCallback(this._videoFrameRequestCallback)}load(){if(this._load)return this._load;const source=this.source;return(source.readyState===source.HAVE_ENOUGH_DATA||source.readyState===source.HAVE_FUTURE_DATA)&&source.width&&source.height&&(source.complete=!0),source.addEventListener("play",this._onPlayStart),source.addEventListener("pause",this._onPlayStop),source.addEventListener("seeked",this._onSeeked),this._isSourceReady()?this._onCanPlay():(source.addEventListener("canplay",this._onCanPlay),source.addEventListener("canplaythrough",this._onCanPlay),source.addEventListener("error",this._onError,!0)),this._load=new Promise(((resolve,reject)=>{this.valid?resolve(this):(this._resolve=resolve,this._reject=reject,source.load())})),this._load}_onError(event){this.source.removeEventListener("error",this._onError,!0),this.onError.emit(event),this._reject&&(this._reject(event),this._reject=null,this._resolve=null)}_isSourcePlaying(){const source=this.source;return!source.paused&&!source.ended&&this._isSourceReady()}_isSourceReady(){return this.source.readyState>2}_onPlayStart(){this.valid||this._onCanPlay(),this._configureAutoUpdate()}_onPlayStop(){this._configureAutoUpdate()}_onSeeked(){this._autoUpdate&&!this._isSourcePlaying()&&(this._msToNextUpdate=0,this.update(),this._msToNextUpdate=0)}_onCanPlay(){const source=this.source;source.removeEventListener("canplay",this._onCanPlay),source.removeEventListener("canplaythrough",this._onCanPlay);const valid=this.valid;this._msToNextUpdate=0,this.update(),this._msToNextUpdate=0,!valid&&this._resolve&&(this._resolve(this),this._resolve=null,this._reject=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&source.play()}dispose(){this._configureAutoUpdate();const source=this.source;source&&(source.removeEventListener("play",this._onPlayStart),source.removeEventListener("pause",this._onPlayStop),source.removeEventListener("seeked",this._onSeeked),source.removeEventListener("canplay",this._onCanPlay),source.removeEventListener("canplaythrough",this._onCanPlay),source.removeEventListener("error",this._onError,!0),source.pause(),source.src="",source.load()),super.dispose()}get autoUpdate(){return this._autoUpdate}set autoUpdate(value){value!==this._autoUpdate&&(this._autoUpdate=value,this._configureAutoUpdate())}get updateFPS(){return this._updateFPS}set updateFPS(value){value!==this._updateFPS&&(this._updateFPS=value,this._configureAutoUpdate())}_configureAutoUpdate(){this._autoUpdate&&this._isSourcePlaying()?!this._updateFPS&&this.source.requestVideoFrameCallback?(this._isConnectedToTicker&&(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0),null===this._videoFrameRequestCallbackHandle&&(this._videoFrameRequestCallbackHandle=this.source.requestVideoFrameCallback(this._videoFrameRequestCallback))):(null!==this._videoFrameRequestCallbackHandle&&(this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker||(Ticker.shared.add(this.update,this),this._isConnectedToTicker=!0,this._msToNextUpdate=0)):(null!==this._videoFrameRequestCallbackHandle&&(this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker&&(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0))}static test(source,extension){return globalThis.HTMLVideoElement&&source instanceof HTMLVideoElement||_VideoResource2.TYPES.includes(extension)}};_VideoResource.TYPES=["mp4","m4v","webm","ogg","ogv","h264","avi","mov"],_VideoResource.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};let VideoResource=_VideoResource;INSTALLED.push(ImageBitmapResource,ImageResource,class CanvasResource extends BaseImageResource{constructor(source){super(source)}static test(source){const{OffscreenCanvas}=globalThis;return!!(OffscreenCanvas&&source instanceof OffscreenCanvas)||globalThis.HTMLCanvasElement&&source instanceof HTMLCanvasElement}},VideoResource,SVGResource,BufferResource,CubeResource,class ArrayResource extends AbstractMultiResource{constructor(source,options){const{width,height}=options||{};let urls,length;Array.isArray(source)?(urls=source,length=source.length):length=source,super(length,{width,height}),urls&&this.initFromArray(urls,options)}addBaseTextureAt(baseTexture,index){if(!baseTexture.resource)throw new Error("ArrayResource does not support RenderTexture");return this.addResourceAt(baseTexture.resource,index),this}bind(baseTexture){super.bind(baseTexture),baseTexture.target=TARGETS.TEXTURE_2D_ARRAY}upload(renderer,texture,glTexture){const{length,itemDirtyIds,items}=this,{gl}=renderer;glTexture.dirtyId<0&&gl.texImage3D(gl.TEXTURE_2D_ARRAY,0,glTexture.internalFormat,this._width,this._height,length,0,texture.format,glTexture.type,null);for(let i=0;i<length;i++){const item=items[i];itemDirtyIds[i]<item.dirtyId&&(itemDirtyIds[i]=item.dirtyId,item.valid&&gl.texSubImage3D(gl.TEXTURE_2D_ARRAY,0,0,0,i,item.resource.width,item.resource.height,1,texture.format,glTexture.type,item.resource.source))}return!0}})},"./node_modules/@pixi/display/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{YZ:()=>Bounds,W2:()=>Container});var lib=__webpack_require__("./node_modules/@pixi/core/lib/index.mjs");class Bounds{constructor(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.rect=null,this.updateID=-1}isEmpty(){return this.minX>this.maxX||this.minY>this.maxY}clear(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}getRectangle(rect){return this.minX>this.maxX||this.minY>this.maxY?lib.Ae.EMPTY:((rect=rect||new lib.Ae(0,0,1,1)).x=this.minX,rect.y=this.minY,rect.width=this.maxX-this.minX,rect.height=this.maxY-this.minY,rect)}addPoint(point){this.minX=Math.min(this.minX,point.x),this.maxX=Math.max(this.maxX,point.x),this.minY=Math.min(this.minY,point.y),this.maxY=Math.max(this.maxY,point.y)}addPointMatrix(matrix,point){const{a,b,c,d,tx,ty}=matrix,x=a*point.x+c*point.y+tx,y=b*point.x+d*point.y+ty;this.minX=Math.min(this.minX,x),this.maxX=Math.max(this.maxX,x),this.minY=Math.min(this.minY,y),this.maxY=Math.max(this.maxY,y)}addQuad(vertices){let minX=this.minX,minY=this.minY,maxX=this.maxX,maxY=this.maxY,x=vertices[0],y=vertices[1];minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,x=vertices[2],y=vertices[3],minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,x=vertices[4],y=vertices[5],minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,x=vertices[6],y=vertices[7],minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,this.minX=minX,this.minY=minY,this.maxX=maxX,this.maxY=maxY}addFrame(transform,x0,y0,x1,y1){this.addFrameMatrix(transform.worldTransform,x0,y0,x1,y1)}addFrameMatrix(matrix,x0,y0,x1,y1){const a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;let minX=this.minX,minY=this.minY,maxX=this.maxX,maxY=this.maxY,x=a*x0+c*y0+tx,y=b*x0+d*y0+ty;minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,x=a*x1+c*y0+tx,y=b*x1+d*y0+ty,minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,x=a*x0+c*y1+tx,y=b*x0+d*y1+ty,minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,x=a*x1+c*y1+tx,y=b*x1+d*y1+ty,minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,this.minX=minX,this.minY=minY,this.maxX=maxX,this.maxY=maxY}addVertexData(vertexData,beginOffset,endOffset){let minX=this.minX,minY=this.minY,maxX=this.maxX,maxY=this.maxY;for(let i=beginOffset;i<endOffset;i+=2){const x=vertexData[i],y=vertexData[i+1];minX=x<minX?x:minX,minY=y<minY?y:minY,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY}this.minX=minX,this.minY=minY,this.maxX=maxX,this.maxY=maxY}addVertices(transform,vertices,beginOffset,endOffset){this.addVerticesMatrix(transform.worldTransform,vertices,beginOffset,endOffset)}addVerticesMatrix(matrix,vertices,beginOffset,endOffset,padX=0,padY=padX){const a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;let minX=this.minX,minY=this.minY,maxX=this.maxX,maxY=this.maxY;for(let i=beginOffset;i<endOffset;i+=2){const rawX=vertices[i],rawY=vertices[i+1],x=a*rawX+c*rawY+tx,y=d*rawY+b*rawX+ty;minX=Math.min(minX,x-padX),maxX=Math.max(maxX,x+padX),minY=Math.min(minY,y-padY),maxY=Math.max(maxY,y+padY)}this.minX=minX,this.minY=minY,this.maxX=maxX,this.maxY=maxY}addBounds(bounds){const minX=this.minX,minY=this.minY,maxX=this.maxX,maxY=this.maxY;this.minX=bounds.minX<minX?bounds.minX:minX,this.minY=bounds.minY<minY?bounds.minY:minY,this.maxX=bounds.maxX>maxX?bounds.maxX:maxX,this.maxY=bounds.maxY>maxY?bounds.maxY:maxY}addBoundsMask(bounds,mask){const _minX=bounds.minX>mask.minX?bounds.minX:mask.minX,_minY=bounds.minY>mask.minY?bounds.minY:mask.minY,_maxX=bounds.maxX<mask.maxX?bounds.maxX:mask.maxX,_maxY=bounds.maxY<mask.maxY?bounds.maxY:mask.maxY;if(_minX<=_maxX&&_minY<=_maxY){const minX=this.minX,minY=this.minY,maxX=this.maxX,maxY=this.maxY;this.minX=_minX<minX?_minX:minX,this.minY=_minY<minY?_minY:minY,this.maxX=_maxX>maxX?_maxX:maxX,this.maxY=_maxY>maxY?_maxY:maxY}}addBoundsMatrix(bounds,matrix){this.addFrameMatrix(matrix,bounds.minX,bounds.minY,bounds.maxX,bounds.maxY)}addBoundsArea(bounds,area){const _minX=bounds.minX>area.x?bounds.minX:area.x,_minY=bounds.minY>area.y?bounds.minY:area.y,_maxX=bounds.maxX<area.x+area.width?bounds.maxX:area.x+area.width,_maxY=bounds.maxY<area.y+area.height?bounds.maxY:area.y+area.height;if(_minX<=_maxX&&_minY<=_maxY){const minX=this.minX,minY=this.minY,maxX=this.maxX,maxY=this.maxY;this.minX=_minX<minX?_minX:minX,this.minY=_minY<minY?_minY:minY,this.maxX=_maxX>maxX?_maxX:maxX,this.maxY=_maxY>maxY?_maxY:maxY}}pad(paddingX=0,paddingY=paddingX){this.isEmpty()||(this.minX-=paddingX,this.maxX+=paddingX,this.minY-=paddingY,this.maxY+=paddingY)}addFramePad(x0,y0,x1,y1,padX,padY){x0-=padX,y0-=padY,x1+=padX,y1+=padY,this.minX=this.minX<x0?this.minX:x0,this.maxX=this.maxX>x1?this.maxX:x1,this.minY=this.minY<y0?this.minY:y0,this.maxY=this.maxY>y1?this.maxY:y1}}class DisplayObject extends lib.P6.EventEmitter{constructor(){super(),this.tempDisplayObjectParent=null,this.transform=new lib.wx,this.alpha=1,this.visible=!0,this.renderable=!0,this.cullable=!1,this.cullArea=null,this.parent=null,this.worldAlpha=1,this._lastSortedIndex=0,this._zIndex=0,this.filterArea=null,this.filters=null,this._enabledFilters=null,this._bounds=new Bounds,this._localBounds=null,this._boundsID=0,this._boundsRect=null,this._localBoundsRect=null,this._mask=null,this._maskRefCount=0,this._destroyed=!1,this.isSprite=!1,this.isMask=!1}static mixin(source){const keys=Object.keys(source);for(let i=0;i<keys.length;++i){const propertyName=keys[i];Object.defineProperty(DisplayObject.prototype,propertyName,Object.getOwnPropertyDescriptor(source,propertyName))}}get destroyed(){return this._destroyed}_recursivePostUpdateTransform(){this.parent?(this.parent._recursivePostUpdateTransform(),this.transform.updateTransform(this.parent.transform)):this.transform.updateTransform(this._tempDisplayObjectParent.transform)}updateTransform(){this._boundsID++,this.transform.updateTransform(this.parent.transform),this.worldAlpha=this.alpha*this.parent.worldAlpha}getBounds(skipUpdate,rect){return skipUpdate||(this.parent?(this._recursivePostUpdateTransform(),this.updateTransform()):(this.parent=this._tempDisplayObjectParent,this.updateTransform(),this.parent=null)),this._bounds.updateID!==this._boundsID&&(this.calculateBounds(),this._bounds.updateID=this._boundsID),rect||(this._boundsRect||(this._boundsRect=new lib.Ae),rect=this._boundsRect),this._bounds.getRectangle(rect)}getLocalBounds(rect){rect||(this._localBoundsRect||(this._localBoundsRect=new lib.Ae),rect=this._localBoundsRect),this._localBounds||(this._localBounds=new Bounds);const transformRef=this.transform,parentRef=this.parent;this.parent=null,this._tempDisplayObjectParent.worldAlpha=parentRef?.worldAlpha??1,this.transform=this._tempDisplayObjectParent.transform;const worldBounds=this._bounds,worldBoundsID=this._boundsID;this._bounds=this._localBounds;const bounds=this.getBounds(!1,rect);return this.parent=parentRef,this.transform=transformRef,this._bounds=worldBounds,this._bounds.updateID+=this._boundsID-worldBoundsID,bounds}toGlobal(position,point,skipUpdate=!1){return skipUpdate||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.apply(position,point)}toLocal(position,from,point,skipUpdate){return from&&(position=from.toGlobal(position,point,skipUpdate)),skipUpdate||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.applyInverse(position,point)}setParent(container){if(!container||!container.addChild)throw new Error("setParent: Argument must be a Container");return container.addChild(this),container}removeFromParent(){this.parent?.removeChild(this)}setTransform(x=0,y=0,scaleX=1,scaleY=1,rotation=0,skewX=0,skewY=0,pivotX=0,pivotY=0){return this.position.x=x,this.position.y=y,this.scale.x=scaleX||1,this.scale.y=scaleY||1,this.rotation=rotation,this.skew.x=skewX,this.skew.y=skewY,this.pivot.x=pivotX,this.pivot.y=pivotY,this}destroy(_options){this.removeFromParent(),this._destroyed=!0,this.transform=null,this.parent=null,this._bounds=null,this.mask=null,this.cullArea=null,this.filters=null,this.filterArea=null,this.hitArea=null,this.eventMode="auto",this.interactiveChildren=!1,this.emit("destroyed"),this.removeAllListeners()}get _tempDisplayObjectParent(){return null===this.tempDisplayObjectParent&&(this.tempDisplayObjectParent=new TemporaryDisplayObject),this.tempDisplayObjectParent}enableTempParent(){const myParent=this.parent;return this.parent=this._tempDisplayObjectParent,myParent}disableTempParent(cacheParent){this.parent=cacheParent}get x(){return this.position.x}set x(value){this.transform.position.x=value}get y(){return this.position.y}set y(value){this.transform.position.y=value}get worldTransform(){return this.transform.worldTransform}get localTransform(){return this.transform.localTransform}get position(){return this.transform.position}set position(value){this.transform.position.copyFrom(value)}get scale(){return this.transform.scale}set scale(value){this.transform.scale.copyFrom(value)}get pivot(){return this.transform.pivot}set pivot(value){this.transform.pivot.copyFrom(value)}get skew(){return this.transform.skew}set skew(value){this.transform.skew.copyFrom(value)}get rotation(){return this.transform.rotation}set rotation(value){this.transform.rotation=value}get angle(){return this.transform.rotation*lib.jl}set angle(value){this.transform.rotation=value*lib.ZX}get zIndex(){return this._zIndex}set zIndex(value){this._zIndex=value,this.parent&&(this.parent.sortDirty=!0)}get worldVisible(){let item=this;do{if(!item.visible)return!1;item=item.parent}while(item);return!0}get mask(){return this._mask}set mask(value){if(this._mask!==value){if(this._mask){const maskObject=this._mask.isMaskData?this._mask.maskObject:this._mask;maskObject&&(maskObject._maskRefCount--,0===maskObject._maskRefCount&&(maskObject.renderable=!0,maskObject.isMask=!1))}if(this._mask=value,this._mask){const maskObject=this._mask.isMaskData?this._mask.maskObject:this._mask;maskObject&&(0===maskObject._maskRefCount&&(maskObject.renderable=!1,maskObject.isMask=!0),maskObject._maskRefCount++)}}}}class TemporaryDisplayObject extends DisplayObject{constructor(){super(...arguments),this.sortDirty=null}}DisplayObject.prototype.displayObjectUpdateTransform=DisplayObject.prototype.updateTransform;const tempMatrix=new lib.y3;function sortChildren(a,b){return a.zIndex===b.zIndex?a._lastSortedIndex-b._lastSortedIndex:a.zIndex-b.zIndex}const _Container=class _Container2 extends DisplayObject{constructor(){super(),this.children=[],this.sortableChildren=_Container2.defaultSortableChildren,this.sortDirty=!1}onChildrenChange(_length){}addChild(...children){if(children.length>1)for(let i=0;i<children.length;i++)this.addChild(children[i]);else{const child=children[0];child.parent&&child.parent.removeChild(child),child.parent=this,this.sortDirty=!0,child.transform._parentID=-1,this.children.push(child),this._boundsID++,this.onChildrenChange(this.children.length-1),this.emit("childAdded",child,this,this.children.length-1),child.emit("added",this)}return children[0]}addChildAt(child,index){if(index<0||index>this.children.length)throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);return child.parent&&child.parent.removeChild(child),child.parent=this,this.sortDirty=!0,child.transform._parentID=-1,this.children.splice(index,0,child),this._boundsID++,this.onChildrenChange(index),child.emit("added",this),this.emit("childAdded",child,this,index),child}swapChildren(child,child2){if(child===child2)return;const index1=this.getChildIndex(child),index2=this.getChildIndex(child2);this.children[index1]=child2,this.children[index2]=child,this.onChildrenChange(index1<index2?index1:index2)}getChildIndex(child){const index=this.children.indexOf(child);if(-1===index)throw new Error("The supplied DisplayObject must be a child of the caller");return index}setChildIndex(child,index){if(index<0||index>=this.children.length)throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);const currentIndex=this.getChildIndex(child);lib.P6.removeItems(this.children,currentIndex,1),this.children.splice(index,0,child),this.onChildrenChange(index)}getChildAt(index){if(index<0||index>=this.children.length)throw new Error(`getChildAt: Index (${index}) does not exist.`);return this.children[index]}removeChild(...children){if(children.length>1)for(let i=0;i<children.length;i++)this.removeChild(children[i]);else{const child=children[0],index=this.children.indexOf(child);if(-1===index)return null;child.parent=null,child.transform._parentID=-1,lib.P6.removeItems(this.children,index,1),this._boundsID++,this.onChildrenChange(index),child.emit("removed",this),this.emit("childRemoved",child,this,index)}return children[0]}removeChildAt(index){const child=this.getChildAt(index);return child.parent=null,child.transform._parentID=-1,lib.P6.removeItems(this.children,index,1),this._boundsID++,this.onChildrenChange(index),child.emit("removed",this),this.emit("childRemoved",child,this,index),child}removeChildren(beginIndex=0,endIndex=this.children.length){const begin=beginIndex,range=endIndex-begin;let removed;if(range>0&&range<=endIndex){removed=this.children.splice(begin,range);for(let i=0;i<removed.length;++i)removed[i].parent=null,removed[i].transform&&(removed[i].transform._parentID=-1);this._boundsID++,this.onChildrenChange(beginIndex);for(let i=0;i<removed.length;++i)removed[i].emit("removed",this),this.emit("childRemoved",removed[i],this,i);return removed}if(0===range&&0===this.children.length)return[];throw new RangeError("removeChildren: numeric values are outside the acceptable range.")}sortChildren(){let sortRequired=!1;for(let i=0,j=this.children.length;i<j;++i){const child=this.children[i];child._lastSortedIndex=i,!sortRequired&&0!==child.zIndex&&(sortRequired=!0)}sortRequired&&this.children.length>1&&this.children.sort(sortChildren),this.sortDirty=!1}updateTransform(){this.sortableChildren&&this.sortDirty&&this.sortChildren(),this._boundsID++,this.transform.updateTransform(this.parent.transform),this.worldAlpha=this.alpha*this.parent.worldAlpha;for(let i=0,j=this.children.length;i<j;++i){const child=this.children[i];child.visible&&child.updateTransform()}}calculateBounds(){this._bounds.clear(),this._calculateBounds();for(let i=0;i<this.children.length;i++){const child=this.children[i];if(child.visible&&child.renderable)if(child.calculateBounds(),child._mask){const maskObject=child._mask.isMaskData?child._mask.maskObject:child._mask;maskObject?(maskObject.calculateBounds(),this._bounds.addBoundsMask(child._bounds,maskObject._bounds)):this._bounds.addBounds(child._bounds)}else child.filterArea?this._bounds.addBoundsArea(child._bounds,child.filterArea):this._bounds.addBounds(child._bounds)}this._bounds.updateID=this._boundsID}getLocalBounds(rect,skipChildrenUpdate=!1){const result=super.getLocalBounds(rect);if(!skipChildrenUpdate)for(let i=0,j=this.children.length;i<j;++i){const child=this.children[i];child.visible&&child.updateTransform()}return result}_calculateBounds(){}_renderWithCulling(renderer){const sourceFrame=renderer.renderTexture.sourceFrame;if(!(sourceFrame.width>0&&sourceFrame.height>0))return;let bounds,transform;this.cullArea?(bounds=this.cullArea,transform=this.worldTransform):this._render!==_Container2.prototype._render&&(bounds=this.getBounds(!0));const projectionTransform=renderer.projection.transform;if(projectionTransform&&(transform?(transform=tempMatrix.copyFrom(transform),transform.prepend(projectionTransform)):transform=projectionTransform),bounds&&sourceFrame.intersects(bounds,transform))this._render(renderer);else if(this.cullArea)return;for(let i=0,j=this.children.length;i<j;++i){const child=this.children[i],childCullable=child.cullable;child.cullable=childCullable||!this.cullArea,child.render(renderer),child.cullable=childCullable}}render(renderer){if(this.visible&&!(this.worldAlpha<=0)&&this.renderable)if(this._mask||this.filters?.length)this.renderAdvanced(renderer);else if(this.cullable)this._renderWithCulling(renderer);else{this._render(renderer);for(let i=0,j=this.children.length;i<j;++i)this.children[i].render(renderer)}}renderAdvanced(renderer){const filters=this.filters,mask=this._mask;if(filters){this._enabledFilters||(this._enabledFilters=[]),this._enabledFilters.length=0;for(let i=0;i<filters.length;i++)filters[i].enabled&&this._enabledFilters.push(filters[i])}const flush=filters&&this._enabledFilters?.length||mask&&(!mask.isMaskData||mask.enabled&&(mask.autoDetect||mask.type!==lib.A7.NONE));if(flush&&renderer.batch.flush(),filters&&this._enabledFilters?.length&&renderer.filter.push(this,this._enabledFilters),mask&&renderer.mask.push(this,this._mask),this.cullable)this._renderWithCulling(renderer);else{this._render(renderer);for(let i=0,j=this.children.length;i<j;++i)this.children[i].render(renderer)}flush&&renderer.batch.flush(),mask&&renderer.mask.pop(this),filters&&this._enabledFilters?.length&&renderer.filter.pop()}_render(_renderer){}destroy(options){super.destroy(),this.sortDirty=!1;const destroyChildren="boolean"==typeof options?options:options?.children,oldChildren=this.removeChildren(0,this.children.length);if(destroyChildren)for(let i=0;i<oldChildren.length;++i)oldChildren[i].destroy(options)}get width(){return this.scale.x*this.getLocalBounds().width}set width(value){const width=this.getLocalBounds().width;this.scale.x=0!==width?value/width:1,this._width=value}get height(){return this.scale.y*this.getLocalBounds().height}set height(value){const height=this.getLocalBounds().height;this.scale.y=0!==height?value/height:1,this._height=value}};_Container.defaultSortableChildren=!1;let Container=_Container;Container.prototype.containerUpdateTransform=Container.prototype.updateTransform,Object.defineProperties(lib.Xd,{SORTABLE_CHILDREN:{get:()=>Container.defaultSortableChildren,set(value){lib.P6.deprecation("7.1.0","settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),Container.defaultSortableChildren=value}}})}}]);