"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[2824],{"./node_modules/@pixi/graphics/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{TC:()=>Graphics});var lib=__webpack_require__("./node_modules/@pixi/core/lib/index.mjs");const buildCircle={build(graphicsData){const points=graphicsData.points;let x,y,dx,dy,rx,ry;if(graphicsData.type===lib.HS.CIRC){const circle=graphicsData.shape;x=circle.x,y=circle.y,rx=ry=circle.radius,dx=dy=0}else if(graphicsData.type===lib.HS.ELIP){const ellipse=graphicsData.shape;x=ellipse.x,y=ellipse.y,rx=ellipse.width,ry=ellipse.height,dx=dy=0}else{const roundedRect=graphicsData.shape,halfWidth=roundedRect.width/2,halfHeight=roundedRect.height/2;x=roundedRect.x+halfWidth,y=roundedRect.y+halfHeight,rx=ry=Math.max(0,Math.min(roundedRect.radius,Math.min(halfWidth,halfHeight))),dx=halfWidth-rx,dy=halfHeight-ry}if(!(rx>=0&&ry>=0&&dx>=0&&dy>=0))return void(points.length=0);const n=Math.ceil(2.3*Math.sqrt(rx+ry)),m=8*n+(dx?4:0)+(dy?4:0);if(points.length=m,0===m)return;if(0===n)return points.length=8,points[0]=points[6]=x+dx,points[1]=points[3]=y+dy,points[2]=points[4]=x-dx,void(points[5]=points[7]=y-dy);let j1=0,j2=4*n+(dx?2:0)+2,j3=j2,j4=m;{const x0=dx+rx,y0=dy,x1=x+x0,x2=x-x0,y1=y+y0;if(points[j1++]=x1,points[j1++]=y1,points[--j2]=y1,points[--j2]=x2,dy){const y2=y-y0;points[j3++]=x2,points[j3++]=y2,points[--j4]=y2,points[--j4]=x1}}for(let i=1;i<n;i++){const a=Math.PI/2*(i/n),x0=dx+Math.cos(a)*rx,y0=dy+Math.sin(a)*ry,x1=x+x0,x2=x-x0,y1=y+y0,y2=y-y0;points[j1++]=x1,points[j1++]=y1,points[--j2]=y1,points[--j2]=x2,points[j3++]=x2,points[j3++]=y2,points[--j4]=y2,points[--j4]=x1}{const y0=dy+ry,x1=x+dx,x2=x-dx,y1=y+y0,y2=y-y0;points[j1++]=x1,points[j1++]=y1,points[--j4]=y2,points[--j4]=x1,dx&&(points[j1++]=x2,points[j1++]=y1,points[--j4]=y2,points[--j4]=x2)}},triangulate(graphicsData,graphicsGeometry){const points=graphicsData.points,verts=graphicsGeometry.points,indices=graphicsGeometry.indices;if(0===points.length)return;let vertPos=verts.length/2;const center=vertPos;let x,y;if(graphicsData.type!==lib.HS.RREC){const circle=graphicsData.shape;x=circle.x,y=circle.y}else{const roundedRect=graphicsData.shape;x=roundedRect.x+roundedRect.width/2,y=roundedRect.y+roundedRect.height/2}const matrix=graphicsData.matrix;verts.push(graphicsData.matrix?matrix.a*x+matrix.c*y+matrix.tx:x,graphicsData.matrix?matrix.b*x+matrix.d*y+matrix.ty:y),vertPos++,verts.push(points[0],points[1]);for(let i=2;i<points.length;i+=2)verts.push(points[i],points[i+1]),indices.push(vertPos++,center,vertPos);indices.push(center+1,center,vertPos)}};function fixOrientation(points,hole=!1){const m=points.length;if(m<6)return;let area=0;for(let i=0,x1=points[m-2],y1=points[m-1];i<m;i+=2){const x2=points[i],y2=points[i+1];area+=(x2-x1)*(y2+y1),x1=x2,y1=y2}if(!hole&&area>0||hole&&area<=0){const n=m/2;for(let i=n+n%2;i<m;i+=2){const i1=m-i-2,i2=m-i-1,i3=i,i4=i+1;[points[i1],points[i3]]=[points[i3],points[i1]],[points[i2],points[i4]]=[points[i4],points[i2]]}}}const buildPoly={build(graphicsData){graphicsData.points=graphicsData.shape.points.slice()},triangulate(graphicsData,graphicsGeometry){let points=graphicsData.points;const holes=graphicsData.holes,verts=graphicsGeometry.points,indices=graphicsGeometry.indices;if(points.length>=6){fixOrientation(points,!1);const holeArray=[];for(let i=0;i<holes.length;i++){const hole=holes[i];fixOrientation(hole.points,!0),holeArray.push(points.length/2),points=points.concat(hole.points)}const triangles=lib.P6.earcut(points,holeArray,2);if(!triangles)return;const vertPos=verts.length/2;for(let i=0;i<triangles.length;i+=3)indices.push(triangles[i]+vertPos),indices.push(triangles[i+1]+vertPos),indices.push(triangles[i+2]+vertPos);for(let i=0;i<points.length;i++)verts.push(points[i])}}},buildRectangle={build(graphicsData){const rectData=graphicsData.shape,x=rectData.x,y=rectData.y,width=rectData.width,height=rectData.height,points=graphicsData.points;points.length=0,width>=0&&height>=0&&points.push(x,y,x+width,y,x+width,y+height,x,y+height)},triangulate(graphicsData,graphicsGeometry){const points=graphicsData.points,verts=graphicsGeometry.points;if(0===points.length)return;const vertPos=verts.length/2;verts.push(points[0],points[1],points[2],points[3],points[6],points[7],points[4],points[5]),graphicsGeometry.indices.push(vertPos,vertPos+1,vertPos+2,vertPos+1,vertPos+2,vertPos+3)}},buildRoundedRectangle={build(graphicsData){buildCircle.build(graphicsData)},triangulate(graphicsData,graphicsGeometry){buildCircle.triangulate(graphicsData,graphicsGeometry)}};var LINE_JOIN=(LINE_JOIN2=>(LINE_JOIN2.MITER="miter",LINE_JOIN2.BEVEL="bevel",LINE_JOIN2.ROUND="round",LINE_JOIN2))(LINE_JOIN||{}),LINE_CAP=(LINE_CAP2=>(LINE_CAP2.BUTT="butt",LINE_CAP2.ROUND="round",LINE_CAP2.SQUARE="square",LINE_CAP2))(LINE_CAP||{});const curves={adaptive:!0,maxLength:10,minSegments:8,maxSegments:2048,epsilon:1e-4,_segmentsCount(length,defaultSegments=20){if(!this.adaptive||!length||isNaN(length))return defaultSegments;let result=Math.ceil(length/this.maxLength);return result<this.minSegments?result=this.minSegments:result>this.maxSegments&&(result=this.maxSegments),result}};class ArcUtils{static curveTo(x1,y1,x2,y2,radius,points){const fromX=points[points.length-2],a1=points[points.length-1]-y1,b1=fromX-x1,a2=y2-y1,b2=x2-x1,mm=Math.abs(a1*b2-b1*a2);if(mm<1e-8||0===radius)return(points[points.length-2]!==x1||points[points.length-1]!==y1)&&points.push(x1,y1),null;const dd=a1*a1+b1*b1,cc=a2*a2+b2*b2,tt=a1*a2+b1*b2,k1=radius*Math.sqrt(dd)/mm,k2=radius*Math.sqrt(cc)/mm,j1=k1*tt/dd,j2=k2*tt/cc,cx=k1*b2+k2*b1,cy=k1*a2+k2*a1,px=b1*(k2+j1),py=a1*(k2+j1),qx=b2*(k1+j2),qy=a2*(k1+j2);return{cx:cx+x1,cy:cy+y1,radius,startAngle:Math.atan2(py-cy,px-cx),endAngle:Math.atan2(qy-cy,qx-cx),anticlockwise:b1*a2>b2*a1}}static arc(_startX,_startY,cx,cy,radius,startAngle,endAngle,_anticlockwise,points){const sweep=endAngle-startAngle,n=curves._segmentsCount(Math.abs(sweep)*radius,40*Math.ceil(Math.abs(sweep)/lib._b)),theta=sweep/(2*n),theta2=2*theta,cTheta=Math.cos(theta),sTheta=Math.sin(theta),segMinus=n-1,remainder=segMinus%1/segMinus;for(let i=0;i<=segMinus;++i){const angle=theta+startAngle+theta2*(i+remainder*i),c=Math.cos(angle),s=-Math.sin(angle);points.push((cTheta*c+sTheta*s)*radius+cx,(cTheta*-s+sTheta*c)*radius+cy)}}}class BezierUtils{static curveLength(fromX,fromY,cpX,cpY,cpX2,cpY2,toX,toY){let result=0,t=0,t2=0,t3=0,nt=0,nt2=0,nt3=0,x=0,y=0,dx=0,dy=0,prevX=fromX,prevY=fromY;for(let i=1;i<=10;++i)t=i/10,t2=t*t,t3=t2*t,nt=1-t,nt2=nt*nt,nt3=nt2*nt,x=nt3*fromX+3*nt2*t*cpX+3*nt*t2*cpX2+t3*toX,y=nt3*fromY+3*nt2*t*cpY+3*nt*t2*cpY2+t3*toY,dx=prevX-x,dy=prevY-y,prevX=x,prevY=y,result+=Math.sqrt(dx*dx+dy*dy);return result}static curveTo(cpX,cpY,cpX2,cpY2,toX,toY,points){const fromX=points[points.length-2],fromY=points[points.length-1];points.length-=2;const n=curves._segmentsCount(BezierUtils.curveLength(fromX,fromY,cpX,cpY,cpX2,cpY2,toX,toY));let dt=0,dt2=0,dt3=0,t2=0,t3=0;points.push(fromX,fromY);for(let i=1,j=0;i<=n;++i)j=i/n,dt=1-j,dt2=dt*dt,dt3=dt2*dt,t2=j*j,t3=t2*j,points.push(dt3*fromX+3*dt2*j*cpX+3*dt*t2*cpX2+t3*toX,dt3*fromY+3*dt2*j*cpY+3*dt*t2*cpY2+t3*toY)}}function square(x,y,nx,ny,innerWeight,outerWeight,clockwise,verts){let exx,eyy;clockwise?(exx=ny,eyy=-nx):(exx=-ny,eyy=nx);const eix=x-nx*innerWeight+exx,eiy=y-ny*innerWeight+eyy,eox=x+nx*outerWeight+exx,eoy=y+ny*outerWeight+eyy;return verts.push(eix,eiy,eox,eoy),2}function round(cx,cy,sx,sy,ex,ey,verts,clockwise){const cx2p0x=sx-cx,cy2p0y=sy-cy;let angle0=Math.atan2(cx2p0x,cy2p0y),angle1=Math.atan2(ex-cx,ey-cy);clockwise&&angle0<angle1?angle0+=2*Math.PI:!clockwise&&angle0>angle1&&(angle1+=2*Math.PI);let startAngle=angle0;const angleDiff=angle1-angle0,absAngleDiff=Math.abs(angleDiff),radius=Math.sqrt(cx2p0x*cx2p0x+cy2p0y*cy2p0y),segCount=1+(15*absAngleDiff*Math.sqrt(radius)/Math.PI>>0),angleInc=angleDiff/segCount;if(startAngle+=angleInc,clockwise){verts.push(cx,cy,sx,sy);for(let i=1,angle=startAngle;i<segCount;i++,angle+=angleInc)verts.push(cx,cy,cx+Math.sin(angle)*radius,cy+Math.cos(angle)*radius);verts.push(cx,cy,ex,ey)}else{verts.push(sx,sy,cx,cy);for(let i=1,angle=startAngle;i<segCount;i++,angle+=angleInc)verts.push(cx+Math.sin(angle)*radius,cy+Math.cos(angle)*radius,cx,cy);verts.push(ex,ey,cx,cy)}return 2*segCount}function buildLine(graphicsData,graphicsGeometry){graphicsData.lineStyle.native?function buildNativeLine(graphicsData,graphicsGeometry){let i=0;const shape=graphicsData.shape,points=graphicsData.points||shape.points,closedShape=shape.type!==lib.HS.POLY||shape.closeStroke;if(0===points.length)return;const verts=graphicsGeometry.points,indices=graphicsGeometry.indices,length=points.length/2,startIndex=verts.length/2;let currentIndex=startIndex;for(verts.push(points[0],points[1]),i=1;i<length;i++)verts.push(points[2*i],points[2*i+1]),indices.push(currentIndex,currentIndex+1),currentIndex++;closedShape&&indices.push(currentIndex,startIndex)}(graphicsData,graphicsGeometry):function buildNonNativeLine(graphicsData,graphicsGeometry){const shape=graphicsData.shape;let points=graphicsData.points||shape.points.slice();const eps=graphicsGeometry.closePointEps;if(0===points.length)return;const style=graphicsData.lineStyle,firstPoint=new lib.E9(points[0],points[1]),lastPoint=new lib.E9(points[points.length-2],points[points.length-1]),closedShape=shape.type!==lib.HS.POLY||shape.closeStroke,closedPath=Math.abs(firstPoint.x-lastPoint.x)<eps&&Math.abs(firstPoint.y-lastPoint.y)<eps;if(closedShape){points=points.slice(),closedPath&&(points.pop(),points.pop(),lastPoint.set(points[points.length-2],points[points.length-1]));const midPointX=.5*(firstPoint.x+lastPoint.x),midPointY=.5*(lastPoint.y+firstPoint.y);points.unshift(midPointX,midPointY),points.push(midPointX,midPointY)}const verts=graphicsGeometry.points,length=points.length/2;let indexCount=points.length;const indexStart=verts.length/2,width=style.width/2,widthSquared=width*width,miterLimitSquared=style.miterLimit*style.miterLimit;let x0=points[0],y0=points[1],x1=points[2],y1=points[3],x2=0,y2=0,perpx=-(y0-y1),perpy=x0-x1,perp1x=0,perp1y=0,dist=Math.sqrt(perpx*perpx+perpy*perpy);perpx/=dist,perpy/=dist,perpx*=width,perpy*=width;const ratio=style.alignment,innerWeight=2*(1-ratio),outerWeight=2*ratio;closedShape||(style.cap===LINE_CAP.ROUND?indexCount+=round(x0-perpx*(innerWeight-outerWeight)*.5,y0-perpy*(innerWeight-outerWeight)*.5,x0-perpx*innerWeight,y0-perpy*innerWeight,x0+perpx*outerWeight,y0+perpy*outerWeight,verts,!0)+2:style.cap===LINE_CAP.SQUARE&&(indexCount+=square(x0,y0,perpx,perpy,innerWeight,outerWeight,!0,verts))),verts.push(x0-perpx*innerWeight,y0-perpy*innerWeight,x0+perpx*outerWeight,y0+perpy*outerWeight);for(let i=1;i<length-1;++i){x0=points[2*(i-1)],y0=points[2*(i-1)+1],x1=points[2*i],y1=points[2*i+1],x2=points[2*(i+1)],y2=points[2*(i+1)+1],perpx=-(y0-y1),perpy=x0-x1,dist=Math.sqrt(perpx*perpx+perpy*perpy),perpx/=dist,perpy/=dist,perpx*=width,perpy*=width,perp1x=-(y1-y2),perp1y=x1-x2,dist=Math.sqrt(perp1x*perp1x+perp1y*perp1y),perp1x/=dist,perp1y/=dist,perp1x*=width,perp1y*=width;const dx0=x1-x0,dy0=y0-y1,dx1=x1-x2,dy1=y2-y1,dot=dx0*dx1+dy0*dy1,cross=dy0*dx1-dy1*dx0,clockwise=cross<0;if(Math.abs(cross)<.001*Math.abs(dot)){verts.push(x1-perpx*innerWeight,y1-perpy*innerWeight,x1+perpx*outerWeight,y1+perpy*outerWeight),dot>=0&&(style.join===LINE_JOIN.ROUND?indexCount+=round(x1,y1,x1-perpx*innerWeight,y1-perpy*innerWeight,x1-perp1x*innerWeight,y1-perp1y*innerWeight,verts,!1)+4:indexCount+=2,verts.push(x1-perp1x*outerWeight,y1-perp1y*outerWeight,x1+perp1x*innerWeight,y1+perp1y*innerWeight));continue}const c1=(-perpx+x0)*(-perpy+y1)-(-perpx+x1)*(-perpy+y0),c2=(-perp1x+x2)*(-perp1y+y1)-(-perp1x+x1)*(-perp1y+y2),px=(dx0*c2-dx1*c1)/cross,py=(dy1*c1-dy0*c2)/cross,pdist=(px-x1)*(px-x1)+(py-y1)*(py-y1),imx=x1+(px-x1)*innerWeight,imy=y1+(py-y1)*innerWeight,omx=x1-(px-x1)*outerWeight,omy=y1-(py-y1)*outerWeight,insideWeight=clockwise?innerWeight:outerWeight,insideMiterOk=pdist<=Math.min(dx0*dx0+dy0*dy0,dx1*dx1+dy1*dy1)+insideWeight*insideWeight*widthSquared;let join=style.join;if(join===LINE_JOIN.MITER&&pdist/widthSquared>miterLimitSquared&&(join=LINE_JOIN.BEVEL),insideMiterOk)switch(join){case LINE_JOIN.MITER:verts.push(imx,imy,omx,omy);break;case LINE_JOIN.BEVEL:clockwise?verts.push(imx,imy,x1+perpx*outerWeight,y1+perpy*outerWeight,imx,imy,x1+perp1x*outerWeight,y1+perp1y*outerWeight):verts.push(x1-perpx*innerWeight,y1-perpy*innerWeight,omx,omy,x1-perp1x*innerWeight,y1-perp1y*innerWeight,omx,omy),indexCount+=2;break;case LINE_JOIN.ROUND:clockwise?(verts.push(imx,imy,x1+perpx*outerWeight,y1+perpy*outerWeight),indexCount+=round(x1,y1,x1+perpx*outerWeight,y1+perpy*outerWeight,x1+perp1x*outerWeight,y1+perp1y*outerWeight,verts,!0)+4,verts.push(imx,imy,x1+perp1x*outerWeight,y1+perp1y*outerWeight)):(verts.push(x1-perpx*innerWeight,y1-perpy*innerWeight,omx,omy),indexCount+=round(x1,y1,x1-perpx*innerWeight,y1-perpy*innerWeight,x1-perp1x*innerWeight,y1-perp1y*innerWeight,verts,!1)+4,verts.push(x1-perp1x*innerWeight,y1-perp1y*innerWeight,omx,omy))}else{switch(verts.push(x1-perpx*innerWeight,y1-perpy*innerWeight,x1+perpx*outerWeight,y1+perpy*outerWeight),join){case LINE_JOIN.MITER:clockwise?verts.push(omx,omy,omx,omy):verts.push(imx,imy,imx,imy),indexCount+=2;break;case LINE_JOIN.ROUND:indexCount+=clockwise?round(x1,y1,x1+perpx*outerWeight,y1+perpy*outerWeight,x1+perp1x*outerWeight,y1+perp1y*outerWeight,verts,!0)+2:round(x1,y1,x1-perpx*innerWeight,y1-perpy*innerWeight,x1-perp1x*innerWeight,y1-perp1y*innerWeight,verts,!1)+2}verts.push(x1-perp1x*innerWeight,y1-perp1y*innerWeight,x1+perp1x*outerWeight,y1+perp1y*outerWeight),indexCount+=2}}x0=points[2*(length-2)],y0=points[2*(length-2)+1],x1=points[2*(length-1)],y1=points[2*(length-1)+1],perpx=-(y0-y1),perpy=x0-x1,dist=Math.sqrt(perpx*perpx+perpy*perpy),perpx/=dist,perpy/=dist,perpx*=width,perpy*=width,verts.push(x1-perpx*innerWeight,y1-perpy*innerWeight,x1+perpx*outerWeight,y1+perpy*outerWeight),closedShape||(style.cap===LINE_CAP.ROUND?indexCount+=round(x1-perpx*(innerWeight-outerWeight)*.5,y1-perpy*(innerWeight-outerWeight)*.5,x1-perpx*innerWeight,y1-perpy*innerWeight,x1+perpx*outerWeight,y1+perpy*outerWeight,verts,!1)+2:style.cap===LINE_CAP.SQUARE&&(indexCount+=square(x1,y1,perpx,perpy,innerWeight,outerWeight,!1,verts)));const indices=graphicsGeometry.indices,eps2=curves.epsilon*curves.epsilon;for(let i=indexStart;i<indexCount+indexStart-2;++i)x0=verts[2*i],y0=verts[2*i+1],x1=verts[2*(i+1)],y1=verts[2*(i+1)+1],x2=verts[2*(i+2)],y2=verts[2*(i+2)+1],!(Math.abs(x0*(y1-y2)+x1*(y2-y0)+x2*(y0-y1))<eps2)&&indices.push(i,i+1,i+2)}(graphicsData,graphicsGeometry)}class QuadraticUtils{static curveLength(fromX,fromY,cpX,cpY,toX,toY){const ax=fromX-2*cpX+toX,ay=fromY-2*cpY+toY,bx=2*cpX-2*fromX,by=2*cpY-2*fromY,a=4*(ax*ax+ay*ay),b=4*(ax*bx+ay*by),c=bx*bx+by*by,s=2*Math.sqrt(a+b+c),a2=Math.sqrt(a),a32=2*a*a2,c2=2*Math.sqrt(c),ba=b/a2;return(a32*s+a2*b*(s-c2)+(4*c*a-b*b)*Math.log((2*a2+ba+s)/(ba+c2)))/(4*a32)}static curveTo(cpX,cpY,toX,toY,points){const fromX=points[points.length-2],fromY=points[points.length-1],n=curves._segmentsCount(QuadraticUtils.curveLength(fromX,fromY,cpX,cpY,toX,toY));let xa=0,ya=0;for(let i=1;i<=n;++i){const j=i/n;xa=fromX+(cpX-fromX)*j,ya=fromY+(cpY-fromY)*j,points.push(xa+(cpX+(toX-cpX)*j-xa)*j,ya+(cpY+(toY-cpY)*j-ya)*j)}}}const FILL_COMMANDS={[lib.HS.POLY]:buildPoly,[lib.HS.CIRC]:buildCircle,[lib.HS.ELIP]:buildCircle,[lib.HS.RECT]:buildRectangle,[lib.HS.RREC]:buildRoundedRectangle},BATCH_POOL=[],DRAW_CALL_POOL=[];var display_lib=__webpack_require__("./node_modules/@pixi/display/lib/index.mjs");class GraphicsData{constructor(shape,fillStyle=null,lineStyle=null,matrix=null){this.points=[],this.holes=[],this.shape=shape,this.lineStyle=lineStyle,this.fillStyle=fillStyle,this.matrix=matrix,this.type=shape.type}clone(){return new GraphicsData(this.shape,this.fillStyle,this.lineStyle,this.matrix)}destroy(){this.shape=null,this.holes.length=0,this.holes=null,this.points.length=0,this.points=null,this.lineStyle=null,this.fillStyle=null}}class BatchPart{constructor(){this.reset()}begin(style,startIndex,attribStart){this.reset(),this.style=style,this.start=startIndex,this.attribStart=attribStart}end(endIndex,endAttrib){this.attribSize=endAttrib-this.attribStart,this.size=endIndex-this.start}reset(){this.style=null,this.size=0,this.start=0,this.attribStart=0,this.attribSize=0}}const tmpPoint=new lib.E9,_GraphicsGeometry=class _GraphicsGeometry2 extends lib.JZ{constructor(){super(),this.closePointEps=1e-4,this.boundsPadding=0,this.uvsFloat32=null,this.indicesUint16=null,this.batchable=!1,this.points=[],this.colors=[],this.uvs=[],this.indices=[],this.textureIds=[],this.graphicsData=[],this.drawCalls=[],this.batchDirty=-1,this.batches=[],this.dirty=0,this.cacheDirty=-1,this.clearDirty=0,this.shapeIndex=0,this._bounds=new display_lib.YZ,this.boundsDirty=-1}get bounds(){return this.updateBatches(),this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds}invalidate(){this.boundsDirty=-1,this.dirty++,this.batchDirty++,this.shapeIndex=0,this.points.length=0,this.colors.length=0,this.uvs.length=0,this.indices.length=0,this.textureIds.length=0;for(let i=0;i<this.drawCalls.length;i++)this.drawCalls[i].texArray.clear(),DRAW_CALL_POOL.push(this.drawCalls[i]);this.drawCalls.length=0;for(let i=0;i<this.batches.length;i++){const batchPart=this.batches[i];batchPart.reset(),BATCH_POOL.push(batchPart)}this.batches.length=0}clear(){return this.graphicsData.length>0&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this}drawShape(shape,fillStyle=null,lineStyle=null,matrix=null){const data=new GraphicsData(shape,fillStyle,lineStyle,matrix);return this.graphicsData.push(data),this.dirty++,this}drawHole(shape,matrix=null){if(!this.graphicsData.length)return null;const data=new GraphicsData(shape,null,null,matrix),lastShape=this.graphicsData[this.graphicsData.length-1];return data.lineStyle=lastShape.lineStyle,lastShape.holes.push(data),this.dirty++,this}destroy(){super.destroy();for(let i=0;i<this.graphicsData.length;++i)this.graphicsData[i].destroy();this.points.length=0,this.points=null,this.colors.length=0,this.colors=null,this.uvs.length=0,this.uvs=null,this.indices.length=0,this.indices=null,this.indexBuffer.destroy(),this.indexBuffer=null,this.graphicsData.length=0,this.graphicsData=null,this.drawCalls.length=0,this.drawCalls=null,this.batches.length=0,this.batches=null,this._bounds=null}containsPoint(point){const graphicsData=this.graphicsData;for(let i=0;i<graphicsData.length;++i){const data=graphicsData[i];if(data.fillStyle.visible&&data.shape&&(data.matrix?data.matrix.applyInverse(point,tmpPoint):tmpPoint.copyFrom(point),data.shape.contains(tmpPoint.x,tmpPoint.y))){let hitHole=!1;if(data.holes)for(let i2=0;i2<data.holes.length;i2++)if(data.holes[i2].shape.contains(tmpPoint.x,tmpPoint.y)){hitHole=!0;break}if(!hitHole)return!0}}return!1}updateBatches(){if(!this.graphicsData.length)return void(this.batchable=!0);if(!this.validateBatching())return;this.cacheDirty=this.dirty;const uvs=this.uvs,graphicsData=this.graphicsData;let batchPart=null,currentStyle=null;this.batches.length>0&&(batchPart=this.batches[this.batches.length-1],currentStyle=batchPart.style);for(let i=this.shapeIndex;i<graphicsData.length;i++){this.shapeIndex++;const data=graphicsData[i],fillStyle=data.fillStyle,lineStyle=data.lineStyle;FILL_COMMANDS[data.type].build(data),data.matrix&&this.transformPoints(data.points,data.matrix),(fillStyle.visible||lineStyle.visible)&&this.processHoles(data.holes);for(let j=0;j<2;j++){const style=0===j?fillStyle:lineStyle;if(!style.visible)continue;const nextTexture=style.texture.baseTexture,index2=this.indices.length,attribIndex=this.points.length/2;nextTexture.wrapMode=lib.Nt.REPEAT,0===j?this.processFill(data):this.processLine(data);const size=this.points.length/2-attribIndex;0!==size&&(batchPart&&!this._compareStyles(currentStyle,style)&&(batchPart.end(index2,attribIndex),batchPart=null),batchPart||(batchPart=BATCH_POOL.pop()||new BatchPart,batchPart.begin(style,index2,attribIndex),this.batches.push(batchPart),currentStyle=style),this.addUvs(this.points,uvs,style.texture,attribIndex,size,style.matrix))}}const index=this.indices.length,attrib=this.points.length/2;if(batchPart&&batchPart.end(index,attrib),0===this.batches.length)return void(this.batchable=!0);const need32=attrib>65535;this.indicesUint16&&this.indices.length===this.indicesUint16.length&&need32===this.indicesUint16.BYTES_PER_ELEMENT>2?this.indicesUint16.set(this.indices):this.indicesUint16=need32?new Uint32Array(this.indices):new Uint16Array(this.indices),this.batchable=this.isBatchable(),this.batchable?this.packBatches():this.buildDrawCalls()}_compareStyles(styleA,styleB){return!(!styleA||!styleB||styleA.texture.baseTexture!==styleB.texture.baseTexture||styleA.color+styleA.alpha!==styleB.color+styleB.alpha||!!styleA.native!=!!styleB.native)}validateBatching(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(let i=0,l=this.graphicsData.length;i<l;i++){const data=this.graphicsData[i],fill=data.fillStyle,line=data.lineStyle;if(fill&&!fill.texture.baseTexture.valid||line&&!line.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++,this.uvsFloat32=new Float32Array(this.uvs);const batches=this.batches;for(let i=0,l=batches.length;i<l;i++){const batch=batches[i];for(let j=0;j<batch.size;j++){const index=batch.start+j;this.indicesUint16[index]=this.indicesUint16[index]-batch.attribStart}}}isBatchable(){if(this.points.length>131070)return!1;const batches=this.batches;for(let i=0;i<batches.length;i++)if(batches[i].style.native)return!1;return this.points.length<2*_GraphicsGeometry2.BATCHABLE_SIZE}buildDrawCalls(){let TICK=++lib.VL._globalBatch;for(let i=0;i<this.drawCalls.length;i++)this.drawCalls[i].texArray.clear(),DRAW_CALL_POOL.push(this.drawCalls[i]);this.drawCalls.length=0;const colors=this.colors,textureIds=this.textureIds;let currentGroup=DRAW_CALL_POOL.pop();currentGroup||(currentGroup=new lib.a$,currentGroup.texArray=new lib.Ie),currentGroup.texArray.count=0,currentGroup.start=0,currentGroup.size=0,currentGroup.type=lib.lg.TRIANGLES;let textureCount=0,currentTexture=null,textureId=0,native=!1,drawMode=lib.lg.TRIANGLES,index=0;this.drawCalls.push(currentGroup);for(let i=0;i<this.batches.length;i++){const data=this.batches[i],maxTextures=8,style=data.style,nextTexture=style.texture.baseTexture;native!==!!style.native&&(native=!!style.native,drawMode=native?lib.lg.LINES:lib.lg.TRIANGLES,currentTexture=null,textureCount=maxTextures,TICK++),currentTexture!==nextTexture&&(currentTexture=nextTexture,nextTexture._batchEnabled!==TICK&&(textureCount===maxTextures&&(TICK++,textureCount=0,currentGroup.size>0&&(currentGroup=DRAW_CALL_POOL.pop(),currentGroup||(currentGroup=new lib.a$,currentGroup.texArray=new lib.Ie),this.drawCalls.push(currentGroup)),currentGroup.start=index,currentGroup.size=0,currentGroup.texArray.count=0,currentGroup.type=drawMode),nextTexture.touched=1,nextTexture._batchEnabled=TICK,nextTexture._batchLocation=textureCount,nextTexture.wrapMode=lib.Nt.REPEAT,currentGroup.texArray.elements[currentGroup.texArray.count++]=nextTexture,textureCount++)),currentGroup.size+=data.size,index+=data.size,textureId=nextTexture._batchLocation,this.addColors(colors,style.color,style.alpha,data.attribSize,data.attribStart),this.addTextureIds(textureIds,textureId,data.attribSize,data.attribStart)}lib.VL._globalBatch=TICK,this.packAttributes()}packAttributes(){const verts=this.points,uvs=this.uvs,colors=this.colors,textureIds=this.textureIds,glPoints=new ArrayBuffer(3*verts.length*4),f32=new Float32Array(glPoints),u32=new Uint32Array(glPoints);let p=0;for(let i=0;i<verts.length/2;i++)f32[p++]=verts[2*i],f32[p++]=verts[2*i+1],f32[p++]=uvs[2*i],f32[p++]=uvs[2*i+1],u32[p++]=colors[i],f32[p++]=textureIds[i];this._buffer.update(glPoints),this._indexBuffer.update(this.indicesUint16)}processFill(data){data.holes.length?buildPoly.triangulate(data,this):FILL_COMMANDS[data.type].triangulate(data,this)}processLine(data){buildLine(data,this);for(let i=0;i<data.holes.length;i++)buildLine(data.holes[i],this)}processHoles(holes){for(let i=0;i<holes.length;i++){const hole=holes[i];FILL_COMMANDS[hole.type].build(hole),hole.matrix&&this.transformPoints(hole.points,hole.matrix)}}calculateBounds(){const bounds=this._bounds;bounds.clear(),bounds.addVertexData(this.points,0,this.points.length),bounds.pad(this.boundsPadding,this.boundsPadding)}transformPoints(points,matrix){for(let i=0;i<points.length/2;i++){const x=points[2*i],y=points[2*i+1];points[2*i]=matrix.a*x+matrix.c*y+matrix.tx,points[2*i+1]=matrix.b*x+matrix.d*y+matrix.ty}}addColors(colors,color,alpha,size,offset=0){const bgr=lib.Il.shared.setValue(color).toLittleEndianNumber(),result=lib.Il.shared.setValue(bgr).toPremultiplied(alpha);colors.length=Math.max(colors.length,offset+size);for(let i=0;i<size;i++)colors[offset+i]=result}addTextureIds(textureIds,id,size,offset=0){textureIds.length=Math.max(textureIds.length,offset+size);for(let i=0;i<size;i++)textureIds[offset+i]=id}addUvs(verts,uvs,texture,start,size,matrix=null){let index=0;const uvsStart=uvs.length,frame=texture.frame;for(;index<size;){let x=verts[2*(start+index)],y=verts[2*(start+index)+1];if(matrix){const nx=matrix.a*x+matrix.c*y+matrix.tx;y=matrix.b*x+matrix.d*y+matrix.ty,x=nx}index++,uvs.push(x/frame.width,y/frame.height)}const baseTexture=texture.baseTexture;(frame.width<baseTexture.width||frame.height<baseTexture.height)&&this.adjustUvs(uvs,texture,uvsStart,size)}adjustUvs(uvs,texture,start,size){const baseTexture=texture.baseTexture,eps=1e-6,finish=start+2*size,frame=texture.frame,scaleX=frame.width/baseTexture.width,scaleY=frame.height/baseTexture.height;let offsetX=frame.x/frame.width,offsetY=frame.y/frame.height,minX=Math.floor(uvs[start]+eps),minY=Math.floor(uvs[start+1]+eps);for(let i=start+2;i<finish;i+=2)minX=Math.min(minX,Math.floor(uvs[i]+eps)),minY=Math.min(minY,Math.floor(uvs[i+1]+eps));offsetX-=minX,offsetY-=minY;for(let i=start;i<finish;i+=2)uvs[i]=(uvs[i]+offsetX)*scaleX,uvs[i+1]=(uvs[i+1]+offsetY)*scaleY}};_GraphicsGeometry.BATCHABLE_SIZE=100;let GraphicsGeometry=_GraphicsGeometry;class FillStyle{constructor(){this.color=16777215,this.alpha=1,this.texture=lib.xE.WHITE,this.matrix=null,this.visible=!1,this.reset()}clone(){const obj=new FillStyle;return obj.color=this.color,obj.alpha=this.alpha,obj.texture=this.texture,obj.matrix=this.matrix,obj.visible=this.visible,obj}reset(){this.color=16777215,this.alpha=1,this.texture=lib.xE.WHITE,this.matrix=null,this.visible=!1}destroy(){this.texture=null,this.matrix=null}}class LineStyle extends FillStyle{constructor(){super(...arguments),this.width=0,this.alignment=.5,this.native=!1,this.cap=LINE_CAP.BUTT,this.join=LINE_JOIN.MITER,this.miterLimit=10}clone(){const obj=new LineStyle;return obj.color=this.color,obj.alpha=this.alpha,obj.texture=this.texture,obj.matrix=this.matrix,obj.visible=this.visible,obj.width=this.width,obj.alignment=this.alignment,obj.native=this.native,obj.cap=this.cap,obj.join=this.join,obj.miterLimit=this.miterLimit,obj}reset(){super.reset(),this.color=0,this.alignment=.5,this.width=0,this.native=!1,this.cap=LINE_CAP.BUTT,this.join=LINE_JOIN.MITER,this.miterLimit=10}}const DEFAULT_SHADERS={},_Graphics=class _Graphics2 extends display_lib.W2{constructor(geometry=null){super(),this.shader=null,this.pluginName="batch",this.currentPath=null,this.batches=[],this.batchTint=-1,this.batchDirty=-1,this.vertexData=null,this._fillStyle=new FillStyle,this._lineStyle=new LineStyle,this._matrix=null,this._holeMode=!1,this.state=lib.ZM.for2d(),this._geometry=geometry||new GraphicsGeometry,this._geometry.refCount++,this._transformID=-1,this._tintColor=new lib.Il(16777215),this.blendMode=lib.T$.NORMAL}get geometry(){return this._geometry}clone(){return this.finishPoly(),new _Graphics2(this._geometry)}set blendMode(value){this.state.blendMode=value}get blendMode(){return this.state.blendMode}get tint(){return this._tintColor.value}set tint(value){this._tintColor.setValue(value)}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(options=null,color=0,alpha,alignment=.5,native=!1){return"number"==typeof options&&(options={width:options,color,alpha,alignment,native}),this.lineTextureStyle(options)}lineTextureStyle(options){const defaultLineStyleOptions={width:0,texture:lib.xE.WHITE,color:options?.texture?16777215:0,matrix:null,alignment:.5,native:!1,cap:LINE_CAP.BUTT,join:LINE_JOIN.MITER,miterLimit:10};options=Object.assign(defaultLineStyleOptions,options),this.normalizeColor(options),this.currentPath&&this.startPoly();const visible=options.width>0&&options.alpha>0;return visible?(options.matrix&&(options.matrix=options.matrix.clone(),options.matrix.invert()),Object.assign(this._lineStyle,{visible},options)):this._lineStyle.reset(),this}startPoly(){if(this.currentPath){const points=this.currentPath.points,len=this.currentPath.points.length;len>2&&(this.drawShape(this.currentPath),this.currentPath=new lib.mg,this.currentPath.closeStroke=!1,this.currentPath.points.push(points[len-2],points[len-1]))}else this.currentPath=new lib.mg,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(this.currentPath.points.length>2?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(x,y){return this.startPoly(),this.currentPath.points[0]=x,this.currentPath.points[1]=y,this}lineTo(x,y){this.currentPath||this.moveTo(0,0);const points=this.currentPath.points,fromX=points[points.length-2],fromY=points[points.length-1];return(fromX!==x||fromY!==y)&&points.push(x,y),this}_initCurve(x=0,y=0){this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[x,y]):this.moveTo(x,y)}quadraticCurveTo(cpX,cpY,toX,toY){this._initCurve();const points=this.currentPath.points;return 0===points.length&&this.moveTo(0,0),QuadraticUtils.curveTo(cpX,cpY,toX,toY,points),this}bezierCurveTo(cpX,cpY,cpX2,cpY2,toX,toY){return this._initCurve(),BezierUtils.curveTo(cpX,cpY,cpX2,cpY2,toX,toY,this.currentPath.points),this}arcTo(x1,y1,x2,y2,radius){this._initCurve(x1,y1);const points=this.currentPath.points,result=ArcUtils.curveTo(x1,y1,x2,y2,radius,points);if(result){const{cx,cy,radius:radius2,startAngle,endAngle,anticlockwise}=result;this.arc(cx,cy,radius2,startAngle,endAngle,anticlockwise)}return this}arc(cx,cy,radius,startAngle,endAngle,anticlockwise=!1){if(startAngle===endAngle)return this;if(!anticlockwise&&endAngle<=startAngle?endAngle+=lib._b:anticlockwise&&startAngle<=endAngle&&(startAngle+=lib._b),endAngle-startAngle==0)return this;const startX=cx+Math.cos(startAngle)*radius,startY=cy+Math.sin(startAngle)*radius,eps=this._geometry.closePointEps;let points=this.currentPath?this.currentPath.points:null;if(points){const xDiff=Math.abs(points[points.length-2]-startX),yDiff=Math.abs(points[points.length-1]-startY);xDiff<eps&&yDiff<eps||points.push(startX,startY)}else this.moveTo(startX,startY),points=this.currentPath.points;return ArcUtils.arc(startX,startY,cx,cy,radius,startAngle,endAngle,anticlockwise,points),this}beginFill(color=0,alpha){return this.beginTextureFill({texture:lib.xE.WHITE,color,alpha})}normalizeColor(options){const temp=lib.Il.shared.setValue(options.color??0);options.color=temp.toNumber(),options.alpha??(options.alpha=temp.alpha)}beginTextureFill(options){const defaultOptions={texture:lib.xE.WHITE,color:16777215,matrix:null};options=Object.assign(defaultOptions,options),this.normalizeColor(options),this.currentPath&&this.startPoly();const visible=options.alpha>0;return visible?(options.matrix&&(options.matrix=options.matrix.clone(),options.matrix.invert()),Object.assign(this._fillStyle,{visible},options)):this._fillStyle.reset(),this}endFill(){return this.finishPoly(),this._fillStyle.reset(),this}drawRect(x,y,width,height){return this.drawShape(new lib.Ae(x,y,width,height))}drawRoundedRect(x,y,width,height,radius){return this.drawShape(new lib.c9(x,y,width,height,radius))}drawCircle(x,y,radius){return this.drawShape(new lib.Cd(x,y,radius))}drawEllipse(x,y,width,height){return this.drawShape(new lib.Pj(x,y,width,height))}drawPolygon(...path){let points,closeStroke=!0;const poly=path[0];poly.points?(closeStroke=poly.closeStroke,points=poly.points):points=Array.isArray(path[0])?path[0]:path;const shape=new lib.mg(points);return shape.closeStroke=closeStroke,this.drawShape(shape),this}drawShape(shape){return this._holeMode?this._geometry.drawHole(shape,this._matrix):this._geometry.drawShape(shape,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this}clear(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this}isFastRect(){const data=this._geometry.graphicsData;return!(1!==data.length||data[0].shape.type!==lib.HS.RECT||data[0].matrix||data[0].holes.length||data[0].lineStyle.visible&&data[0].lineStyle.width)}_render(renderer){this.finishPoly();const geometry=this._geometry;geometry.updateBatches(),geometry.batchable?(this.batchDirty!==geometry.batchDirty&&this._populateBatches(),this._renderBatched(renderer)):(renderer.batch.flush(),this._renderDirect(renderer))}_populateBatches(){const geometry=this._geometry,blendMode=this.blendMode,len=geometry.batches.length;this.batchTint=-1,this._transformID=-1,this.batchDirty=geometry.batchDirty,this.batches.length=len,this.vertexData=new Float32Array(geometry.points);for(let i=0;i<len;i++){const gI=geometry.batches[i],color=gI.style.color,vertexData=new Float32Array(this.vertexData.buffer,4*gI.attribStart*2,2*gI.attribSize),uvs=new Float32Array(geometry.uvsFloat32.buffer,4*gI.attribStart*2,2*gI.attribSize),batch={vertexData,blendMode,indices:new Uint16Array(geometry.indicesUint16.buffer,2*gI.start,gI.size),uvs,_batchRGB:lib.Il.shared.setValue(color).toRgbArray(),_tintRGB:color,_texture:gI.style.texture,alpha:gI.style.alpha,worldAlpha:1};this.batches[i]=batch}}_renderBatched(renderer){if(this.batches.length){renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]),this.calculateVertices(),this.calculateTints();for(let i=0,l=this.batches.length;i<l;i++){const batch=this.batches[i];batch.worldAlpha=this.worldAlpha*batch.alpha,renderer.plugins[this.pluginName].render(batch)}}}_renderDirect(renderer){const shader=this._resolveDirectShader(renderer),geometry=this._geometry,worldAlpha=this.worldAlpha,uniforms=shader.uniforms,drawCalls=geometry.drawCalls;uniforms.translationMatrix=this.transform.worldTransform,lib.Il.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint),renderer.shader.bind(shader),renderer.geometry.bind(geometry,shader),renderer.state.set(this.state);for(let i=0,l=drawCalls.length;i<l;i++)this._renderDrawCallDirect(renderer,geometry.drawCalls[i])}_renderDrawCallDirect(renderer,drawCall){const{texArray,type,size,start}=drawCall,groupTextureCount=texArray.count;for(let j=0;j<groupTextureCount;j++)renderer.texture.bind(texArray.elements[j],j);renderer.geometry.draw(type,size,start)}_resolveDirectShader(renderer){let shader=this.shader;const pluginName=this.pluginName;if(!shader){if(!DEFAULT_SHADERS[pluginName]){const{maxTextures}=renderer.plugins[pluginName],sampleValues=new Int32Array(maxTextures);for(let i=0;i<maxTextures;i++)sampleValues[i]=i;const uniforms={tint:new Float32Array([1,1,1,1]),translationMatrix:new lib.y3,default:lib.oo.from({uSamplers:sampleValues},!0)},program=renderer.plugins[pluginName]._shader.program;DEFAULT_SHADERS[pluginName]=new lib.ex(program,uniforms)}shader=DEFAULT_SHADERS[pluginName]}return shader}_calculateBounds(){this.finishPoly();const geometry=this._geometry;if(!geometry.graphicsData.length)return;const{minX,minY,maxX,maxY}=geometry.bounds;this._bounds.addFrame(this.transform,minX,minY,maxX,maxY)}containsPoint(point){return this.worldTransform.applyInverse(point,_Graphics2._TEMP_POINT),this._geometry.containsPoint(_Graphics2._TEMP_POINT)}calculateTints(){if(this.batchTint!==this.tint){this.batchTint=this._tintColor.toNumber();for(let i=0;i<this.batches.length;i++){const batch=this.batches[i];batch._tintRGB=lib.Il.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber()}}}calculateVertices(){const wtID=this.transform._worldID;if(this._transformID===wtID)return;this._transformID=wtID;const wt=this.transform.worldTransform,a=wt.a,b=wt.b,c=wt.c,d=wt.d,tx=wt.tx,ty=wt.ty,data=this._geometry.points,vertexData=this.vertexData;let count=0;for(let i=0;i<data.length;i+=2){const x=data[i],y=data[i+1];vertexData[count++]=a*x+c*y+tx,vertexData[count++]=d*y+b*x+ty}}closePath(){const currentPath=this.currentPath;return currentPath&&(currentPath.closeStroke=!0,this.finishPoly()),this}setMatrix(matrix){return this._matrix=matrix,this}beginHole(){return this.finishPoly(),this._holeMode=!0,this}endHole(){return this.finishPoly(),this._holeMode=!1,this}destroy(options){this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose(),this._matrix=null,this.currentPath=null,this._lineStyle.destroy(),this._lineStyle=null,this._fillStyle.destroy(),this._fillStyle=null,this._geometry=null,this.shader=null,this.vertexData=null,this.batches.length=0,this.batches=null,super.destroy(options)}};_Graphics.curves=curves,_Graphics._TEMP_POINT=new lib.E9;let Graphics=_Graphics}}]);