"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[345],{"./node_modules/@pixi/text-bitmap/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{UP:()=>BitmapFont,Xz:()=>BitmapText});var lib=__webpack_require__("./node_modules/@pixi/core/lib/index.mjs"),text_lib=__webpack_require__("./node_modules/@pixi/text/lib/index.mjs");class BitmapFontData{constructor(){this.info=[],this.common=[],this.page=[],this.char=[],this.kerning=[],this.distanceField=[]}}class TextFormat{static test(data){return"string"==typeof data&&data.startsWith("info face=")}static parse(txt){const items=txt.match(/^[a-z]+\s+.+$/gm),rawData={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const i in items){const name=items[i].match(/^[a-z]+/gm)[0],attributeList=items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),itemData={};for(const i2 in attributeList){const split=attributeList[i2].split("="),key=split[0],strValue=split[1].replace(/"/gm,""),floatValue=parseFloat(strValue),value=isNaN(floatValue)?strValue:floatValue;itemData[key]=value}rawData[name].push(itemData)}const font=new BitmapFontData;return rawData.info.forEach((info=>font.info.push({face:info.face,size:parseInt(info.size,10)}))),rawData.common.forEach((common=>font.common.push({lineHeight:parseInt(common.lineHeight,10)}))),rawData.page.forEach((page=>font.page.push({id:parseInt(page.id,10),file:page.file}))),rawData.char.forEach((char=>font.char.push({id:parseInt(char.id,10),page:parseInt(char.page,10),x:parseInt(char.x,10),y:parseInt(char.y,10),width:parseInt(char.width,10),height:parseInt(char.height,10),xoffset:parseInt(char.xoffset,10),yoffset:parseInt(char.yoffset,10),xadvance:parseInt(char.xadvance,10)}))),rawData.kerning.forEach((kerning=>font.kerning.push({first:parseInt(kerning.first,10),second:parseInt(kerning.second,10),amount:parseInt(kerning.amount,10)}))),rawData.distanceField.forEach((df=>font.distanceField.push({distanceRange:parseInt(df.distanceRange,10),fieldType:df.fieldType}))),font}}class XMLFormat{static test(data){const xml=data;return"string"!=typeof data&&"getElementsByTagName"in data&&xml.getElementsByTagName("page").length&&null!==xml.getElementsByTagName("info")[0].getAttribute("face")}static parse(xml){const data=new BitmapFontData,info=xml.getElementsByTagName("info"),common=xml.getElementsByTagName("common"),page=xml.getElementsByTagName("page"),char=xml.getElementsByTagName("char"),kerning=xml.getElementsByTagName("kerning"),distanceField=xml.getElementsByTagName("distanceField");for(let i=0;i<info.length;i++)data.info.push({face:info[i].getAttribute("face"),size:parseInt(info[i].getAttribute("size"),10)});for(let i=0;i<common.length;i++)data.common.push({lineHeight:parseInt(common[i].getAttribute("lineHeight"),10)});for(let i=0;i<page.length;i++)data.page.push({id:parseInt(page[i].getAttribute("id"),10)||0,file:page[i].getAttribute("file")});for(let i=0;i<char.length;i++){const letter=char[i];data.char.push({id:parseInt(letter.getAttribute("id"),10),page:parseInt(letter.getAttribute("page"),10)||0,x:parseInt(letter.getAttribute("x"),10),y:parseInt(letter.getAttribute("y"),10),width:parseInt(letter.getAttribute("width"),10),height:parseInt(letter.getAttribute("height"),10),xoffset:parseInt(letter.getAttribute("xoffset"),10),yoffset:parseInt(letter.getAttribute("yoffset"),10),xadvance:parseInt(letter.getAttribute("xadvance"),10)})}for(let i=0;i<kerning.length;i++)data.kerning.push({first:parseInt(kerning[i].getAttribute("first"),10),second:parseInt(kerning[i].getAttribute("second"),10),amount:parseInt(kerning[i].getAttribute("amount"),10)});for(let i=0;i<distanceField.length;i++)data.distanceField.push({fieldType:distanceField[i].getAttribute("fieldType"),distanceRange:parseInt(distanceField[i].getAttribute("distanceRange"),10)});return data}}class XMLStringFormat{static test(data){return!("string"!=typeof data||!data.includes("<font>"))&&XMLFormat.test(lib.Xd.ADAPTER.parseXML(data))}static parse(xmlTxt){return XMLFormat.parse(lib.Xd.ADAPTER.parseXML(xmlTxt))}}const formats=[TextFormat,XMLFormat,XMLStringFormat];function drawGlyph(canvas,context,metrics,x,y,resolution,style){const char=metrics.text,fontProperties=metrics.fontProperties;context.translate(x,y),context.scale(resolution,resolution);const tx=style.strokeThickness/2,ty=-style.strokeThickness/2;if(context.font=style.toFontString(),context.lineWidth=style.strokeThickness,context.textBaseline=style.textBaseline,context.lineJoin=style.lineJoin,context.miterLimit=style.miterLimit,context.fillStyle=function generateFillStyle(canvas,context,style,resolution,lines,metrics){const fillStyle=style.fill;if(!Array.isArray(fillStyle))return fillStyle;if(1===fillStyle.length)return fillStyle[0];let gradient;const dropShadowCorrection=style.dropShadow?style.dropShadowDistance:0,padding=style.padding||0,width=canvas.width/resolution-dropShadowCorrection-2*padding,height=canvas.height/resolution-dropShadowCorrection-2*padding,fill=fillStyle.slice(),fillGradientStops=style.fillGradientStops.slice();if(!fillGradientStops.length){const lengthPlus1=fill.length+1;for(let i=1;i<lengthPlus1;++i)fillGradientStops.push(i/lengthPlus1)}if(fill.unshift(fillStyle[0]),fillGradientStops.unshift(0),fill.push(fillStyle[fillStyle.length-1]),fillGradientStops.push(1),style.fillGradientType===text_lib.M_.LINEAR_VERTICAL){gradient=context.createLinearGradient(width/2,padding,width/2,height+padding);let lastIterationStop=0;const gradStopLineHeight=(metrics.fontProperties.fontSize+style.strokeThickness)/height;for(let i=0;i<lines.length;i++){const thisLineTop=metrics.lineHeight*i;for(let j=0;j<fill.length;j++){let lineStop=0;lineStop="number"==typeof fillGradientStops[j]?fillGradientStops[j]:j/fill.length;const globalStop=thisLineTop/height+lineStop*gradStopLineHeight;let clampedStop=Math.max(lastIterationStop,globalStop);clampedStop=Math.min(clampedStop,1),gradient.addColorStop(clampedStop,fill[j]),lastIterationStop=clampedStop}}}else{gradient=context.createLinearGradient(padding,height/2,width+padding,height/2);const totalIterations=fill.length+1;let currentIteration=1;for(let i=0;i<fill.length;i++){let stop;stop="number"==typeof fillGradientStops[i]?fillGradientStops[i]:currentIteration/totalIterations,gradient.addColorStop(stop,fill[i]),currentIteration++}}return gradient}(canvas,context,style,resolution,[char],metrics),context.strokeStyle=style.stroke,style.dropShadow){const dropShadowColor=style.dropShadowColor,dropShadowBlur=style.dropShadowBlur*resolution,dropShadowDistance=style.dropShadowDistance*resolution;context.shadowColor=lib.Il.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(),context.shadowBlur=dropShadowBlur,context.shadowOffsetX=Math.cos(style.dropShadowAngle)*dropShadowDistance,context.shadowOffsetY=Math.sin(style.dropShadowAngle)*dropShadowDistance}else context.shadowColor="black",context.shadowBlur=0,context.shadowOffsetX=0,context.shadowOffsetY=0;style.stroke&&style.strokeThickness&&context.strokeText(char,tx,ty+metrics.lineHeight-fontProperties.descent),style.fill&&context.fillText(char,tx,ty+metrics.lineHeight-fontProperties.descent),context.setTransform(1,0,0,1,0,0),context.fillStyle="rgba(0, 0, 0, 0)"}function splitTextToCharacters(text){return Array.from?Array.from(text):text.split("")}function extractCharCode(str){return str.codePointAt?str.codePointAt(0):str.charCodeAt(0)}const _BitmapFont=class _BitmapFont2{constructor(data,textures,ownsTextures){const[info]=data.info,[common]=data.common,[page]=data.page,[distanceField]=data.distanceField,res=lib.P6.getResolutionOfUrl(page.file),pageTextures={};this._ownsTextures=ownsTextures,this.font=info.face,this.size=info.size,this.lineHeight=common.lineHeight/res,this.chars={},this.pageTextures=pageTextures;for(let i=0;i<data.page.length;i++){const{id,file}=data.page[i];pageTextures[id]=textures instanceof Array?textures[i]:textures[file],distanceField?.fieldType&&"none"!==distanceField.fieldType&&(pageTextures[id].baseTexture.alphaMode=lib.iw.NO_PREMULTIPLIED_ALPHA,pageTextures[id].baseTexture.mipmap=lib.KI.OFF)}for(let i=0;i<data.char.length;i++){const{id,page:page2}=data.char[i];let{x,y,width,height,xoffset,yoffset,xadvance}=data.char[i];x/=res,y/=res,width/=res,height/=res,xoffset/=res,yoffset/=res,xadvance/=res;const rect=new lib.Ae(x+pageTextures[page2].frame.x/res,y+pageTextures[page2].frame.y/res,width,height);this.chars[id]={xOffset:xoffset,yOffset:yoffset,xAdvance:xadvance,kerning:{},texture:new lib.xE(pageTextures[page2].baseTexture,rect),page:page2}}for(let i=0;i<data.kerning.length;i++){let{first,second,amount}=data.kerning[i];first/=res,second/=res,amount/=res,this.chars[second]&&(this.chars[second].kerning[first]=amount)}this.distanceFieldRange=distanceField?.distanceRange,this.distanceFieldType=distanceField?.fieldType?.toLowerCase()??"none"}destroy(){for(const id in this.chars)this.chars[id].texture.destroy(),this.chars[id].texture=null;for(const id in this.pageTextures)this._ownsTextures&&this.pageTextures[id].destroy(!0),this.pageTextures[id]=null;this.chars=null,this.pageTextures=null}static install(data,textures,ownsTextures){let fontData;if(data instanceof BitmapFontData)fontData=data;else{const format=function autoDetectFormat(data){for(let i=0;i<formats.length;i++)if(formats[i].test(data))return formats[i];return null}(data);if(!format)throw new Error("Unrecognized data format for font.");fontData=format.parse(data)}textures instanceof lib.xE&&(textures=[textures]);const font=new _BitmapFont2(fontData,textures,ownsTextures);return _BitmapFont2.available[font.font]=font,font}static uninstall(name){const font=_BitmapFont2.available[name];if(!font)throw new Error(`No font found named '${name}'`);font.destroy(),delete _BitmapFont2.available[name]}static from(name,textStyle,options){if(!name)throw new Error("[BitmapFont] Property `name` is required.");const{chars,padding,resolution,textureWidth,textureHeight,...baseOptions}=Object.assign({},_BitmapFont2.defaultOptions,options),charsList=function resolveCharacters(chars){"string"==typeof chars&&(chars=[chars]);const result=[];for(let i=0,j=chars.length;i<j;i++){const item=chars[i];if(Array.isArray(item)){if(2!==item.length)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);const startCode=item[0].charCodeAt(0),endCode=item[1].charCodeAt(0);if(endCode<startCode)throw new Error("[BitmapFont]: Invalid character range.");for(let i2=startCode,j2=endCode;i2<=j2;i2++)result.push(String.fromCharCode(i2))}else result.push(...splitTextToCharacters(item))}if(0===result.length)throw new Error("[BitmapFont]: Empty set when resolving characters.");return result}(chars),style=textStyle instanceof text_lib.pn?textStyle:new text_lib.pn(textStyle),lineWidth=textureWidth,fontData=new BitmapFontData;fontData.info[0]={face:style.fontFamily,size:style.fontSize},fontData.common[0]={lineHeight:style.fontSize};let canvas,context,baseTexture,positionX=0,positionY=0,maxCharHeight=0;const baseTextures=[],textures=[];for(let i=0;i<charsList.length;i++){canvas||(canvas=lib.Xd.ADAPTER.createCanvas(),canvas.width=textureWidth,canvas.height=textureHeight,context=canvas.getContext("2d"),baseTexture=new lib.VL(canvas,{resolution,...baseOptions}),baseTextures.push(baseTexture),textures.push(new lib.xE(baseTexture)),fontData.page.push({id:textures.length-1,file:""}));const character=charsList[i],metrics=text_lib._A.measureText(character,style,!1,canvas),width=metrics.width,height=Math.ceil(metrics.height),textureGlyphWidth=Math.ceil(("italic"===style.fontStyle?2:1)*width);if(positionY>=textureHeight-height*resolution){if(0===positionY)throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);--i,canvas=null,context=null,baseTexture=null,positionY=0,positionX=0,maxCharHeight=0;continue}if(maxCharHeight=Math.max(height+metrics.fontProperties.descent,maxCharHeight),textureGlyphWidth*resolution+positionX>=lineWidth){if(0===positionX)throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);--i,positionY+=maxCharHeight*resolution,positionY=Math.ceil(positionY),positionX=0,maxCharHeight=0;continue}drawGlyph(canvas,context,metrics,positionX,positionY,resolution,style);const id=extractCharCode(metrics.text);fontData.char.push({id,page:textures.length-1,x:positionX/resolution,y:positionY/resolution,width:textureGlyphWidth,height,xoffset:0,yoffset:0,xadvance:width-(style.dropShadow?style.dropShadowDistance:0)-(style.stroke?style.strokeThickness:0)}),positionX+=(textureGlyphWidth+2*padding)*resolution,positionX=Math.ceil(positionX)}if(!options?.skipKerning)for(let i=0,len=charsList.length;i<len;i++){const first=charsList[i];for(let j=0;j<len;j++){const second=charsList[j],c1=context.measureText(first).width,c2=context.measureText(second).width,amount=context.measureText(first+second).width-(c1+c2);amount&&fontData.kerning.push({first:extractCharCode(first),second:extractCharCode(second),amount})}}const font=new _BitmapFont2(fontData,textures,!0);return void 0!==_BitmapFont2.available[name]&&_BitmapFont2.uninstall(name),_BitmapFont2.available[name]=font,font}};_BitmapFont.ALPHA=[["a","z"],["A","Z"]," "],_BitmapFont.NUMERIC=[["0","9"]],_BitmapFont.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],_BitmapFont.ASCII=[[" ","~"]],_BitmapFont.defaultOptions={resolution:1,textureWidth:512,textureHeight:512,padding:4,chars:_BitmapFont.ALPHANUMERIC},_BitmapFont.available={};let BitmapFont=_BitmapFont;var display_lib=__webpack_require__("./node_modules/@pixi/display/lib/index.mjs");class MeshBatchUvs{constructor(uvBuffer,uvMatrix){this.uvBuffer=uvBuffer,this.uvMatrix=uvMatrix,this.data=null,this._bufferUpdateId=-1,this._textureUpdateId=-1,this._updateID=0}update(forceUpdate){if(!forceUpdate&&this._bufferUpdateId===this.uvBuffer._updateID&&this._textureUpdateId===this.uvMatrix._updateID)return;this._bufferUpdateId=this.uvBuffer._updateID,this._textureUpdateId=this.uvMatrix._updateID;const data=this.uvBuffer.data;(!this.data||this.data.length!==data.length)&&(this.data=new Float32Array(data.length)),this.uvMatrix.multiplyUvs(data,this.data),this._updateID++}}const tempPoint=new lib.E9,tempPolygon=new lib.mg,_Mesh=class _Mesh2 extends display_lib.W2{constructor(geometry,shader,state,drawMode=lib.lg.TRIANGLES){super(),this.geometry=geometry,this.shader=shader,this.state=state||lib.ZM.for2d(),this.drawMode=drawMode,this.start=0,this.size=0,this.uvs=null,this.indices=null,this.vertexData=new Float32Array(1),this.vertexDirty=-1,this._transformID=-1,this._roundPixels=lib.Xd.ROUND_PIXELS,this.batchUvs=null}get geometry(){return this._geometry}set geometry(value){this._geometry!==value&&(this._geometry&&(this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose()),this._geometry=value,this._geometry&&this._geometry.refCount++,this.vertexDirty=-1)}get uvBuffer(){return this.geometry.buffers[1]}get verticesBuffer(){return this.geometry.buffers[0]}set material(value){this.shader=value}get material(){return this.shader}set blendMode(value){this.state.blendMode=value}get blendMode(){return this.state.blendMode}set roundPixels(value){this._roundPixels!==value&&(this._transformID=-1),this._roundPixels=value}get roundPixels(){return this._roundPixels}get tint(){return"tint"in this.shader?this.shader.tint:null}set tint(value){this.shader.tint=value}get tintValue(){return this.shader.tintValue}get texture(){return"texture"in this.shader?this.shader.texture:null}set texture(value){this.shader.texture=value}_render(renderer){const vertices=this.geometry.buffers[0].data;this.shader.batchable&&this.drawMode===lib.lg.TRIANGLES&&vertices.length<2*_Mesh2.BATCHABLE_SIZE?this._renderToBatch(renderer):this._renderDefault(renderer)}_renderDefault(renderer){const shader=this.shader;shader.alpha=this.worldAlpha,shader.update&&shader.update(),renderer.batch.flush(),shader.uniforms.translationMatrix=this.transform.worldTransform.toArray(!0),renderer.shader.bind(shader),renderer.state.set(this.state),renderer.geometry.bind(this.geometry,shader),renderer.geometry.draw(this.drawMode,this.size,this.start,this.geometry.instanceCount)}_renderToBatch(renderer){const geometry=this.geometry,shader=this.shader;shader.uvMatrix&&(shader.uvMatrix.update(),this.calculateUvs()),this.calculateVertices(),this.indices=geometry.indexBuffer.data,this._tintRGB=shader._tintRGB,this._texture=shader.texture;const pluginName=this.material.pluginName;renderer.batch.setObjectRenderer(renderer.plugins[pluginName]),renderer.plugins[pluginName].render(this)}calculateVertices(){const verticesBuffer=this.geometry.buffers[0],vertices=verticesBuffer.data,vertexDirtyId=verticesBuffer._updateID;if(vertexDirtyId===this.vertexDirty&&this._transformID===this.transform._worldID)return;this._transformID=this.transform._worldID,this.vertexData.length!==vertices.length&&(this.vertexData=new Float32Array(vertices.length));const wt=this.transform.worldTransform,a=wt.a,b=wt.b,c=wt.c,d=wt.d,tx=wt.tx,ty=wt.ty,vertexData=this.vertexData;for(let i=0;i<vertexData.length/2;i++){const x=vertices[2*i],y=vertices[2*i+1];vertexData[2*i]=a*x+c*y+tx,vertexData[2*i+1]=b*x+d*y+ty}if(this._roundPixels){const resolution=lib.Xd.RESOLUTION;for(let i=0;i<vertexData.length;++i)vertexData[i]=Math.round(vertexData[i]*resolution)/resolution}this.vertexDirty=vertexDirtyId}calculateUvs(){const geomUvs=this.geometry.buffers[1],shader=this.shader;shader.uvMatrix.isSimple?this.uvs=geomUvs.data:(this.batchUvs||(this.batchUvs=new MeshBatchUvs(geomUvs,shader.uvMatrix)),this.batchUvs.update(),this.uvs=this.batchUvs.data)}_calculateBounds(){this.calculateVertices(),this._bounds.addVertexData(this.vertexData,0,this.vertexData.length)}containsPoint(point){if(!this.getBounds().contains(point.x,point.y))return!1;this.worldTransform.applyInverse(point,tempPoint);const vertices=this.geometry.getBuffer("aVertexPosition").data,points=tempPolygon.points,indices=this.geometry.getIndex().data,len=indices.length,step=4===this.drawMode?3:1;for(let i=0;i+2<len;i+=step){const ind0=2*indices[i],ind1=2*indices[i+1],ind2=2*indices[i+2];if(points[0]=vertices[ind0],points[1]=vertices[ind0+1],points[2]=vertices[ind1],points[3]=vertices[ind1+1],points[4]=vertices[ind2],points[5]=vertices[ind2+1],tempPolygon.contains(tempPoint.x,tempPoint.y))return!0}return!1}destroy(options){super.destroy(options),this._cachedTexture&&(this._cachedTexture.destroy(),this._cachedTexture=null),this.geometry=null,this.shader=null,this.state=null,this.uvs=null,this.indices=null,this.vertexData=null}};_Mesh.BATCHABLE_SIZE=100;let Mesh=_Mesh;class MeshGeometry extends lib.wG{constructor(vertices,uvs,index){super();const verticesBuffer=new lib.lW(vertices),uvsBuffer=new lib.lW(uvs,!0),indexBuffer=new lib.lW(index,!0,!0);this.addAttribute("aVertexPosition",verticesBuffer,2,!1,lib.vK.FLOAT).addAttribute("aTextureCoord",uvsBuffer,2,!1,lib.vK.FLOAT).addIndex(indexBuffer),this._updateId=-1}get vertexDirtyId(){return this.buffers[0]._updateID}}class MeshMaterial extends lib.ex{constructor(uSampler,options){const uniforms={uSampler,alpha:1,uTextureMatrix:lib.y3.IDENTITY,uColor:new Float32Array([1,1,1,1])};(options=Object.assign({tint:16777215,alpha:1,pluginName:"batch"},options)).uniforms&&Object.assign(uniforms,options.uniforms),super(options.program||lib.$r.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"),uniforms),this._colorDirty=!1,this.uvMatrix=new lib.UX(uSampler),this.batchable=void 0===options.program,this.pluginName=options.pluginName,this._tintColor=new lib.Il(options.tint),this._tintRGB=this._tintColor.toLittleEndianNumber(),this._colorDirty=!0,this.alpha=options.alpha}get texture(){return this.uniforms.uSampler}set texture(value){this.uniforms.uSampler!==value&&(!this.uniforms.uSampler.baseTexture.alphaMode!=!value.baseTexture.alphaMode&&(this._colorDirty=!0),this.uniforms.uSampler=value,this.uvMatrix.texture=value)}set alpha(value){value!==this._alpha&&(this._alpha=value,this._colorDirty=!0)}get alpha(){return this._alpha}set tint(value){value!==this.tint&&(this._tintColor.setValue(value),this._tintRGB=this._tintColor.toLittleEndianNumber(),this._colorDirty=!0)}get tint(){return this._tintColor.value}get tintValue(){return this._tintColor.toNumber()}update(){if(this._colorDirty){this._colorDirty=!1;const applyToChannels=this.texture.baseTexture.alphaMode;lib.Il.shared.setValue(this._tintColor).premultiply(this._alpha,applyToChannels).toArray(this.uniforms.uColor)}this.uvMatrix.update()&&(this.uniforms.uTextureMatrix=this.uvMatrix.mapCoord)}}const pageMeshDataDefaultPageMeshData=[],pageMeshDataMSDFPageMeshData=[],charRenderDataPool=[],_BitmapText=class _BitmapText2 extends display_lib.W2{constructor(text,style={}){super();const{align,tint,maxWidth,letterSpacing,fontName,fontSize}=Object.assign({},_BitmapText2.styleDefaults,style);if(!BitmapFont.available[fontName])throw new Error(`Missing BitmapFont "${fontName}"`);this._activePagesMeshData=[],this._textWidth=0,this._textHeight=0,this._align=align,this._tintColor=new lib.Il(tint),this._font=void 0,this._fontName=fontName,this._fontSize=fontSize,this.text=text,this._maxWidth=maxWidth,this._maxLineHeight=0,this._letterSpacing=letterSpacing,this._anchor=new lib.AB((()=>{this.dirty=!0}),this,0,0),this._roundPixels=lib.Xd.ROUND_PIXELS,this.dirty=!0,this._resolution=lib.Xd.RESOLUTION,this._autoResolution=!0,this._textureCache={}}updateText(){const data=BitmapFont.available[this._fontName],fontSize=this.fontSize,scale=fontSize/data.size,pos=new lib.E9,chars=[],lineWidths=[],lineSpaces=[],charsInput=splitTextToCharacters(this._text.replace(/(?:\r\n|\r)/g,"\n")||" "),maxWidth=this._maxWidth*data.size/fontSize,pageMeshDataPool="none"===data.distanceFieldType?pageMeshDataDefaultPageMeshData:pageMeshDataMSDFPageMeshData;let prevCharCode=null,lastLineWidth=0,maxLineWidth=0,line=0,lastBreakPos=-1,lastBreakWidth=0,spacesRemoved=0,maxLineHeight=0,spaceCount=0;for(let i=0;i<charsInput.length;i++){const char=charsInput[i],charCode=extractCharCode(char);if(/(?:\s)/.test(char)&&(lastBreakPos=i,lastBreakWidth=lastLineWidth,spaceCount++),"\r"===char||"\n"===char){lineWidths.push(lastLineWidth),lineSpaces.push(-1),maxLineWidth=Math.max(maxLineWidth,lastLineWidth),++line,++spacesRemoved,pos.x=0,pos.y+=data.lineHeight,prevCharCode=null,spaceCount=0;continue}const charData=data.chars[charCode];if(!charData)continue;prevCharCode&&charData.kerning[prevCharCode]&&(pos.x+=charData.kerning[prevCharCode]);const charRenderData=charRenderDataPool.pop()||{texture:lib.xE.EMPTY,line:0,charCode:0,prevSpaces:0,position:new lib.E9};charRenderData.texture=charData.texture,charRenderData.line=line,charRenderData.charCode=charCode,charRenderData.position.x=Math.round(pos.x+charData.xOffset+this._letterSpacing/2),charRenderData.position.y=Math.round(pos.y+charData.yOffset),charRenderData.prevSpaces=spaceCount,chars.push(charRenderData),lastLineWidth=charRenderData.position.x+Math.max(charData.xAdvance-charData.xOffset,charData.texture.orig.width),pos.x+=charData.xAdvance+this._letterSpacing,maxLineHeight=Math.max(maxLineHeight,charData.yOffset+charData.texture.height),prevCharCode=charCode,-1!==lastBreakPos&&maxWidth>0&&pos.x>maxWidth&&(++spacesRemoved,lib.P6.removeItems(chars,1+lastBreakPos-spacesRemoved,1+i-lastBreakPos),i=lastBreakPos,lastBreakPos=-1,lineWidths.push(lastBreakWidth),lineSpaces.push(chars.length>0?chars[chars.length-1].prevSpaces:0),maxLineWidth=Math.max(maxLineWidth,lastBreakWidth),line++,pos.x=0,pos.y+=data.lineHeight,prevCharCode=null,spaceCount=0)}const lastChar=charsInput[charsInput.length-1];"\r"!==lastChar&&"\n"!==lastChar&&(/(?:\s)/.test(lastChar)&&(lastLineWidth=lastBreakWidth),lineWidths.push(lastLineWidth),maxLineWidth=Math.max(maxLineWidth,lastLineWidth),lineSpaces.push(-1));const lineAlignOffsets=[];for(let i=0;i<=line;i++){let alignOffset=0;"right"===this._align?alignOffset=maxLineWidth-lineWidths[i]:"center"===this._align?alignOffset=(maxLineWidth-lineWidths[i])/2:"justify"===this._align&&(alignOffset=lineSpaces[i]<0?0:(maxLineWidth-lineWidths[i])/lineSpaces[i]),lineAlignOffsets.push(alignOffset)}const lenChars=chars.length,pagesMeshData={},newPagesMeshData=[],activePagesMeshData=this._activePagesMeshData;pageMeshDataPool.push(...activePagesMeshData);for(let i=0;i<lenChars;i++){const texture=chars[i].texture,baseTextureUid=texture.baseTexture.uid;if(!pagesMeshData[baseTextureUid]){let pageMeshData=pageMeshDataPool.pop();if(!pageMeshData){const geometry=new MeshGeometry;let material,meshBlendMode;"none"===data.distanceFieldType?(material=new MeshMaterial(lib.xE.EMPTY),meshBlendMode=lib.T$.NORMAL):(material=new MeshMaterial(lib.xE.EMPTY,{program:lib.$r.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n","// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n"),uniforms:{uFWidth:0}}),meshBlendMode=lib.T$.NORMAL_NPM);const mesh=new Mesh(geometry,material);mesh.blendMode=meshBlendMode,pageMeshData={index:0,indexCount:0,vertexCount:0,uvsCount:0,total:0,mesh,vertices:null,uvs:null,indices:null}}pageMeshData.index=0,pageMeshData.indexCount=0,pageMeshData.vertexCount=0,pageMeshData.uvsCount=0,pageMeshData.total=0;const{_textureCache}=this;_textureCache[baseTextureUid]=_textureCache[baseTextureUid]||new lib.xE(texture.baseTexture),pageMeshData.mesh.texture=_textureCache[baseTextureUid],pageMeshData.mesh.tint=this._tintColor.value,newPagesMeshData.push(pageMeshData),pagesMeshData[baseTextureUid]=pageMeshData}pagesMeshData[baseTextureUid].total++}for(let i=0;i<activePagesMeshData.length;i++)newPagesMeshData.includes(activePagesMeshData[i])||this.removeChild(activePagesMeshData[i].mesh);for(let i=0;i<newPagesMeshData.length;i++)newPagesMeshData[i].mesh.parent!==this&&this.addChild(newPagesMeshData[i].mesh);this._activePagesMeshData=newPagesMeshData;for(const i in pagesMeshData){const pageMeshData=pagesMeshData[i],total=pageMeshData.total;if(!(pageMeshData.indices?.length>6*total)||pageMeshData.vertices.length<2*Mesh.BATCHABLE_SIZE)pageMeshData.vertices=new Float32Array(8*total),pageMeshData.uvs=new Float32Array(8*total),pageMeshData.indices=new Uint16Array(6*total);else{const total2=pageMeshData.total,vertices=pageMeshData.vertices;for(let i2=4*total2*2;i2<vertices.length;i2++)vertices[i2]=0}pageMeshData.mesh.size=6*total}for(let i=0;i<lenChars;i++){const char=chars[i];let offset=char.position.x+lineAlignOffsets[char.line]*("justify"===this._align?char.prevSpaces:1);this._roundPixels&&(offset=Math.round(offset));const xPos=offset*scale,yPos=char.position.y*scale,texture=char.texture,pageMesh=pagesMeshData[texture.baseTexture.uid],textureFrame=texture.frame,textureUvs=texture._uvs,index=pageMesh.index++;pageMesh.indices[6*index+0]=0+4*index,pageMesh.indices[6*index+1]=1+4*index,pageMesh.indices[6*index+2]=2+4*index,pageMesh.indices[6*index+3]=0+4*index,pageMesh.indices[6*index+4]=2+4*index,pageMesh.indices[6*index+5]=3+4*index,pageMesh.vertices[8*index+0]=xPos,pageMesh.vertices[8*index+1]=yPos,pageMesh.vertices[8*index+2]=xPos+textureFrame.width*scale,pageMesh.vertices[8*index+3]=yPos,pageMesh.vertices[8*index+4]=xPos+textureFrame.width*scale,pageMesh.vertices[8*index+5]=yPos+textureFrame.height*scale,pageMesh.vertices[8*index+6]=xPos,pageMesh.vertices[8*index+7]=yPos+textureFrame.height*scale,pageMesh.uvs[8*index+0]=textureUvs.x0,pageMesh.uvs[8*index+1]=textureUvs.y0,pageMesh.uvs[8*index+2]=textureUvs.x1,pageMesh.uvs[8*index+3]=textureUvs.y1,pageMesh.uvs[8*index+4]=textureUvs.x2,pageMesh.uvs[8*index+5]=textureUvs.y2,pageMesh.uvs[8*index+6]=textureUvs.x3,pageMesh.uvs[8*index+7]=textureUvs.y3}this._textWidth=maxLineWidth*scale,this._textHeight=(pos.y+data.lineHeight)*scale;for(const i in pagesMeshData){const pageMeshData=pagesMeshData[i];if(0!==this.anchor.x||0!==this.anchor.y){let vertexCount=0;const anchorOffsetX=this._textWidth*this.anchor.x,anchorOffsetY=this._textHeight*this.anchor.y;for(let i2=0;i2<pageMeshData.total;i2++)pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY,pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY,pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY,pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY}this._maxLineHeight=maxLineHeight*scale;const vertexBuffer=pageMeshData.mesh.geometry.getBuffer("aVertexPosition"),textureBuffer=pageMeshData.mesh.geometry.getBuffer("aTextureCoord"),indexBuffer=pageMeshData.mesh.geometry.getIndex();vertexBuffer.data=pageMeshData.vertices,textureBuffer.data=pageMeshData.uvs,indexBuffer.data=pageMeshData.indices,vertexBuffer.update(),textureBuffer.update(),indexBuffer.update()}for(let i=0;i<chars.length;i++)charRenderDataPool.push(chars[i]);this._font=data,this.dirty=!1}updateTransform(){this.validate(),this.containerUpdateTransform()}_render(renderer){this._autoResolution&&this._resolution!==renderer.resolution&&(this._resolution=renderer.resolution,this.dirty=!0);const{distanceFieldRange,distanceFieldType,size}=BitmapFont.available[this._fontName];if("none"!==distanceFieldType){const{a,b,c,d}=this.worldTransform,dx=Math.sqrt(a*a+b*b),dy=Math.sqrt(c*c+d*d),worldScale=(Math.abs(dx)+Math.abs(dy))/2,fontScale=this.fontSize/size,resolution=renderer._view.resolution;for(const mesh of this._activePagesMeshData)mesh.mesh.shader.uniforms.uFWidth=worldScale*distanceFieldRange*fontScale*resolution}super._render(renderer)}getLocalBounds(){return this.validate(),super.getLocalBounds()}validate(){const font=BitmapFont.available[this._fontName];if(!font)throw new Error(`Missing BitmapFont "${this._fontName}"`);this._font!==font&&(this.dirty=!0),this.dirty&&this.updateText()}get tint(){return this._tintColor.value}set tint(value){if(this.tint!==value){this._tintColor.setValue(value);for(let i=0;i<this._activePagesMeshData.length;i++)this._activePagesMeshData[i].mesh.tint=value}}get align(){return this._align}set align(value){this._align!==value&&(this._align=value,this.dirty=!0)}get fontName(){return this._fontName}set fontName(value){if(!BitmapFont.available[value])throw new Error(`Missing BitmapFont "${value}"`);this._fontName!==value&&(this._fontName=value,this.dirty=!0)}get fontSize(){return this._fontSize??BitmapFont.available[this._fontName].size}set fontSize(value){this._fontSize!==value&&(this._fontSize=value,this.dirty=!0)}get anchor(){return this._anchor}set anchor(value){"number"==typeof value?this._anchor.set(value):this._anchor.copyFrom(value)}get text(){return this._text}set text(text){text=String(text??""),this._text!==text&&(this._text=text,this.dirty=!0)}get maxWidth(){return this._maxWidth}set maxWidth(value){this._maxWidth!==value&&(this._maxWidth=value,this.dirty=!0)}get maxLineHeight(){return this.validate(),this._maxLineHeight}get textWidth(){return this.validate(),this._textWidth}get letterSpacing(){return this._letterSpacing}set letterSpacing(value){this._letterSpacing!==value&&(this._letterSpacing=value,this.dirty=!0)}get roundPixels(){return this._roundPixels}set roundPixels(value){value!==this._roundPixels&&(this._roundPixels=value,this.dirty=!0)}get textHeight(){return this.validate(),this._textHeight}get resolution(){return this._resolution}set resolution(value){this._autoResolution=!1,this._resolution!==value&&(this._resolution=value,this.dirty=!0)}destroy(options){const{_textureCache}=this,pageMeshDataPool="none"===BitmapFont.available[this._fontName].distanceFieldType?pageMeshDataDefaultPageMeshData:pageMeshDataMSDFPageMeshData;pageMeshDataPool.push(...this._activePagesMeshData);for(const pageMeshData of this._activePagesMeshData)this.removeChild(pageMeshData.mesh);this._activePagesMeshData=[],pageMeshDataPool.filter((page=>_textureCache[page.mesh.texture.baseTexture.uid])).forEach((page=>{page.mesh.texture=lib.xE.EMPTY}));for(const id in _textureCache)_textureCache[id].destroy(),delete _textureCache[id];this._font=null,this._tintColor=null,this._textureCache=null,super.destroy(options)}};_BitmapText.styleDefaults={align:"left",tint:16777215,maxWidth:0,letterSpacing:0};let BitmapText=_BitmapText;var assets_lib=__webpack_require__("./node_modules/@pixi/assets/lib/index.mjs");const validExtensions=[".xml",".fnt"],loadBitmapFont={extension:{type:lib.nw.LoadParser,priority:assets_lib.Q2.Normal},name:"loadBitmapFont",test:url=>validExtensions.includes(lib.P6.path.extname(url).toLowerCase()),testParse:async data=>TextFormat.test(data)||XMLStringFormat.test(data),async parse(asset,data,loader){const fontData=TextFormat.test(asset)?TextFormat.parse(asset):XMLStringFormat.parse(asset),{src}=data,{page:pages}=fontData,textureUrls=[];for(let i=0;i<pages.length;++i){const pageFile=pages[i].file;let imagePath=lib.P6.path.join(lib.P6.path.dirname(src),pageFile);imagePath=(0,assets_lib.uz)(imagePath,src),textureUrls.push(imagePath)}const loadedTextures=await loader.load(textureUrls),textures=textureUrls.map((url=>loadedTextures[url]));return BitmapFont.install(fontData,textures,!0)},load:async(url,_options)=>(await lib.Xd.ADAPTER.fetch(url)).text(),unload(bitmapFont){bitmapFont.destroy()}};lib.Rw.add(loadBitmapFont)}}]);