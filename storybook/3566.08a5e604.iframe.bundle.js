"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[3566],{"./node_modules/pixi.js/lib/app/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class ResizePlugin{static init(options){Object.defineProperty(this,"resizeTo",{set(dom){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=dom,dom&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame((()=>this.resize())))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;let width,height;if(this._cancelResize(),this._resizeTo===globalThis.window)width=globalThis.innerWidth,height=globalThis.innerHeight;else{const{clientWidth,clientHeight}=this._resizeTo;width=clientWidth,height=clientHeight}this.renderer.resize(width,height),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=options.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=Extensions.Ag.Application;var ticker_const=__webpack_require__("./node_modules/pixi.js/lib/ticker/const.mjs"),Ticker=__webpack_require__("./node_modules/pixi.js/lib/ticker/Ticker.mjs");class TickerPlugin{static init(options){options=Object.assign({autoStart:!0,sharedTicker:!1},options),Object.defineProperty(this,"ticker",{set(ticker){this._ticker&&this._ticker.remove(this.render,this),this._ticker=ticker,ticker&&ticker.add(this.render,this,ticker_const.d.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=options.sharedTicker?Ticker.R.shared:new Ticker.R,options.autoStart&&this.start()}static destroy(){if(this._ticker){const oldTicker=this._ticker;this.ticker=null,oldTicker.destroy()}}}TickerPlugin.extension=Extensions.Ag.Application,Extensions.XO.add(ResizePlugin),Extensions.XO.add(TickerPlugin)},"./node_modules/pixi.js/lib/filters/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class FilterPipe{constructor(renderer){this._renderer=renderer}push(filterEffect,container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container,filterEffect})}pop(_filterEffect,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(instruction){"pushFilter"===instruction.action?this._renderer.filter.push(instruction):"popFilter"===instruction.action&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"filter"};var Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),Point=__webpack_require__("./node_modules/pixi.js/lib/maths/point/Point.mjs"),BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"),Geometry=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),Bounds=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"),matrixAndBoundsPool=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");const tempMatrix=new Matrix.u;function getFastGlobalBounds(target,bounds){return bounds.clear(),_getGlobalBoundsRecursive(target,bounds),bounds.isValid||bounds.set(0,0,0,0),target.isRenderGroupRoot?bounds.applyMatrix(target.renderGroup.localTransform):bounds.applyMatrix(target.renderGroup.worldTransform),bounds}function _getGlobalBoundsRecursive(target,bounds){if(7!==target.localDisplayStatus||!target.measurable)return;const manageEffects=!!target.effects.length;let localBounds=bounds;if((target.isRenderGroupRoot||manageEffects)&&(localBounds=matrixAndBoundsPool.o.get().clear()),target.boundsArea)bounds.addRect(target.boundsArea,target.worldTransform);else{if(target.renderPipeId){const viewBounds=target.bounds;localBounds.addFrame(viewBounds.minX,viewBounds.minY,viewBounds.maxX,viewBounds.maxY,target.groupTransform)}const children=target.children;for(let i=0;i<children.length;i++)_getGlobalBoundsRecursive(children[i],localBounds)}if(manageEffects){let advanced=!1;for(let i=0;i<target.effects.length;i++)target.effects[i].addBounds&&(advanced||(advanced=!0,localBounds.applyMatrix(target.renderGroup.worldTransform)),target.effects[i].addBounds(localBounds,!0));advanced&&(localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert()),bounds.addBounds(localBounds,target.relativeGroupTransform)),bounds.addBounds(localBounds),matrixAndBoundsPool.o.return(localBounds)}else target.isRenderGroupRoot&&(bounds.addBounds(localBounds,target.relativeGroupTransform),matrixAndBoundsPool.o.return(localBounds))}var warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs");const quadGeometry=new Geometry.V({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),location:0,format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterSystem{constructor(renderer){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup.k({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup.T({}),this.renderer=renderer}get activeBackTexture(){return this._activeFilterData?.backTexture}push(instruction){const renderer=this.renderer,filters=instruction.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const filterData=this._filterStack[this._filterStackIndex];if(this._filterStackIndex++,0===filters.length)return void(filterData.skip=!0);const bounds=filterData.bounds;instruction.renderables?function getGlobalRenderableBounds(renderables,bounds){bounds.clear();const tempMatrix=bounds.matrix;for(let i=0;i<renderables.length;i++){const renderable=renderables[i];renderable.globalDisplayStatus<7||(bounds.matrix=renderable.worldTransform,renderable.addBounds(bounds))}return bounds.matrix=tempMatrix,bounds}(instruction.renderables,bounds):instruction.filterEffect.filterArea?(bounds.clear(),bounds.addRect(instruction.filterEffect.filterArea),bounds.applyMatrix(instruction.container.worldTransform)):getFastGlobalBounds(instruction.container,bounds);const colorTextureSource=renderer.renderTarget.rootRenderTarget.colorTexture.source;let resolution=colorTextureSource._resolution,padding=0,antialias=colorTextureSource.antialias,blendRequired=!1,enabled=!1;for(let i=0;i<filters.length;i++){const filter=filters[i];resolution=Math.min(resolution,filter.resolution),padding+=filter.padding,"inherit"!==filter.antialias&&(antialias="on"===filter.antialias);if(!!!(filter.compatibleRenderers&renderer.type)){enabled=!1;break}if(filter.blendRequired&&!(renderer.backBuffer?.useBackBuffer??1)){(0,warn.R)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),enabled=!1;break}enabled=filter.enabled||enabled,blendRequired=blendRequired||filter.blendRequired}enabled?(bounds.scale(resolution).fit(renderer.renderTarget.rootViewPort).scale(1/resolution).pad(padding).ceil(),bounds.isPositive?(filterData.skip=!1,filterData.bounds=bounds,filterData.blendRequired=blendRequired,filterData.container=instruction.container,filterData.filterEffect=instruction.filterEffect,filterData.previousRenderSurface=renderer.renderTarget.renderSurface,filterData.inputTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,resolution,antialias),renderer.renderTarget.bind(filterData.inputTexture,!0),renderer.globalUniforms.push({offset:bounds})):filterData.skip=!0):filterData.skip=!0}pop(){const renderer=this.renderer;this._filterStackIndex--;const filterData=this._filterStack[this._filterStackIndex];if(filterData.skip)return;this._activeFilterData=filterData;const inputTexture=filterData.inputTexture,bounds=filterData.bounds;let backTexture=Texture.g.EMPTY;if(renderer.renderTarget.finishRenderPass(),filterData.blendRequired){const previousBounds=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null,renderTarget=renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);backTexture=this.getBackTexture(renderTarget,bounds,previousBounds)}filterData.backTexture=backTexture;const filters=filterData.filterEffect.filters;if(this._globalFilterBindGroup.setResource(inputTexture.source.style,2),this._globalFilterBindGroup.setResource(backTexture.source,3),renderer.globalUniforms.pop(),1===filters.length)filters[0].apply(this,inputTexture,filterData.previousRenderSurface,!1),TexturePool.W.returnTexture(inputTexture);else{let flip=filterData.inputTexture,flop=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,flip.source._resolution,!1),i=0;for(i=0;i<filters.length-1;++i){filters[i].apply(this,flip,flop,!0);const t=flip;flip=flop,flop=t}filters[i].apply(this,flip,filterData.previousRenderSurface,!1),TexturePool.W.returnTexture(flip),TexturePool.W.returnTexture(flop)}filterData.blendRequired&&TexturePool.W.returnTexture(backTexture)}getBackTexture(lastRenderSurface,bounds,previousBounds){const backgroundResolution=lastRenderSurface.colorTexture.source._resolution,backTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,backgroundResolution,!1);let x=bounds.minX,y=bounds.minY;previousBounds&&(x-=previousBounds.minX,y-=previousBounds.minY),x=Math.floor(x*backgroundResolution),y=Math.floor(y*backgroundResolution);const width=Math.ceil(bounds.width*backgroundResolution),height=Math.ceil(bounds.height*backgroundResolution);return this.renderer.renderTarget.copyToTexture(lastRenderSurface,backTexture,{x,y},{width,height},{x:0,y:0}),backTexture}applyFilter(filter,input,output,clear){const renderer=this.renderer,filterData=this._filterStack[this._filterStackIndex],bounds=filterData.bounds,offset=Point.b.shared,isFinalTarget=filterData.previousRenderSurface===output;let resolution=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,currentIndex=this._filterStackIndex-1;for(;currentIndex>0&&this._filterStack[currentIndex].skip;)--currentIndex;currentIndex>0&&(resolution=this._filterStack[currentIndex].inputTexture.source._resolution);const filterUniforms=this._filterGlobalUniforms,uniforms=filterUniforms.uniforms,outputFrame=uniforms.uOutputFrame,inputSize=uniforms.uInputSize,inputPixel=uniforms.uInputPixel,inputClamp=uniforms.uInputClamp,globalFrame=uniforms.uGlobalFrame,outputTexture=uniforms.uOutputTexture;if(isFinalTarget){let lastIndex=this._filterStackIndex;for(;lastIndex>0;){lastIndex--;const filterData2=this._filterStack[this._filterStackIndex-1];if(!filterData2.skip){offset.x=filterData2.bounds.minX,offset.y=filterData2.bounds.minY;break}}outputFrame[0]=bounds.minX-offset.x,outputFrame[1]=bounds.minY-offset.y}else outputFrame[0]=0,outputFrame[1]=0;outputFrame[2]=input.frame.width,outputFrame[3]=input.frame.height,inputSize[0]=input.source.width,inputSize[1]=input.source.height,inputSize[2]=1/inputSize[0],inputSize[3]=1/inputSize[1],inputPixel[0]=input.source.pixelWidth,inputPixel[1]=input.source.pixelHeight,inputPixel[2]=1/inputPixel[0],inputPixel[3]=1/inputPixel[1],inputClamp[0]=.5*inputPixel[2],inputClamp[1]=.5*inputPixel[3],inputClamp[2]=input.frame.width*inputSize[2]-.5*inputPixel[2],inputClamp[3]=input.frame.height*inputSize[3]-.5*inputPixel[3];const rootTexture=this.renderer.renderTarget.rootRenderTarget.colorTexture;globalFrame[0]=offset.x*resolution,globalFrame[1]=offset.y*resolution,globalFrame[2]=rootTexture.source.width*resolution,globalFrame[3]=rootTexture.source.height*resolution;const renderTarget=this.renderer.renderTarget.getRenderTarget(output);if(renderer.renderTarget.bind(output,!!clear),output instanceof Texture.g?(outputTexture[0]=output.frame.width,outputTexture[1]=output.frame.height):(outputTexture[0]=renderTarget.width,outputTexture[1]=renderTarget.height),outputTexture[2]=renderTarget.isRoot?-1:1,filterUniforms.update(),renderer.renderPipes.uniformBatch){const batchUniforms=renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);this._globalFilterBindGroup.setResource(batchUniforms,0)}else this._globalFilterBindGroup.setResource(filterUniforms,0);this._globalFilterBindGroup.setResource(input.source,1),this._globalFilterBindGroup.setResource(input.source.style,2),filter.groups[0]=this._globalFilterBindGroup,renderer.encoder.draw({geometry:quadGeometry,shader:filter,state:filter._state,topology:"triangle-list"}),renderer.type===types.W.WEBGL&&renderer.renderTarget.finishRenderPass()}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Bounds.c,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(outputMatrix,sprite){const data=this._activeFilterData,mappedMatrix=outputMatrix.set(data.inputTexture._source.width,0,0,data.inputTexture._source.height,data.bounds.minX,data.bounds.minY),worldTransform=sprite.worldTransform.copyTo(Matrix.u.shared);return worldTransform.invert(),mappedMatrix.prepend(worldTransform),mappedMatrix.scale(1/sprite.texture.frame.width,1/sprite.texture.frame.height),mappedMatrix.translate(sprite.anchor.x,sprite.anchor.y),mappedMatrix}}FilterSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem],name:"filter"},Extensions.XO.add(FilterSystem),Extensions.XO.add(FilterPipe)},"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{v:()=>batchSamplersUniformGroup});var _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs"),_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");const sampleValues=new Int32Array(_batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__.k);for(let i=0;i<_batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__.k;i++)sampleValues[i]=i;const batchSamplersUniformGroup=new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.k({uTextures:{value:sampleValues,type:"i32",size:_batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__.k}},{isStatic:!0})},"./node_modules/pixi.js/lib/scene/graphics/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),GraphicsContextSystem=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableGraphics=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs");class GraphicsPipe{constructor(renderer,adaptor){this.state=State.U.for2d(),this._graphicsBatchesHash=Object.create(null),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init()}validateRenderable(graphics){const context=graphics.context,wasBatched=!!this._graphicsBatchesHash[graphics.uid],gpuContext=this.renderer.graphicsContext.updateGpuContext(context);return!(!gpuContext.isBatchable&&wasBatched===gpuContext.isBatchable)}addRenderable(graphics,instructionSet){const gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);graphics._didGraphicsUpdate&&(graphics._didGraphicsUpdate=!1,this._rebuild(graphics)),gpuContext.isBatchable?this._addToBatcher(graphics,instructionSet):(this.renderer.renderPipes.batch.break(instructionSet),instructionSet.add(graphics))}updateRenderable(graphics){const batches=this._graphicsBatchesHash[graphics.uid];if(batches)for(let i=0;i<batches.length;i++){const batch=batches[i];batch.batcher.updateElement(batch)}}destroyRenderable(graphics){this._graphicsBatchesHash[graphics.uid]&&this._removeBatchForRenderable(graphics.uid)}execute(graphics){if(!graphics.isRenderable)return;const renderer=this.renderer,context=graphics.context;if(!renderer.graphicsContext.getGpuContext(context).batches.length)return;const shader=context.customShader||this._adaptor.shader;this.state.blendMode=graphics.groupBlendMode;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=graphics.groupTransform,localUniforms.uRound=renderer._roundPixels|graphics._roundPixels,(0,colorToUniform.V)(graphics.groupColorAlpha,localUniforms.uColor,0),this._adaptor.execute(this,graphics)}_rebuild(graphics){const wasBatched=!!this._graphicsBatchesHash[graphics.uid],gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);wasBatched&&this._removeBatchForRenderable(graphics.uid),gpuContext.isBatchable&&this._initBatchesForRenderable(graphics),graphics.batched=gpuContext.isBatchable}_addToBatcher(graphics,instructionSet){const batchPipe=this.renderer.renderPipes.batch,batches=this._getBatchesForRenderable(graphics);for(let i=0;i<batches.length;i++){const batch=batches[i];batchPipe.addToBatch(batch,instructionSet)}}_getBatchesForRenderable(graphics){return this._graphicsBatchesHash[graphics.uid]||this._initBatchesForRenderable(graphics)}_initBatchesForRenderable(graphics){const context=graphics.context,gpuContext=this.renderer.graphicsContext.getGpuContext(context),roundPixels=this.renderer._roundPixels|graphics._roundPixels,batches=gpuContext.batches.map((batch=>{const batchClone=PoolGroup.Z.get(BatchableGraphics.G);return batch.copyTo(batchClone),batchClone.renderable=graphics,batchClone.roundPixels=roundPixels,batchClone}));return this._graphicsBatchesHash[graphics.uid]=batches,graphics.on("destroyed",(()=>{this.destroyRenderable(graphics)})),batches}_removeBatchForRenderable(graphicsUid){this._graphicsBatchesHash[graphicsUid].forEach((batch=>{PoolGroup.Z.return(batch)})),this._graphicsBatchesHash[graphicsUid]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const i in this._graphicsBatchesHash)this._removeBatchForRenderable(i);this._graphicsBatchesHash=null}}GraphicsPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"graphics"},Extensions.XO.add(GraphicsPipe),Extensions.XO.add(GraphicsContextSystem.GH)},"./node_modules/pixi.js/lib/scene/mesh/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs");class MeshPipe{constructor(renderer,adaptor){this.localUniforms=new UniformGroup.k({uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup.T({0:this.localUniforms}),this._meshDataHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init()}validateRenderable(mesh){const meshData=this._getMeshData(mesh),wasBatched=meshData.batched,isBatched=mesh.batched;if(meshData.batched=isBatched,wasBatched!==isBatched)return!0;if(isBatched){const geometry=mesh._geometry;if(geometry.indices.length!==meshData.indexSize||geometry.positions.length!==meshData.vertexSize)return meshData.indexSize=geometry.indices.length,meshData.vertexSize=geometry.positions.length,!0;const batchableMesh=this._getBatchableMesh(mesh),texture=mesh.texture;if(batchableMesh.texture._source!==texture._source&&batchableMesh.texture._source!==texture._source)return!batchableMesh.batcher.checkAndUpdateTexture(batchableMesh,texture)}return!1}addRenderable(mesh,instructionSet){const batcher=this.renderer.renderPipes.batch,{batched}=this._getMeshData(mesh);if(batched){const gpuBatchableMesh=this._getBatchableMesh(mesh);gpuBatchableMesh.texture=mesh._texture,gpuBatchableMesh.geometry=mesh._geometry,batcher.addToBatch(gpuBatchableMesh)}else batcher.break(instructionSet),instructionSet.add({renderPipeId:"mesh",mesh})}updateRenderable(mesh){if(mesh.batched){const gpuBatchableMesh=this._gpuBatchableMeshHash[mesh.uid];gpuBatchableMesh.texture=mesh._texture,gpuBatchableMesh.geometry=mesh._geometry,gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh)}}destroyRenderable(mesh){this._meshDataHash[mesh.uid]=null;const gpuMesh=this._gpuBatchableMeshHash[mesh.uid];PoolGroup.Z.return(gpuMesh),this._gpuBatchableMeshHash[mesh.uid]=null}execute({mesh}){if(!mesh.isRenderable)return;mesh.state.blendMode=mesh.groupBlendMode;const localUniforms=this.localUniforms;localUniforms.uniforms.uTransformMatrix=mesh.groupTransform,localUniforms.uniforms.uRound=this.renderer._roundPixels|mesh._roundPixels,localUniforms.update(),(0,colorToUniform.V)(mesh.groupColorAlpha,localUniforms.uniforms.uColor,0),this._adaptor.execute(this,mesh)}_getMeshData(mesh){return this._meshDataHash[mesh.uid]||this._initMeshData(mesh)}_initMeshData(mesh){return this._meshDataHash[mesh.uid]={batched:mesh.batched,indexSize:mesh._geometry.indices?.length,vertexSize:mesh._geometry.positions?.length},mesh.on("destroyed",(()=>{this.destroyRenderable(mesh)})),this._meshDataHash[mesh.uid]}_getBatchableMesh(mesh){return this._gpuBatchableMeshHash[mesh.uid]||this._initBatchableMesh(mesh)}_initBatchableMesh(mesh){const gpuMesh=PoolGroup.Z.get(BatchableMesh.U);return gpuMesh.mesh=mesh,gpuMesh.texture=mesh._texture,gpuMesh.roundPixels=this.renderer._roundPixels|mesh._roundPixels,this._gpuBatchableMeshHash[mesh.uid]=gpuMesh,gpuMesh.mesh=mesh,gpuMesh}destroy(){for(const i in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[i]&&PoolGroup.Z.return(this._gpuBatchableMeshHash[i]);this._gpuBatchableMeshHash=null,this._meshDataHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"mesh"},Extensions.XO.add(MeshPipe)},"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>BatchableMesh});var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");class BatchableMesh{constructor(){this.batcher=null,this.batch=null,this.roundPixels=0,this._uvMatrix=new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.u}get blendMode(){return this.mesh.groupBlendMode}reset(){this.mesh=null,this.texture=null,this.batcher=null,this.batch=null}packIndex(indexBuffer,index,indicesOffset){const indices=this.geometry.indices;for(let i=0;i<indices.length;i++)indexBuffer[index++]=indices[i]+indicesOffset}packAttributes(float32View,uint32View,index,textureId){const mesh=this.mesh,geometry=this.geometry,wt=mesh.groupTransform,textureIdAndRound=textureId<<16|65535&this.roundPixels,a=wt.a,b=wt.b,c=wt.c,d=wt.d,tx=wt.tx,ty=wt.ty,positions=geometry.positions,uvs=geometry.uvs;let transformedUvs=uvs;const textureMatrix=this.texture.textureMatrix;textureMatrix.isSimple||(transformedUvs=this._transformedUvs,(!transformedUvs||transformedUvs.length<uvs.length)&&(transformedUvs=this._transformedUvs=new Float32Array(uvs.length)),textureMatrix.mapCoord.equals(this._uvMatrix)||(this._uvMatrix.copyFrom(textureMatrix.mapCoord),textureMatrix.multiplyUvs(uvs,transformedUvs)));const abgr=mesh.groupColorAlpha;for(let i=0;i<positions.length;i+=2){const x=positions[i],y=positions[i+1];float32View[index]=a*x+c*y+tx,float32View[index+1]=b*x+d*y+ty,float32View[index+2]=transformedUvs[i],float32View[index+3]=transformedUvs[i+1],uint32View[index+4]=abgr,uint32View[index+5]=textureIdAndRound,index+=6}}get vertexSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}},"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{u:()=>MeshGeometry});var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"),_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"),_rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"),_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");const _MeshGeometry=class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__.V{constructor(...args){let options=args[0]??{};options instanceof Float32Array&&((0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.l,"use new MeshGeometry({ positions, uvs, indices }) instead"),options={positions:options,uvs:args[1],indices:args[2]}),options={..._MeshGeometry.defaultOptions,...options};const positions=options.positions||new Float32Array([0,0,1,0,1,1,0,1]),uvs=options.uvs||new Float32Array([0,0,1,0,1,1,0,1]),indices=options.indices||new Uint32Array([0,1,2,0,2,3]),shrinkToFit=options.shrinkBuffersToFit;super({attributes:{aPosition:{buffer:new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__.h({data:positions,label:"attribute-mesh-positions",shrinkToFit,usage:_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.S.VERTEX|_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.S.COPY_DST}),format:"float32x2",stride:8,offset:0},aUV:{buffer:new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__.h({data:uvs,label:"attribute-mesh-uvs",shrinkToFit,usage:_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.S.VERTEX|_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.S.COPY_DST}),format:"float32x2",stride:8,offset:0}},indexBuffer:new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__.h({data:indices,label:"index-mesh-buffer",shrinkToFit,usage:_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.S.INDEX|_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.S.COPY_DST}),topology:options.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(value){this.attributes.aPosition.buffer.data=value}get uvs(){return this.attributes.aUV.buffer.data}set uvs(value){this.attributes.aUV.buffer.data=value}get indices(){return this.indexBuffer.data}set indices(value){this.indexBuffer.data=value}};_MeshGeometry.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let MeshGeometry=_MeshGeometry},"./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),deprecation=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs"),MeshGeometry=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");const _PlaneGeometry=class _PlaneGeometry extends MeshGeometry.u{constructor(...args){super({});let options=args[0]??{};"number"==typeof options&&((0,deprecation.t)(deprecation.l,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),options={width:options,height:args[1],verticesX:args[2],verticesY:args[3]}),this.build(options)}build(options){options={..._PlaneGeometry.defaultOptions,...options},this.verticesX=this.verticesX??options.verticesX,this.verticesY=this.verticesY??options.verticesY,this.width=this.width??options.width,this.height=this.height??options.height;const total=this.verticesX*this.verticesY,verts=[],uvs=[],indices=[],verticesX=this.verticesX-1,verticesY=this.verticesY-1,sizeX=this.width/verticesX,sizeY=this.height/verticesY;for(let i=0;i<total;i++){const x=i%this.verticesX,y=i/this.verticesX|0;verts.push(x*sizeX,y*sizeY),uvs.push(x/verticesX,y/verticesY)}const totalSub=verticesX*verticesY;for(let i=0;i<totalSub;i++){const xpos=i%verticesX,ypos=i/verticesX|0,value=ypos*this.verticesX+xpos,value2=ypos*this.verticesX+xpos+1,value3=(ypos+1)*this.verticesX+xpos,value4=(ypos+1)*this.verticesX+xpos+1;indices.push(value,value2,value3,value2,value4,value3)}this.buffers[0].data=new Float32Array(verts),this.buffers[1].data=new Float32Array(uvs),this.indexBuffer.data=new Uint32Array(indices),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};_PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let PlaneGeometry=_PlaneGeometry;const _NineSliceGeometry=class _NineSliceGeometry extends PlaneGeometry{constructor(options={}){super({width:(options={..._NineSliceGeometry.defaultOptions,...options}).width,height:options.height,verticesX:4,verticesY:4}),this._textureMatrix=new Matrix.u,this.update(options)}update(options){this.width=options.width??this.width,this.height=options.height??this.height,this._originalWidth=options.originalWidth??this._originalWidth,this._originalHeight=options.originalHeight??this._originalHeight,this._leftWidth=options.leftWidth??this._leftWidth,this._rightWidth=options.rightWidth??this._rightWidth,this._topHeight=options.topHeight??this._topHeight,this._bottomHeight=options.bottomHeight??this._bottomHeight,options.textureMatrix&&this._textureMatrix.copyFrom(options.textureMatrix),this.updateUvs(),this.updatePositions()}updatePositions(){const positions=this.positions,w=this._leftWidth+this._rightWidth,scaleW=this.width>w?1:this.width/w,h=this._topHeight+this._bottomHeight,scaleH=this.height>h?1:this.height/h,scale=Math.min(scaleW,scaleH);positions[9]=positions[11]=positions[13]=positions[15]=this._topHeight*scale,positions[17]=positions[19]=positions[21]=positions[23]=this.height-this._bottomHeight*scale,positions[25]=positions[27]=positions[29]=positions[31]=this.height,positions[2]=positions[10]=positions[18]=positions[26]=this._leftWidth*scale,positions[4]=positions[12]=positions[20]=positions[28]=this.width-this._rightWidth*scale,positions[6]=positions[14]=positions[22]=positions[30]=this.width,this.getBuffer("aPosition").update()}updateUvs(){const textureMatrix=this._textureMatrix,uvs=this.uvs;uvs[0]=uvs[8]=uvs[16]=uvs[24]=0,uvs[1]=uvs[3]=uvs[5]=uvs[7]=0,uvs[6]=uvs[14]=uvs[22]=uvs[30]=1,uvs[25]=uvs[27]=uvs[29]=uvs[31]=1;const _uvw=1/this._originalWidth,_uvh=1/this._originalHeight;uvs[2]=uvs[10]=uvs[18]=uvs[26]=_uvw*this._leftWidth,uvs[9]=uvs[11]=uvs[13]=uvs[15]=_uvh*this._topHeight,uvs[4]=uvs[12]=uvs[20]=uvs[28]=1-_uvw*this._rightWidth,uvs[17]=uvs[19]=uvs[21]=uvs[23]=1-_uvh*this._bottomHeight,function multiplyUvs(matrix,uvs,out){out??(out=uvs);const a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;for(let i=0;i<uvs.length;i+=2){const x=uvs[i],y=uvs[i+1];out[i]=x*a+y*c+tx,out[i+1]=x*b+y*d+ty}return out}(textureMatrix,uvs),this.getBuffer("aUV").update()}};_NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let NineSliceGeometry=_NineSliceGeometry;class NineSliceSpritePipe{constructor(renderer){this._gpuSpriteHash=Object.create(null),this._renderer=renderer}addRenderable(sprite,_instructionSet){const gpuSprite=this._getGpuSprite(sprite);sprite._didSpriteUpdate&&this._updateBatchableSprite(sprite,gpuSprite),this._renderer.renderPipes.batch.addToBatch(gpuSprite)}updateRenderable(sprite){const gpuSprite=this._gpuSpriteHash[sprite.uid];sprite._didSpriteUpdate&&this._updateBatchableSprite(sprite,gpuSprite),gpuSprite.batcher.updateElement(gpuSprite)}validateRenderable(sprite){const texture=sprite._texture,gpuSprite=this._getGpuSprite(sprite);return gpuSprite.texture._source!==texture._source&&!gpuSprite.batcher.checkAndUpdateTexture(gpuSprite,texture)}destroyRenderable(sprite){const batchableSprite=this._gpuSpriteHash[sprite.uid];PoolGroup.Z.return(batchableSprite),this._gpuSpriteHash[sprite.uid]=null}_updateBatchableSprite(sprite,batchableSprite){sprite._didSpriteUpdate=!1,batchableSprite.geometry.update(sprite),batchableSprite.texture=sprite._texture}_getGpuSprite(sprite){return this._gpuSpriteHash[sprite.uid]||this._initGPUSprite(sprite)}_initGPUSprite(sprite){const batchableMesh=new BatchableMesh.U;return batchableMesh.geometry=new NineSliceGeometry,batchableMesh.mesh=sprite,batchableMesh.texture=sprite._texture,batchableMesh.roundPixels=this._renderer._roundPixels|sprite._roundPixels,this._gpuSpriteHash[sprite.uid]=batchableMesh,sprite.on("destroyed",(()=>{this.destroyRenderable(sprite)})),batchableMesh}destroy(){for(const i in this._gpuSpriteHash){this._gpuSpriteHash[i].geometry.destroy()}this._gpuSpriteHash=null,this._renderer=null}}NineSliceSpritePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"nineSliceSprite"},Extensions.XO.add(NineSliceSpritePipe)},"./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"),MeshGeometry=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),compileHighShaderToProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"),localUniformBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"),roundPixelsBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");const tilingBit={name:"tiling-bit",vertex:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        "},fragment:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        "}},tilingBitGl={name:"tiling-bit",vertex:{header:"\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        ",main:"\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        "},fragment:{header:"\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ",main:"\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        "}};let gpuProgram,glProgram;class TilingSpriteShader extends Shader.M{constructor(){gpuProgram??(gpuProgram=(0,compileHighShaderToProgram.v)({name:"tiling-sprite-shader",bits:[localUniformBit.Ls,tilingBit,roundPixelsBit.b]})),glProgram??(glProgram=(0,compileHighShaderToProgram.I)({name:"tiling-sprite-shader",bits:[localUniformBit.mA,tilingBitGl,roundPixelsBit.m]}));const tilingUniforms=new UniformGroup.k({uMapCoord:{value:new Matrix.u,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix.u,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram,gpuProgram,resources:{localUniforms:new UniformGroup.k({uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms,uTexture:Texture.g.EMPTY.source,uSampler:Texture.g.EMPTY.source.style}})}updateUniforms(width,height,matrix,anchorX,anchorY,texture){const tilingUniforms=this.resources.tilingUniforms,textureWidth=texture.width,textureHeight=texture.height,textureMatrix=texture.textureMatrix,uTextureTransform=tilingUniforms.uniforms.uTextureTransform;uTextureTransform.set(matrix.a*textureWidth/width,matrix.b*textureWidth/height,matrix.c*textureHeight/width,matrix.d*textureHeight/height,matrix.tx/width,matrix.ty/height),uTextureTransform.invert(),tilingUniforms.uniforms.uMapCoord=textureMatrix.mapCoord,tilingUniforms.uniforms.uClampFrame=textureMatrix.uClampFrame,tilingUniforms.uniforms.uClampOffset=textureMatrix.uClampOffset,tilingUniforms.uniforms.uTextureTransform=uTextureTransform,tilingUniforms.uniforms.uSizeAnchor[0]=width,tilingUniforms.uniforms.uSizeAnchor[1]=height,tilingUniforms.uniforms.uSizeAnchor[2]=anchorX,tilingUniforms.uniforms.uSizeAnchor[3]=anchorY,texture&&(this.resources.uTexture=texture.source,this.resources.uSampler=texture.source.style)}}class QuadGeometry extends MeshGeometry.u{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}const sharedQuad=new QuadGeometry;class TilingSpritePipe{constructor(renderer){this._tilingSpriteDataHash=Object.create(null),this._renderer=renderer}validateRenderable(renderable){const tilingSpriteData=this._getTilingSpriteData(renderable),couldBatch=tilingSpriteData.canBatch;this._updateCanBatch(renderable);const canBatch=tilingSpriteData.canBatch;if(canBatch&&canBatch===couldBatch){const{batchableMesh}=tilingSpriteData;if(batchableMesh.texture._source!==renderable.texture._source)return!batchableMesh.batcher.checkAndUpdateTexture(batchableMesh,renderable.texture)}return couldBatch!==canBatch}addRenderable(tilingSprite,instructionSet){const batcher=this._renderer.renderPipes.batch;this._updateCanBatch(tilingSprite);const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{geometry,canBatch}=tilingSpriteData;if(canBatch){tilingSpriteData.batchableMesh||(tilingSpriteData.batchableMesh=new BatchableMesh.U);const batchableMesh=tilingSpriteData.batchableMesh;tilingSprite._didTilingSpriteUpdate&&(tilingSprite._didTilingSpriteUpdate=!1,this._updateBatchableMesh(tilingSprite),batchableMesh.geometry=geometry,batchableMesh.mesh=tilingSprite,batchableMesh.texture=tilingSprite._texture),batchableMesh.roundPixels=this._renderer._roundPixels|tilingSprite._roundPixels,batcher.addToBatch(batchableMesh)}else batcher.break(instructionSet),tilingSpriteData.shader||(tilingSpriteData.shader=new TilingSpriteShader),this.updateRenderable(tilingSprite),instructionSet.add(tilingSprite)}execute(tilingSprite){const{shader}=this._tilingSpriteDataHash[tilingSprite.uid];shader.groups[0]=this._renderer.globalUniforms.bindGroup;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=tilingSprite.groupTransform,localUniforms.uRound=this._renderer._roundPixels|tilingSprite._roundPixels,(0,colorToUniform.V)(tilingSprite.groupColorAlpha,localUniforms.uColor,0),this._renderer.encoder.draw({geometry:sharedQuad,shader,state:State.U.default2d})}updateRenderable(tilingSprite){const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{canBatch}=tilingSpriteData;if(canBatch){const{batchableMesh}=tilingSpriteData;tilingSprite._didTilingSpriteUpdate&&this._updateBatchableMesh(tilingSprite),batchableMesh.batcher.updateElement(batchableMesh)}else if(tilingSprite._didTilingSpriteUpdate){const{shader}=tilingSpriteData;shader.updateUniforms(tilingSprite.width,tilingSprite.height,tilingSprite._tileTransform.matrix,tilingSprite.anchor.x,tilingSprite.anchor.y,tilingSprite.texture)}tilingSprite._didTilingSpriteUpdate=!1}destroyRenderable(tilingSprite){const tilingSpriteData=this._getTilingSpriteData(tilingSprite);tilingSpriteData.batchableMesh=null,tilingSpriteData.shader?.destroy(),this._tilingSpriteDataHash[tilingSprite.uid]=null}_getTilingSpriteData(renderable){return this._tilingSpriteDataHash[renderable.uid]||this._initTilingSpriteData(renderable)}_initTilingSpriteData(tilingSprite){const geometry=new MeshGeometry.u({indices:sharedQuad.indices,positions:sharedQuad.positions.slice(),uvs:sharedQuad.uvs.slice()});return this._tilingSpriteDataHash[tilingSprite.uid]={canBatch:!0,renderable:tilingSprite,geometry},tilingSprite.on("destroyed",(()=>{this.destroyRenderable(tilingSprite)})),this._tilingSpriteDataHash[tilingSprite.uid]}_updateBatchableMesh(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),{geometry}=renderableData,style=tilingSprite.texture.source.style;"repeat"!==style.addressMode&&(style.addressMode="repeat",style.update()),function setUvs(tilingSprite,uvs){const texture=tilingSprite.texture,width=texture.frame.width,height=texture.frame.height;let anchorX=0,anchorY=0;tilingSprite._applyAnchorToTexture&&(anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y),uvs[0]=uvs[6]=-anchorX,uvs[2]=uvs[4]=1-anchorX,uvs[1]=uvs[3]=-anchorY,uvs[5]=uvs[7]=1-anchorY;const textureMatrix=Matrix.u.shared;textureMatrix.copyFrom(tilingSprite._tileTransform.matrix),textureMatrix.tx/=tilingSprite.width,textureMatrix.ty/=tilingSprite.height,textureMatrix.invert(),textureMatrix.scale(tilingSprite.width/width,tilingSprite.height/height),function applyMatrix(array,stride,offset,matrix){let index=0;const size=array.length/(stride||2),a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;for(offset*=stride;index<size;){const x=array[offset],y=array[offset+1];array[offset]=a*x+c*y+tx,array[offset+1]=b*x+d*y+ty,offset+=stride,index++}}(uvs,2,0,textureMatrix)}(tilingSprite,geometry.uvs),function setPositions(tilingSprite,positions){const anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y;positions[0]=-anchorX*tilingSprite.width,positions[1]=-anchorY*tilingSprite.height,positions[2]=(1-anchorX)*tilingSprite.width,positions[3]=-anchorY*tilingSprite.height,positions[4]=(1-anchorX)*tilingSprite.width,positions[5]=(1-anchorY)*tilingSprite.height,positions[6]=-anchorX*tilingSprite.width,positions[7]=(1-anchorY)*tilingSprite.height}(tilingSprite,geometry.positions)}destroy(){for(const i in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);this._tilingSpriteDataHash=null,this._renderer=null}_updateCanBatch(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),texture=tilingSprite.texture;let _nonPowOf2wrapping=!0;return this._renderer.type===types.W.WEBGL&&(_nonPowOf2wrapping=this._renderer.context.supports.nonPowOf2wrapping),renderableData.canBatch=texture.textureMatrix.isSimple&&(_nonPowOf2wrapping||texture.source.isPowerOfTwo),renderableData.canBatch}}TilingSpritePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"tilingSprite"},Extensions.XO.add(TilingSpritePipe)},"./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),LoaderParser=__webpack_require__("./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"),copySearchParams=__webpack_require__("./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"),adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs"),path=__webpack_require__("./node_modules/pixi.js/lib/utils/path.mjs"),Rectangle=__webpack_require__("./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),AbstractBitmapFont=__webpack_require__("./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"),BitmapFontManager=__webpack_require__("./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs");class BitmapFont extends AbstractBitmapFont.v{constructor(options,url){super();const{textures,data}=options;Object.keys(data.pages).forEach((key=>{const pageData=data.pages[parseInt(key,10)],texture=textures[pageData.id];this.pages.push({texture})})),Object.keys(data.chars).forEach((key=>{const charData=data.chars[key],textureSource=textures[charData.page].source,frameReal=new Rectangle.M(charData.x,charData.y,charData.width,charData.height),texture=new Texture.g({source:textureSource,frame:frameReal});this.chars[key]={id:key.codePointAt(0),xOffset:charData.xOffset,yOffset:charData.yOffset,xAdvance:charData.xAdvance,kerning:charData.kerning??{},texture}})),this.baseRenderedFontSize=data.fontSize,this.baseMeasurementFontSize=data.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:data.fontSize},this.baseLineOffset=data.baseLineOffset,this.lineHeight=data.lineHeight,this.fontFamily=data.fontFamily,this.distanceField=data.distanceField??{type:"none",range:0},this.url=url}destroy(){super.destroy();for(let i=0;i<this.pages.length;i++){const{texture}=this.pages[i];texture.destroy(!0)}this.pages=null}static install(options){BitmapFontManager.c.install(options)}static uninstall(name){BitmapFontManager.c.uninstall(name)}}const bitmapFontTextParser={test:data=>"string"==typeof data&&data.startsWith("info face="),parse(txt){const items=txt.match(/^[a-z]+\s+.+$/gm),rawData={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const i in items){const name=items[i].match(/^[a-z]+/gm)[0],attributeList=items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),itemData={};for(const i2 in attributeList){const split=attributeList[i2].split("="),key=split[0],strValue=split[1].replace(/"/gm,""),floatValue=parseFloat(strValue),value=isNaN(floatValue)?strValue:floatValue;itemData[key]=value}rawData[name].push(itemData)}const font={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[info]=rawData.info,[common]=rawData.common,[distanceField]=rawData.distanceField??[];distanceField&&(font.distanceField={range:parseInt(distanceField.distanceRange,10),type:distanceField.fieldType}),font.fontSize=parseInt(info.size,10),font.fontFamily=info.face,font.lineHeight=parseInt(common.lineHeight,10);const page=rawData.page;for(let i=0;i<page.length;i++)font.pages.push({id:parseInt(page[i].id,10)||0,file:page[i].file});const map={};font.baseLineOffset=font.lineHeight-parseInt(common.base,10);const char=rawData.char;for(let i=0;i<char.length;i++){const charNode=char[i],id=parseInt(charNode.id,10);let letter=charNode.letter??charNode.char??String.fromCharCode(id);"space"===letter&&(letter=" "),map[id]=letter,font.chars[letter]={id,page:parseInt(charNode.page,10)||0,x:parseInt(charNode.x,10),y:parseInt(charNode.y,10),width:parseInt(charNode.width,10),height:parseInt(charNode.height,10),xOffset:parseInt(charNode.xoffset,10),yOffset:parseInt(charNode.yoffset,10),xAdvance:parseInt(charNode.xadvance,10),kerning:{}}}const kerning=rawData.kerning||[];for(let i=0;i<kerning.length;i++){const first=parseInt(kerning[i].first,10),second=parseInt(kerning[i].second,10),amount=parseInt(kerning[i].amount,10);font.chars[map[second]].kerning[map[first]]=amount}return font}},bitmapFontXMLParser={test(data){const xml=data;return"string"!=typeof xml&&"getElementsByTagName"in xml&&xml.getElementsByTagName("page").length&&null!==xml.getElementsByTagName("info")[0].getAttribute("face")},parse(xml){const data={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},info=xml.getElementsByTagName("info")[0],common=xml.getElementsByTagName("common")[0],distanceField=xml.getElementsByTagName("distanceField")[0];distanceField&&(data.distanceField={type:distanceField.getAttribute("fieldType"),range:parseInt(distanceField.getAttribute("distanceRange"),10)});const page=xml.getElementsByTagName("page"),char=xml.getElementsByTagName("char"),kerning=xml.getElementsByTagName("kerning");data.fontSize=parseInt(info.getAttribute("size"),10),data.fontFamily=info.getAttribute("face"),data.lineHeight=parseInt(common.getAttribute("lineHeight"),10);for(let i=0;i<page.length;i++)data.pages.push({id:parseInt(page[i].getAttribute("id"),10)||0,file:page[i].getAttribute("file")});const map={};data.baseLineOffset=data.lineHeight-parseInt(common.getAttribute("base"),10);for(let i=0;i<char.length;i++){const charNode=char[i],id=parseInt(charNode.getAttribute("id"),10);let letter=charNode.getAttribute("letter")??charNode.getAttribute("char")??String.fromCharCode(id);"space"===letter&&(letter=" "),map[id]=letter,data.chars[letter]={id,page:parseInt(charNode.getAttribute("page"),10)||0,x:parseInt(charNode.getAttribute("x"),10),y:parseInt(charNode.getAttribute("y"),10),width:parseInt(charNode.getAttribute("width"),10),height:parseInt(charNode.getAttribute("height"),10),xOffset:parseInt(charNode.getAttribute("xoffset"),10),yOffset:parseInt(charNode.getAttribute("yoffset"),10),xAdvance:parseInt(charNode.getAttribute("xadvance"),10),kerning:{}}}for(let i=0;i<kerning.length;i++){const first=parseInt(kerning[i].getAttribute("first"),10),second=parseInt(kerning[i].getAttribute("second"),10),amount=parseInt(kerning[i].getAttribute("amount"),10);data.chars[map[second]].kerning[map[first]]=amount}return data}},bitmapFontXMLStringParser={test:data=>!("string"!=typeof data||!data.includes("<font>"))&&bitmapFontXMLParser.test(adapter.e.get().parseXML(data)),parse:data=>bitmapFontXMLParser.parse(adapter.e.get().parseXML(data))},validExtensions=[".xml",".fnt"],bitmapFontCachePlugin={extension:Extensions.Ag.CacheParser,test:asset=>asset instanceof BitmapFont,getCacheableAssets(keys,asset){const out={};return keys.forEach((key=>{out[key]=asset})),out[`${asset.fontFamily}-bitmap`]=asset,out}},loadBitmapFont={extension:{type:Extensions.Ag.LoadParser,priority:LoaderParser.T.Normal},test:url=>validExtensions.includes(path.A.extname(url).toLowerCase()),testParse:async data=>bitmapFontTextParser.test(data)||bitmapFontXMLStringParser.test(data),async parse(asset,data,loader){const bitmapFontData=bitmapFontTextParser.test(asset)?bitmapFontTextParser.parse(asset):bitmapFontXMLStringParser.parse(asset),{src}=data,{pages}=bitmapFontData,textureUrls=[];for(let i=0;i<pages.length;++i){const pageFile=pages[i].file;let imagePath=path.A.join(path.A.dirname(src),pageFile);imagePath=(0,copySearchParams.Y)(imagePath,src),textureUrls.push(imagePath)}const loadedTextures=await loader.load(textureUrls),textures=textureUrls.map((url=>loadedTextures[url]));return new BitmapFont({data:bitmapFontData,textures},src)},async load(url,_options){const response=await adapter.e.get().fetch(url);return await response.text()},async unload(bitmapFont,_resolvedAsset,loader){await Promise.all(bitmapFont.pages.map((page=>loader.unload(page.texture.source._sourceOrigin)))),bitmapFont.destroy()}};var Cache=__webpack_require__("./node_modules/pixi.js/lib/assets/cache/Cache.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),Graphics=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),shared_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs"),compileHighShaderToProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"),colorBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"),generateTextureBatchBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"),roundPixelsBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"),batchSamplersUniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "},fragment:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ",main:" \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        "}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:"\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "},fragment:{header:"\n            uniform float uDistance;\n         ",main:" \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        "}},mSDFBit={name:"msdf-bit",fragment:{header:"\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        "}},mSDFBitGl={name:"msdf-bit",fragment:{header:"\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        "}};class SdfShader extends Shader.M{constructor(){const uniforms=new UniformGroup.k({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),gpuProgram=(0,compileHighShaderToProgram.v)({name:"sdf-shader",bits:[colorBit.F,(0,generateTextureBatchBit._)(shared_const.k),localUniformMSDFBit,mSDFBit,roundPixelsBit.b]});super({glProgram:(0,compileHighShaderToProgram.I)({name:"sdf-shader",bits:[colorBit.a,(0,generateTextureBatchBit.P)(shared_const.k),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBit.m]}),gpuProgram,resources:{localUniforms:uniforms,batchSamplers:batchSamplersUniformGroup.v}})}}var getBitmapTextLayout=__webpack_require__("./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs");class BitmapTextPipe{constructor(renderer){this._gpuBitmapText={},this._renderer=renderer}validateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);return bitmapText._didTextUpdate&&(bitmapText._didTextUpdate=!1,this._updateContext(bitmapText,graphicsRenderable)),this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable)}addRenderable(bitmapText,instructionSet){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),bitmapText._didTextUpdate&&(bitmapText._didTextUpdate=!1,this._updateContext(bitmapText,graphicsRenderable)),this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable,instructionSet),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}destroyRenderable(bitmapText){this._destroyRenderableByUid(bitmapText.uid)}_destroyRenderableByUid(renderableUid){PoolGroup.Z.return(this._gpuBitmapText[renderableUid]),this._gpuBitmapText[renderableUid]=null}updateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}_updateContext(bitmapText,proxyGraphics){const{context}=proxyGraphics,bitmapFont=BitmapFontManager.c.getFont(bitmapText.text,bitmapText._style);context.clear(),"none"!==bitmapFont.distanceField.type&&(context.customShader||(this._sdfShader||(this._sdfShader=new SdfShader),context.customShader=this._sdfShader));const chars=Array.from(bitmapText.text),style=bitmapText._style;let currentY=(style._stroke?.width||0)/2;currentY+=bitmapFont.baseLineOffset;const bitmapTextLayout=(0,getBitmapTextLayout.Z)(chars,style,bitmapFont);let index=0;const padding=style.padding,scale=bitmapTextLayout.scale;context.translate(-bitmapText._anchor._x*bitmapTextLayout.width-padding,-bitmapText._anchor._y*(bitmapTextLayout.height+bitmapTextLayout.offsetY)-padding).scale(scale,scale);const tint=style._fill.color;for(let i=0;i<bitmapTextLayout.lines.length;i++){const line=bitmapTextLayout.lines[i];for(let j=0;j<line.charPositions.length;j++){const char=chars[index++],charData=bitmapFont.chars[char];charData?.texture&&context.texture(charData.texture,tint||"black",Math.round(line.charPositions[j]+charData.xOffset),Math.round(currentY+charData.yOffset))}currentY+=bitmapFont.lineHeight}}_getGpuBitmapText(bitmapText){return this._gpuBitmapText[bitmapText.uid]||this.initGpuText(bitmapText)}initGpuText(bitmapText){const proxyRenderable=PoolGroup.Z.get(Graphics.A);return this._gpuBitmapText[bitmapText.uid]=proxyRenderable,this._updateContext(bitmapText,proxyRenderable),bitmapText.on("destroyed",(()=>{this.destroyRenderable(bitmapText)})),this._gpuBitmapText[bitmapText.uid]}_updateDistanceField(bitmapText){const context=this._getGpuBitmapText(bitmapText).context,fontFamily=bitmapText._style.fontFamily,dynamicFont=Cache.l.get(`${fontFamily}-bitmap`),{a,b,c,d}=bitmapText.groupTransform,dx=Math.sqrt(a*a+b*b),dy=Math.sqrt(c*c+d*d),worldScale=(Math.abs(dx)+Math.abs(dy))/2,fontScale=dynamicFont.baseRenderedFontSize/bitmapText._style.fontSize,resolution=bitmapText.resolution??this._renderer.resolution,distance=worldScale*dynamicFont.distanceField.range*(1/fontScale)*resolution;context.customShader.resources.localUniforms.uniforms.uDistance=distance}destroy(){for(const uid in this._gpuBitmapText)this._destroyRenderableByUid(uid);this._gpuBitmapText=null,this._sdfShader?.destroy(!0),this._sdfShader=null,this._renderer=null}}function syncWithProxy(container,proxy){proxy.groupTransform=container.groupTransform,proxy.groupColorAlpha=container.groupColorAlpha,proxy.groupColor=container.groupColor,proxy.groupBlendMode=container.groupBlendMode,proxy.globalDisplayStatus=container.globalDisplayStatus,proxy.groupTransform=container.groupTransform,proxy.localDisplayStatus=container.localDisplayStatus,proxy.groupAlpha=container.groupAlpha,proxy._roundPixels=container._roundPixels}BitmapTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"bitmapText"},Extensions.XO.add(BitmapTextPipe,loadBitmapFont,bitmapFontCachePlugin)},"./node_modules/pixi.js/lib/scene/text-html/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),updateQuadBounds=__webpack_require__("./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),BatchableSprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");class HTMLTextPipe{constructor(renderer){this._gpuText=Object.create(null),this._renderer=renderer}validateRenderable(htmlText){const gpuText=this._getGpuText(htmlText),newKey=htmlText._getKey();return gpuText.textureNeedsUploading?(gpuText.textureNeedsUploading=!1,!0):gpuText.currentKey!==newKey}addRenderable(htmlText){const batchableSprite=this._getGpuText(htmlText).batchableSprite;htmlText._didTextUpdate&&this._updateText(htmlText),this._renderer.renderPipes.batch.addToBatch(batchableSprite)}updateRenderable(htmlText){const batchableSprite=this._getGpuText(htmlText).batchableSprite;htmlText._didTextUpdate&&this._updateText(htmlText),batchableSprite.batcher.updateElement(batchableSprite)}destroyRenderable(htmlText){this._destroyRenderableById(htmlText.uid)}_destroyRenderableById(htmlTextUid){const gpuText=this._gpuText[htmlTextUid];this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey),PoolGroup.Z.return(gpuText.batchableSprite),this._gpuText[htmlTextUid]=null}_updateText(htmlText){const newKey=htmlText._getKey(),gpuText=this._getGpuText(htmlText),batchableSprite=gpuText.batchableSprite;gpuText.currentKey!==newKey&&this._updateGpuText(htmlText).catch((e=>{console.error(e)})),htmlText._didTextUpdate=!1;const padding=htmlText._style.padding;(0,updateQuadBounds.y)(batchableSprite.bounds,htmlText._anchor,batchableSprite.texture,padding)}async _updateGpuText(htmlText){htmlText._didTextUpdate=!1;const gpuText=this._getGpuText(htmlText);if(gpuText.generatingTexture)return;const newKey=htmlText._getKey();this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey),gpuText.generatingTexture=!0,gpuText.currentKey=newKey;const resolution=htmlText.resolution??this._renderer.resolution,texture=await this._renderer.htmlText.getManagedTexture(htmlText.text,resolution,htmlText._style,htmlText._getKey()),batchableSprite=gpuText.batchableSprite;batchableSprite.texture=gpuText.texture=texture,gpuText.generatingTexture=!1,gpuText.textureNeedsUploading=!0,htmlText.onViewUpdate();const padding=htmlText._style.padding;(0,updateQuadBounds.y)(batchableSprite.bounds,htmlText._anchor,batchableSprite.texture,padding)}_getGpuText(htmlText){return this._gpuText[htmlText.uid]||this.initGpuText(htmlText)}initGpuText(htmlText){const gpuTextData={texture:Texture.g.EMPTY,currentKey:"--",batchableSprite:PoolGroup.Z.get(BatchableSprite.K),textureNeedsUploading:!1,generatingTexture:!1},batchableSprite=gpuTextData.batchableSprite;return batchableSprite.renderable=htmlText,batchableSprite.texture=Texture.g.EMPTY,batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},batchableSprite.roundPixels=this._renderer._roundPixels|htmlText._roundPixels,this._gpuText[htmlText.uid]=gpuTextData,htmlText.on("destroyed",(()=>{this.destroyRenderable(htmlText)})),gpuTextData}destroy(){for(const i in this._gpuText)this._destroyRenderableById(i);this._gpuText=null,this._renderer=null}}HTMLTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"htmlText"};var TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs");var warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs"),getPo2TextureFromSource=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"),HTMLTextRenderData=__webpack_require__("./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"),HtmlTextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs");var Cache=__webpack_require__("./node_modules/pixi.js/lib/assets/cache/Cache.mjs");async function loadFontCSS(style,url){const dataSrc=await async function loadFontAsBase64(url){const response=await adapter.e.get().fetch(url),blob=await response.blob(),reader=new FileReader;return await new Promise(((resolve,reject)=>{reader.onloadend=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)}))}(url);return`@font-face {\n        font-family: "${style.fontFamily}";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`}const FontStylePromiseCache=new Map;var CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");var measureHtmlText=__webpack_require__("./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs");class HTMLTextSystem{constructor(renderer){this._activeTextures={},this._renderer=renderer,this._createCanvas=renderer.type===types.W.WEBGPU}getTexture(options){return this._buildTexturePromise(options.text,options.resolution,options.style)}getManagedTexture(text,resolution,style,textKey){if(this._activeTextures[textKey])return this._increaseReferenceCount(textKey),this._activeTextures[textKey].promise;const promise=this._buildTexturePromise(text,resolution,style).then((texture=>(this._activeTextures[textKey].texture=texture,texture)));return this._activeTextures[textKey]={texture:null,promise,usageCount:1},promise}async _buildTexturePromise(text,resolution,style){const htmlTextData=PoolGroup.Z.get(HTMLTextRenderData.pF),fontFamilies=function extractFontFamilies(text,style){const fontFamily=style.fontFamily,fontFamilies=[],dedupe={},matches=text.match(/font-family:([^;"\s]+)/g);function addFontFamily(fontFamily2){dedupe[fontFamily2]||(fontFamilies.push(fontFamily2),dedupe[fontFamily2]=!0)}if(Array.isArray(fontFamily))for(let i=0;i<fontFamily.length;i++)addFontFamily(fontFamily[i]);else addFontFamily(fontFamily);matches&&matches.forEach((match=>{addFontFamily(match.split(":")[1].trim())}));for(const i in style.tagStyles)addFontFamily(style.tagStyles[i].fontFamily);return fontFamilies}(text,style),fontCSS=await async function getFontCss(fontFamilies,style,defaultOptions){const fontPromises=fontFamilies.filter((fontFamily=>Cache.l.has(fontFamily))).map(((fontFamily,i)=>{if(!FontStylePromiseCache.has(fontFamily)){const{url}=Cache.l.get(fontFamily);0===i?FontStylePromiseCache.set(fontFamily,loadFontCSS(style,url)):FontStylePromiseCache.set(fontFamily,loadFontCSS({fontWeight:defaultOptions.fontWeight,fontStyle:defaultOptions.fontStyle,fontFamily},url))}return FontStylePromiseCache.get(fontFamily)}));return(await Promise.all(fontPromises)).join("\n")}(fontFamilies,style,HtmlTextStyle.I.defaultTextStyle),measured=(0,measureHtmlText.r)(text,style,fontCSS,htmlTextData),width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*style.padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*style.padding)*resolution),image=htmlTextData.image;image.width=0|width,image.height=0|height;const svgURL=function getSVGUrl(text,style,resolution,fontCSS,htmlTextData){const{domElement,styleElement,svgRoot}=htmlTextData;domElement.innerHTML=`<style>${style.cssStyle}</style><div>${text}</div>`,domElement.setAttribute("style",`transform: scale(${resolution});transform-origin: top left; display: inline-block`),styleElement.textContent=fontCSS;const{width,height}=htmlTextData.image;return svgRoot.setAttribute("width",width.toString()),svgRoot.setAttribute("height",height.toString()),(new XMLSerializer).serializeToString(svgRoot)}(text,style,resolution,fontCSS,htmlTextData);await function loadSVGImage(image,url,delay){return new Promise((async resolve=>{delay&&await new Promise((resolve2=>setTimeout(resolve2,100))),image.onload=()=>{resolve()},image.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`,image.crossOrigin="anonymous"}))}(image,svgURL,function isSafari(){const{userAgent}=adapter.e.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(userAgent)}()&&fontFamilies.length>0);let resource=image;this._createCanvas&&(resource=function getTemporaryCanvasFromImage(image,resolution){const canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(image.width,image.height,resolution),{context}=canvasAndContext;return context.clearRect(0,0,image.width,image.height),context.drawImage(image,0,0),CanvasPool.N.returnCanvasAndContext(canvasAndContext),canvasAndContext.canvas}(image,resolution));const texture=(0,getPo2TextureFromSource.M)(resource,image.width,image.height,resolution);return this._createCanvas&&this._renderer.texture.initSource(texture.source),PoolGroup.Z.return(htmlTextData),texture}_increaseReferenceCount(textKey){this._activeTextures[textKey].usageCount++}decreaseReferenceCount(textKey){const activeTexture=this._activeTextures[textKey];activeTexture&&(activeTexture.usageCount--,0===activeTexture.usageCount&&(activeTexture.texture?this._cleanUp(activeTexture):activeTexture.promise.then((texture=>{activeTexture.texture=texture,this._cleanUp(activeTexture)})).catch((()=>{(0,warn.R)("HTMLTextSystem: Failed to clean texture")})),this._activeTextures[textKey]=null))}_cleanUp(activeTexture){TexturePool.W.returnTexture(activeTexture.texture),activeTexture.texture.source.resource=null,activeTexture.texture.source.uploadMethodId="unknown"}getReferenceCount(textKey){return this._activeTextures[textKey].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"htmlText"},HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"},Extensions.XO.add(HTMLTextSystem),Extensions.XO.add(HTMLTextPipe)},"./node_modules/pixi.js/lib/scene/text/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),updateQuadBounds=__webpack_require__("./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),BatchableSprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");class CanvasTextPipe{constructor(renderer){this._gpuText=Object.create(null),this._renderer=renderer}validateRenderable(text){const gpuText=this._getGpuText(text),newKey=text._getKey();if(gpuText.currentKey!==newKey){const resolution=text.resolution??this._renderer.resolution,{width,height}=this._renderer.canvasText.getTextureSize(text.text,resolution,text._style);return 1!==this._renderer.canvasText.getReferenceCount(gpuText.currentKey)||width!==gpuText.texture._source.width||height!==gpuText.texture._source.height}return!1}addRenderable(text,_instructionSet){const batchableSprite=this._getGpuText(text).batchableSprite;text._didTextUpdate&&this._updateText(text),this._renderer.renderPipes.batch.addToBatch(batchableSprite)}updateRenderable(text){const batchableSprite=this._getGpuText(text).batchableSprite;text._didTextUpdate&&this._updateText(text),batchableSprite.batcher.updateElement(batchableSprite)}destroyRenderable(text){this._destroyRenderableById(text.uid)}_destroyRenderableById(textUid){const gpuText=this._gpuText[textUid];this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey),PoolGroup.Z.return(gpuText.batchableSprite),this._gpuText[textUid]=null}_updateText(text){const newKey=text._getKey(),gpuText=this._getGpuText(text),batchableSprite=gpuText.batchableSprite;gpuText.currentKey!==newKey&&this._updateGpuText(text),text._didTextUpdate=!1;const padding=text._style.padding;(0,updateQuadBounds.y)(batchableSprite.bounds,text._anchor,batchableSprite.texture,padding)}_updateGpuText(text){const gpuText=this._getGpuText(text),batchableSprite=gpuText.batchableSprite;gpuText.texture&&this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);const resolution=text.resolution??this._renderer.resolution;gpuText.texture=batchableSprite.texture=this._renderer.canvasText.getTexture(text.text,resolution,text._style,text._getKey()),gpuText.currentKey=text._getKey(),batchableSprite.texture=gpuText.texture}_getGpuText(text){return this._gpuText[text.uid]||this.initGpuText(text)}initGpuText(text){const gpuTextData={texture:null,currentKey:"--",batchableSprite:PoolGroup.Z.get(BatchableSprite.K)};return gpuTextData.batchableSprite.renderable=text,gpuTextData.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},gpuTextData.batchableSprite.roundPixels=this._renderer._roundPixels|text._roundPixels,this._gpuText[text.uid]=gpuTextData,this._updateText(text),text.on("destroyed",(()=>{this.destroyRenderable(text)})),gpuTextData}destroy(){for(const i in this._gpuText)this._destroyRenderableById(i);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"text"};var Color=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),pow2=__webpack_require__("./node_modules/pixi.js/lib/maths/misc/pow2.mjs"),CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"),TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),Rectangle=__webpack_require__("./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");function checkRow(data,width,y){for(let x=0,index=4*y*width;x<width;++x,index+=4)if(0!==data[index+3])return!1;return!0}function checkColumn(data,width,x,top,bottom){const stride=4*width;for(let y=top,index=top*stride+4*x;y<=bottom;++y,index+=stride)if(0!==data[index+3])return!1;return!0}var getPo2TextureFromSource=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"),CanvasTextMetrics=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"),fontStringFromTextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"),getCanvasFillStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs");class CanvasTextSystem{constructor(){this._activeTextures={}}getTextureSize(text,resolution,style){const measured=CanvasTextMetrics.P.measureText(text||" ",style);let width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*style.padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*style.padding)*resolution);return width=Math.ceil(width-1e-6),height=Math.ceil(height-1e-6),width=(0,pow2.U5)(width),height=(0,pow2.U5)(height),{width,height}}getTexture(text,resolution,style,textKey){if(this._activeTextures[textKey])return this._increaseReferenceCount(textKey),this._activeTextures[textKey].texture;const measured=CanvasTextMetrics.P.measureText(text||" ",style),width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*style.padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*style.padding)*resolution),canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(width,height),{canvas}=canvasAndContext;this.renderTextToCanvas(text,style,resolution,canvasAndContext);const texture=(0,getPo2TextureFromSource.M)(canvas,width,height,resolution);if(style.trim){const trimmed=function getCanvasBoundingBox(canvas,resolution=1){const{width,height}=canvas,context=canvas.getContext("2d",{willReadFrequently:!0});if(null===context)throw new TypeError("Failed to get canvas 2D context");const data=context.getImageData(0,0,width,height).data;let left=0,top=0,right=width-1,bottom=height-1;for(;top<height&&checkRow(data,width,top);)++top;if(top===height)return Rectangle.M.EMPTY;for(;checkRow(data,width,bottom);)--bottom;for(;checkColumn(data,width,left,top,bottom);)++left;for(;checkColumn(data,width,right,top,bottom);)--right;return++right,++bottom,new Rectangle.M(left/resolution,top/resolution,(right-left)/resolution,(bottom-top)/resolution)}(canvas,resolution);texture.frame.copyFrom(trimmed),texture.updateUvs()}return this._activeTextures[textKey]={canvasAndContext,texture,usageCount:1},texture}_increaseReferenceCount(textKey){this._activeTextures[textKey].usageCount++}decreaseReferenceCount(textKey){const activeTexture=this._activeTextures[textKey];if(activeTexture.usageCount--,0===activeTexture.usageCount){CanvasPool.N.returnCanvasAndContext(activeTexture.canvasAndContext),TexturePool.W.returnTexture(activeTexture.texture);const source=activeTexture.texture.source;source.resource=null,source.uploadMethodId="unknown",source.alphaMode="no-premultiply-alpha",this._activeTextures[textKey]=null}}getReferenceCount(textKey){return this._activeTextures[textKey].usageCount}renderTextToCanvas(text,style,resolution,canvasAndContext){const{canvas,context}=canvasAndContext,font=(0,fontStringFromTextStyle.Z)(style),measured=CanvasTextMetrics.P.measureText(text||" ",style),lines=measured.lines,lineHeight=measured.lineHeight,lineWidths=measured.lineWidths,maxLineWidth=measured.maxLineWidth,fontProperties=measured.fontProperties,height=canvas.height;if(context.resetTransform(),context.scale(resolution,resolution),context.clearRect(0,0,measured.width+4,measured.height+4),style._stroke?.width){const strokeStyle=style._stroke;context.lineWidth=strokeStyle.width,context.miterLimit=strokeStyle.miterLimit,context.lineJoin=strokeStyle.join,context.lineCap=strokeStyle.cap}let linePositionX,linePositionY;context.font=font;const passesCount=style.dropShadow?2:1;for(let i=0;i<passesCount;++i){const isShadowPass=style.dropShadow&&0===i,dsOffsetText=isShadowPass?Math.ceil(Math.max(1,height)+2*style.padding):0,dsOffsetShadow=dsOffsetText*resolution;if(isShadowPass){context.fillStyle="black",context.strokeStyle="black";const shadowOptions=style.dropShadow,dropShadowColor=shadowOptions.color,dropShadowAlpha=shadowOptions.alpha;context.shadowColor=Color.Q.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();const dropShadowBlur=shadowOptions.blur*resolution,dropShadowDistance=shadowOptions.distance*resolution;context.shadowBlur=dropShadowBlur,context.shadowOffsetX=Math.cos(shadowOptions.angle)*dropShadowDistance,context.shadowOffsetY=Math.sin(shadowOptions.angle)*dropShadowDistance+dsOffsetShadow}else context.globalAlpha=style._fill?.alpha??1,context.fillStyle=style._fill?(0,getCanvasFillStyle.r)(style._fill,context):null,style._stroke?.width&&(context.strokeStyle=(0,getCanvasFillStyle.r)(style._stroke,context)),context.shadowColor="black";let linePositionYShift=(lineHeight-fontProperties.fontSize)/2;lineHeight-fontProperties.fontSize<0&&(linePositionYShift=0);const strokeWidth=style._stroke?.width??0;for(let i2=0;i2<lines.length;i2++)linePositionX=strokeWidth/2,linePositionY=strokeWidth/2+i2*lineHeight+fontProperties.ascent+linePositionYShift,"right"===style.align?linePositionX+=maxLineWidth-lineWidths[i2]:"center"===style.align&&(linePositionX+=(maxLineWidth-lineWidths[i2])/2),style._stroke&&this._drawLetterSpacing(lines[i2],style,canvasAndContext,linePositionX+style.padding,linePositionY+style.padding-dsOffsetText,!0),void 0!==style._fill&&this._drawLetterSpacing(lines[i2],style,canvasAndContext,linePositionX+style.padding,linePositionY+style.padding-dsOffsetText)}}_drawLetterSpacing(text,style,canvasAndContext,x,y,isStroke=!1){const{context}=canvasAndContext,letterSpacing=style.letterSpacing;let useExperimentalLetterSpacing=!1;if(CanvasTextMetrics.P.experimentalLetterSpacingSupported&&(CanvasTextMetrics.P.experimentalLetterSpacing?(context.letterSpacing=`${letterSpacing}px`,context.textLetterSpacing=`${letterSpacing}px`,useExperimentalLetterSpacing=!0):(context.letterSpacing="0px",context.textLetterSpacing="0px")),0===letterSpacing||useExperimentalLetterSpacing)return void(isStroke?context.strokeText(text,x,y):context.fillText(text,x,y));let currentPosition=x;const stringArray=CanvasTextMetrics.P.graphemeSegmenter(text);let previousWidth=context.measureText(text).width,currentWidth=0;for(let i=0;i<stringArray.length;++i){const currentChar=stringArray[i];isStroke?context.strokeText(currentChar,currentPosition,y):context.fillText(currentChar,currentPosition,y);let textStr="";for(let j=i+1;j<stringArray.length;++j)textStr+=stringArray[j];currentWidth=context.measureText(textStr).width,currentPosition+=previousWidth-currentWidth+letterSpacing,previousWidth=currentWidth}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"canvasText"},Extensions.XO.add(CanvasTextSystem),Extensions.XO.add(CanvasTextPipe)},"./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{M:()=>getPo2TextureFromSource});var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");const tempBounds=new(__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs").c);function getPo2TextureFromSource(image,width,height,resolution){const bounds=tempBounds;bounds.minX=0,bounds.minY=0,bounds.maxX=image.width/resolution|0,bounds.maxY=image.height/resolution|0;const texture=_rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__.W.getOptimalTexture(bounds.width,bounds.height,resolution,!1);return texture.source.uploadMethodId="image",texture.source.resource=image,texture.source.alphaMode="premultiply-alpha-on-upload",texture.frame.width=width/resolution,texture.frame.height=height/resolution,texture.source.emit("update",texture.source),texture.updateUvs(),texture}}}]);