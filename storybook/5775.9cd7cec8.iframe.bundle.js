"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[5775],{"./node_modules/@pixi/text-bitmap/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{UP:()=>BitmapFont,Xz:()=>BitmapText});var lib=__webpack_require__("./node_modules/@pixi/core/lib/index.mjs"),text_lib=__webpack_require__("./node_modules/@pixi/text/lib/index.mjs");class BitmapFontData{constructor(){this.info=[],this.common=[],this.page=[],this.char=[],this.kerning=[],this.distanceField=[]}}class TextFormat{static test(data){return"string"==typeof data&&data.startsWith("info face=")}static parse(txt){const items=txt.match(/^[a-z]+\s+.+$/gm),rawData={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const i in items){const name=items[i].match(/^[a-z]+/gm)[0],attributeList=items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),itemData={};for(const i2 in attributeList){const split=attributeList[i2].split("="),key=split[0],strValue=split[1].replace(/"/gm,""),floatValue=parseFloat(strValue),value=isNaN(floatValue)?strValue:floatValue;itemData[key]=value}rawData[name].push(itemData)}const font=new BitmapFontData;return rawData.info.forEach((info=>font.info.push({face:info.face,size:parseInt(info.size,10)}))),rawData.common.forEach((common=>font.common.push({lineHeight:parseInt(common.lineHeight,10)}))),rawData.page.forEach((page=>font.page.push({id:parseInt(page.id,10),file:page.file}))),rawData.char.forEach((char=>font.char.push({id:parseInt(char.id,10),page:parseInt(char.page,10),x:parseInt(char.x,10),y:parseInt(char.y,10),width:parseInt(char.width,10),height:parseInt(char.height,10),xoffset:parseInt(char.xoffset,10),yoffset:parseInt(char.yoffset,10),xadvance:parseInt(char.xadvance,10)}))),rawData.kerning.forEach((kerning=>font.kerning.push({first:parseInt(kerning.first,10),second:parseInt(kerning.second,10),amount:parseInt(kerning.amount,10)}))),rawData.distanceField.forEach((df=>font.distanceField.push({distanceRange:parseInt(df.distanceRange,10),fieldType:df.fieldType}))),font}}class XMLFormat{static test(data){const xml=data;return"string"!=typeof data&&"getElementsByTagName"in data&&xml.getElementsByTagName("page").length&&null!==xml.getElementsByTagName("info")[0].getAttribute("face")}static parse(xml){const data=new BitmapFontData,info=xml.getElementsByTagName("info"),common=xml.getElementsByTagName("common"),page=xml.getElementsByTagName("page"),char=xml.getElementsByTagName("char"),kerning=xml.getElementsByTagName("kerning"),distanceField=xml.getElementsByTagName("distanceField");for(let i=0;i<info.length;i++)data.info.push({face:info[i].getAttribute("face"),size:parseInt(info[i].getAttribute("size"),10)});for(let i=0;i<common.length;i++)data.common.push({lineHeight:parseInt(common[i].getAttribute("lineHeight"),10)});for(let i=0;i<page.length;i++)data.page.push({id:parseInt(page[i].getAttribute("id"),10)||0,file:page[i].getAttribute("file")});for(let i=0;i<char.length;i++){const letter=char[i];data.char.push({id:parseInt(letter.getAttribute("id"),10),page:parseInt(letter.getAttribute("page"),10)||0,x:parseInt(letter.getAttribute("x"),10),y:parseInt(letter.getAttribute("y"),10),width:parseInt(letter.getAttribute("width"),10),height:parseInt(letter.getAttribute("height"),10),xoffset:parseInt(letter.getAttribute("xoffset"),10),yoffset:parseInt(letter.getAttribute("yoffset"),10),xadvance:parseInt(letter.getAttribute("xadvance"),10)})}for(let i=0;i<kerning.length;i++)data.kerning.push({first:parseInt(kerning[i].getAttribute("first"),10),second:parseInt(kerning[i].getAttribute("second"),10),amount:parseInt(kerning[i].getAttribute("amount"),10)});for(let i=0;i<distanceField.length;i++)data.distanceField.push({fieldType:distanceField[i].getAttribute("fieldType"),distanceRange:parseInt(distanceField[i].getAttribute("distanceRange"),10)});return data}}class XMLStringFormat{static test(data){return!("string"!=typeof data||!data.includes("<font>"))&&XMLFormat.test(lib.Xd.ADAPTER.parseXML(data))}static parse(xmlTxt){return XMLFormat.parse(lib.Xd.ADAPTER.parseXML(xmlTxt))}}const formats=[TextFormat,XMLFormat,XMLStringFormat];function drawGlyph(canvas,context,metrics,x,y,resolution,style){const char=metrics.text,fontProperties=metrics.fontProperties;context.translate(x,y),context.scale(resolution,resolution);const tx=style.strokeThickness/2,ty=-style.strokeThickness/2;if(context.font=style.toFontString(),context.lineWidth=style.strokeThickness,context.textBaseline=style.textBaseline,context.lineJoin=style.lineJoin,context.miterLimit=style.miterLimit,context.fillStyle=function generateFillStyle(canvas,context,style,resolution,lines,metrics){const fillStyle=style.fill;if(!Array.isArray(fillStyle))return fillStyle;if(1===fillStyle.length)return fillStyle[0];let gradient;const dropShadowCorrection=style.dropShadow?style.dropShadowDistance:0,padding=style.padding||0,width=canvas.width/resolution-dropShadowCorrection-2*padding,height=canvas.height/resolution-dropShadowCorrection-2*padding,fill=fillStyle.slice(),fillGradientStops=style.fillGradientStops.slice();if(!fillGradientStops.length){const lengthPlus1=fill.length+1;for(let i=1;i<lengthPlus1;++i)fillGradientStops.push(i/lengthPlus1)}if(fill.unshift(fillStyle[0]),fillGradientStops.unshift(0),fill.push(fillStyle[fillStyle.length-1]),fillGradientStops.push(1),style.fillGradientType===text_lib.M_.LINEAR_VERTICAL){gradient=context.createLinearGradient(width/2,padding,width/2,height+padding);let lastIterationStop=0;const gradStopLineHeight=(metrics.fontProperties.fontSize+style.strokeThickness)/height;for(let i=0;i<lines.length;i++){const thisLineTop=metrics.lineHeight*i;for(let j=0;j<fill.length;j++){let lineStop=0;lineStop="number"==typeof fillGradientStops[j]?fillGradientStops[j]:j/fill.length;const globalStop=thisLineTop/height+lineStop*gradStopLineHeight;let clampedStop=Math.max(lastIterationStop,globalStop);clampedStop=Math.min(clampedStop,1),gradient.addColorStop(clampedStop,fill[j]),lastIterationStop=clampedStop}}}else{gradient=context.createLinearGradient(padding,height/2,width+padding,height/2);const totalIterations=fill.length+1;let currentIteration=1;for(let i=0;i<fill.length;i++){let stop;stop="number"==typeof fillGradientStops[i]?fillGradientStops[i]:currentIteration/totalIterations,gradient.addColorStop(stop,fill[i]),currentIteration++}}return gradient}(canvas,context,style,resolution,[char],metrics),context.strokeStyle=style.stroke,style.dropShadow){const dropShadowColor=style.dropShadowColor,dropShadowBlur=style.dropShadowBlur*resolution,dropShadowDistance=style.dropShadowDistance*resolution;context.shadowColor=lib.Il.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(),context.shadowBlur=dropShadowBlur,context.shadowOffsetX=Math.cos(style.dropShadowAngle)*dropShadowDistance,context.shadowOffsetY=Math.sin(style.dropShadowAngle)*dropShadowDistance}else context.shadowColor="black",context.shadowBlur=0,context.shadowOffsetX=0,context.shadowOffsetY=0;style.stroke&&style.strokeThickness&&context.strokeText(char,tx,ty+metrics.lineHeight-fontProperties.descent),style.fill&&context.fillText(char,tx,ty+metrics.lineHeight-fontProperties.descent),context.setTransform(1,0,0,1,0,0),context.fillStyle="rgba(0, 0, 0, 0)"}function splitTextToCharacters(text){return Array.from?Array.from(text):text.split("")}function extractCharCode(str){return str.codePointAt?str.codePointAt(0):str.charCodeAt(0)}const _BitmapFont=class _BitmapFont2{constructor(data,textures,ownsTextures){const[info]=data.info,[common]=data.common,[page]=data.page,[distanceField]=data.distanceField,res=lib.P6.getResolutionOfUrl(page.file),pageTextures={};this._ownsTextures=ownsTextures,this.font=info.face,this.size=info.size,this.lineHeight=common.lineHeight/res,this.chars={},this.pageTextures=pageTextures;for(let i=0;i<data.page.length;i++){const{id,file}=data.page[i];pageTextures[id]=textures instanceof Array?textures[i]:textures[file],distanceField?.fieldType&&"none"!==distanceField.fieldType&&(pageTextures[id].baseTexture.alphaMode=lib.iw.NO_PREMULTIPLIED_ALPHA,pageTextures[id].baseTexture.mipmap=lib.KI.OFF)}for(let i=0;i<data.char.length;i++){const{id,page:page2}=data.char[i];let{x,y,width,height,xoffset,yoffset,xadvance}=data.char[i];x/=res,y/=res,width/=res,height/=res,xoffset/=res,yoffset/=res,xadvance/=res;const rect=new lib.Ae(x+pageTextures[page2].frame.x/res,y+pageTextures[page2].frame.y/res,width,height);this.chars[id]={xOffset:xoffset,yOffset:yoffset,xAdvance:xadvance,kerning:{},texture:new lib.xE(pageTextures[page2].baseTexture,rect),page:page2}}for(let i=0;i<data.kerning.length;i++){let{first,second,amount}=data.kerning[i];first/=res,second/=res,amount/=res,this.chars[second]&&(this.chars[second].kerning[first]=amount)}this.distanceFieldRange=distanceField?.distanceRange,this.distanceFieldType=distanceField?.fieldType?.toLowerCase()??"none"}destroy(){for(const id in this.chars)this.chars[id].texture.destroy(),this.chars[id].texture=null;for(const id in this.pageTextures)this._ownsTextures&&this.pageTextures[id].destroy(!0),this.pageTextures[id]=null;this.chars=null,this.pageTextures=null}static install(data,textures,ownsTextures){let fontData;if(data instanceof BitmapFontData)fontData=data;else{const format=function autoDetectFormat(data){for(let i=0;i<formats.length;i++)if(formats[i].test(data))return formats[i];return null}(data);if(!format)throw new Error("Unrecognized data format for font.");fontData=format.parse(data)}textures instanceof lib.xE&&(textures=[textures]);const font=new _BitmapFont2(fontData,textures,ownsTextures);return _BitmapFont2.available[font.font]=font,font}static uninstall(name){const font=_BitmapFont2.available[name];if(!font)throw new Error(`No font found named '${name}'`);font.destroy(),delete _BitmapFont2.available[name]}static from(name,textStyle,options){if(!name)throw new Error("[BitmapFont] Property `name` is required.");const{chars,padding,resolution,textureWidth,textureHeight,...baseOptions}=Object.assign({},_BitmapFont2.defaultOptions,options),charsList=function resolveCharacters(chars){"string"==typeof chars&&(chars=[chars]);const result=[];for(let i=0,j=chars.length;i<j;i++){const item=chars[i];if(Array.isArray(item)){if(2!==item.length)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);const startCode=item[0].charCodeAt(0),endCode=item[1].charCodeAt(0);if(endCode<startCode)throw new Error("[BitmapFont]: Invalid character range.");for(let i2=startCode,j2=endCode;i2<=j2;i2++)result.push(String.fromCharCode(i2))}else result.push(...splitTextToCharacters(item))}if(0===result.length)throw new Error("[BitmapFont]: Empty set when resolving characters.");return result}(chars),style=textStyle instanceof text_lib.pn?textStyle:new text_lib.pn(textStyle),lineWidth=textureWidth,fontData=new BitmapFontData;fontData.info[0]={face:style.fontFamily,size:style.fontSize},fontData.common[0]={lineHeight:style.fontSize};let canvas,context,baseTexture,positionX=0,positionY=0,maxCharHeight=0;const baseTextures=[],textures=[];for(let i=0;i<charsList.length;i++){canvas||(canvas=lib.Xd.ADAPTER.createCanvas(),canvas.width=textureWidth,canvas.height=textureHeight,context=canvas.getContext("2d"),baseTexture=new lib.VL(canvas,{resolution,...baseOptions}),baseTextures.push(baseTexture),textures.push(new lib.xE(baseTexture)),fontData.page.push({id:textures.length-1,file:""}));const character=charsList[i],metrics=text_lib._A.measureText(character,style,!1,canvas),width=metrics.width,height=Math.ceil(metrics.height),textureGlyphWidth=Math.ceil(("italic"===style.fontStyle?2:1)*width);if(positionY>=textureHeight-height*resolution){if(0===positionY)throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);--i,canvas=null,context=null,baseTexture=null,positionY=0,positionX=0,maxCharHeight=0;continue}if(maxCharHeight=Math.max(height+metrics.fontProperties.descent,maxCharHeight),textureGlyphWidth*resolution+positionX>=lineWidth){if(0===positionX)throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);--i,positionY+=maxCharHeight*resolution,positionY=Math.ceil(positionY),positionX=0,maxCharHeight=0;continue}drawGlyph(canvas,context,metrics,positionX,positionY,resolution,style);const id=extractCharCode(metrics.text);fontData.char.push({id,page:textures.length-1,x:positionX/resolution,y:positionY/resolution,width:textureGlyphWidth,height,xoffset:0,yoffset:0,xadvance:width-(style.dropShadow?style.dropShadowDistance:0)-(style.stroke?style.strokeThickness:0)}),positionX+=(textureGlyphWidth+2*padding)*resolution,positionX=Math.ceil(positionX)}if(!options?.skipKerning)for(let i=0,len=charsList.length;i<len;i++){const first=charsList[i];for(let j=0;j<len;j++){const second=charsList[j],c1=context.measureText(first).width,c2=context.measureText(second).width,amount=context.measureText(first+second).width-(c1+c2);amount&&fontData.kerning.push({first:extractCharCode(first),second:extractCharCode(second),amount})}}const font=new _BitmapFont2(fontData,textures,!0);return void 0!==_BitmapFont2.available[name]&&_BitmapFont2.uninstall(name),_BitmapFont2.available[name]=font,font}};_BitmapFont.ALPHA=[["a","z"],["A","Z"]," "],_BitmapFont.NUMERIC=[["0","9"]],_BitmapFont.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],_BitmapFont.ASCII=[[" ","~"]],_BitmapFont.defaultOptions={resolution:1,textureWidth:512,textureHeight:512,padding:4,chars:_BitmapFont.ALPHANUMERIC},_BitmapFont.available={};let BitmapFont=_BitmapFont;var display_lib=__webpack_require__("./node_modules/@pixi/display/lib/index.mjs"),mesh_lib=__webpack_require__("./node_modules/@pixi/mesh/lib/index.mjs");const pageMeshDataDefaultPageMeshData=[],pageMeshDataMSDFPageMeshData=[],charRenderDataPool=[],_BitmapText=class _BitmapText2 extends display_lib.W2{constructor(text,style={}){super();const{align,tint,maxWidth,letterSpacing,fontName,fontSize}=Object.assign({},_BitmapText2.styleDefaults,style);if(!BitmapFont.available[fontName])throw new Error(`Missing BitmapFont "${fontName}"`);this._activePagesMeshData=[],this._textWidth=0,this._textHeight=0,this._align=align,this._tintColor=new lib.Il(tint),this._font=void 0,this._fontName=fontName,this._fontSize=fontSize,this.text=text,this._maxWidth=maxWidth,this._maxLineHeight=0,this._letterSpacing=letterSpacing,this._anchor=new lib.AB((()=>{this.dirty=!0}),this,0,0),this._roundPixels=lib.Xd.ROUND_PIXELS,this.dirty=!0,this._resolution=lib.Xd.RESOLUTION,this._autoResolution=!0,this._textureCache={}}updateText(){const data=BitmapFont.available[this._fontName],fontSize=this.fontSize,scale=fontSize/data.size,pos=new lib.E9,chars=[],lineWidths=[],lineSpaces=[],charsInput=splitTextToCharacters(this._text.replace(/(?:\r\n|\r)/g,"\n")||" "),maxWidth=this._maxWidth*data.size/fontSize,pageMeshDataPool="none"===data.distanceFieldType?pageMeshDataDefaultPageMeshData:pageMeshDataMSDFPageMeshData;let prevCharCode=null,lastLineWidth=0,maxLineWidth=0,line=0,lastBreakPos=-1,lastBreakWidth=0,spacesRemoved=0,maxLineHeight=0,spaceCount=0;for(let i=0;i<charsInput.length;i++){const char=charsInput[i],charCode=extractCharCode(char);if(/(?:\s)/.test(char)&&(lastBreakPos=i,lastBreakWidth=lastLineWidth,spaceCount++),"\r"===char||"\n"===char){lineWidths.push(lastLineWidth),lineSpaces.push(-1),maxLineWidth=Math.max(maxLineWidth,lastLineWidth),++line,++spacesRemoved,pos.x=0,pos.y+=data.lineHeight,prevCharCode=null,spaceCount=0;continue}const charData=data.chars[charCode];if(!charData)continue;prevCharCode&&charData.kerning[prevCharCode]&&(pos.x+=charData.kerning[prevCharCode]);const charRenderData=charRenderDataPool.pop()||{texture:lib.xE.EMPTY,line:0,charCode:0,prevSpaces:0,position:new lib.E9};charRenderData.texture=charData.texture,charRenderData.line=line,charRenderData.charCode=charCode,charRenderData.position.x=Math.round(pos.x+charData.xOffset+this._letterSpacing/2),charRenderData.position.y=Math.round(pos.y+charData.yOffset),charRenderData.prevSpaces=spaceCount,chars.push(charRenderData),lastLineWidth=charRenderData.position.x+Math.max(charData.xAdvance-charData.xOffset,charData.texture.orig.width),pos.x+=charData.xAdvance+this._letterSpacing,maxLineHeight=Math.max(maxLineHeight,charData.yOffset+charData.texture.height),prevCharCode=charCode,-1!==lastBreakPos&&maxWidth>0&&pos.x>maxWidth&&(++spacesRemoved,lib.P6.removeItems(chars,1+lastBreakPos-spacesRemoved,1+i-lastBreakPos),i=lastBreakPos,lastBreakPos=-1,lineWidths.push(lastBreakWidth),lineSpaces.push(chars.length>0?chars[chars.length-1].prevSpaces:0),maxLineWidth=Math.max(maxLineWidth,lastBreakWidth),line++,pos.x=0,pos.y+=data.lineHeight,prevCharCode=null,spaceCount=0)}const lastChar=charsInput[charsInput.length-1];"\r"!==lastChar&&"\n"!==lastChar&&(/(?:\s)/.test(lastChar)&&(lastLineWidth=lastBreakWidth),lineWidths.push(lastLineWidth),maxLineWidth=Math.max(maxLineWidth,lastLineWidth),lineSpaces.push(-1));const lineAlignOffsets=[];for(let i=0;i<=line;i++){let alignOffset=0;"right"===this._align?alignOffset=maxLineWidth-lineWidths[i]:"center"===this._align?alignOffset=(maxLineWidth-lineWidths[i])/2:"justify"===this._align&&(alignOffset=lineSpaces[i]<0?0:(maxLineWidth-lineWidths[i])/lineSpaces[i]),lineAlignOffsets.push(alignOffset)}const lenChars=chars.length,pagesMeshData={},newPagesMeshData=[],activePagesMeshData=this._activePagesMeshData;pageMeshDataPool.push(...activePagesMeshData);for(let i=0;i<lenChars;i++){const texture=chars[i].texture,baseTextureUid=texture.baseTexture.uid;if(!pagesMeshData[baseTextureUid]){let pageMeshData=pageMeshDataPool.pop();if(!pageMeshData){const geometry=new mesh_lib.xc;let material,meshBlendMode;"none"===data.distanceFieldType?(material=new mesh_lib.rY(lib.xE.EMPTY),meshBlendMode=lib.T$.NORMAL):(material=new mesh_lib.rY(lib.xE.EMPTY,{program:lib.$r.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n","// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n"),uniforms:{uFWidth:0}}),meshBlendMode=lib.T$.NORMAL_NPM);const mesh=new mesh_lib.Kj(geometry,material);mesh.blendMode=meshBlendMode,pageMeshData={index:0,indexCount:0,vertexCount:0,uvsCount:0,total:0,mesh,vertices:null,uvs:null,indices:null}}pageMeshData.index=0,pageMeshData.indexCount=0,pageMeshData.vertexCount=0,pageMeshData.uvsCount=0,pageMeshData.total=0;const{_textureCache}=this;_textureCache[baseTextureUid]=_textureCache[baseTextureUid]||new lib.xE(texture.baseTexture),pageMeshData.mesh.texture=_textureCache[baseTextureUid],pageMeshData.mesh.tint=this._tintColor.value,newPagesMeshData.push(pageMeshData),pagesMeshData[baseTextureUid]=pageMeshData}pagesMeshData[baseTextureUid].total++}for(let i=0;i<activePagesMeshData.length;i++)newPagesMeshData.includes(activePagesMeshData[i])||this.removeChild(activePagesMeshData[i].mesh);for(let i=0;i<newPagesMeshData.length;i++)newPagesMeshData[i].mesh.parent!==this&&this.addChild(newPagesMeshData[i].mesh);this._activePagesMeshData=newPagesMeshData;for(const i in pagesMeshData){const pageMeshData=pagesMeshData[i],total=pageMeshData.total;if(!(pageMeshData.indices?.length>6*total)||pageMeshData.vertices.length<2*mesh_lib.Kj.BATCHABLE_SIZE)pageMeshData.vertices=new Float32Array(8*total),pageMeshData.uvs=new Float32Array(8*total),pageMeshData.indices=new Uint16Array(6*total);else{const total2=pageMeshData.total,vertices=pageMeshData.vertices;for(let i2=4*total2*2;i2<vertices.length;i2++)vertices[i2]=0}pageMeshData.mesh.size=6*total}for(let i=0;i<lenChars;i++){const char=chars[i];let offset=char.position.x+lineAlignOffsets[char.line]*("justify"===this._align?char.prevSpaces:1);this._roundPixels&&(offset=Math.round(offset));const xPos=offset*scale,yPos=char.position.y*scale,texture=char.texture,pageMesh=pagesMeshData[texture.baseTexture.uid],textureFrame=texture.frame,textureUvs=texture._uvs,index=pageMesh.index++;pageMesh.indices[6*index+0]=0+4*index,pageMesh.indices[6*index+1]=1+4*index,pageMesh.indices[6*index+2]=2+4*index,pageMesh.indices[6*index+3]=0+4*index,pageMesh.indices[6*index+4]=2+4*index,pageMesh.indices[6*index+5]=3+4*index,pageMesh.vertices[8*index+0]=xPos,pageMesh.vertices[8*index+1]=yPos,pageMesh.vertices[8*index+2]=xPos+textureFrame.width*scale,pageMesh.vertices[8*index+3]=yPos,pageMesh.vertices[8*index+4]=xPos+textureFrame.width*scale,pageMesh.vertices[8*index+5]=yPos+textureFrame.height*scale,pageMesh.vertices[8*index+6]=xPos,pageMesh.vertices[8*index+7]=yPos+textureFrame.height*scale,pageMesh.uvs[8*index+0]=textureUvs.x0,pageMesh.uvs[8*index+1]=textureUvs.y0,pageMesh.uvs[8*index+2]=textureUvs.x1,pageMesh.uvs[8*index+3]=textureUvs.y1,pageMesh.uvs[8*index+4]=textureUvs.x2,pageMesh.uvs[8*index+5]=textureUvs.y2,pageMesh.uvs[8*index+6]=textureUvs.x3,pageMesh.uvs[8*index+7]=textureUvs.y3}this._textWidth=maxLineWidth*scale,this._textHeight=(pos.y+data.lineHeight)*scale;for(const i in pagesMeshData){const pageMeshData=pagesMeshData[i];if(0!==this.anchor.x||0!==this.anchor.y){let vertexCount=0;const anchorOffsetX=this._textWidth*this.anchor.x,anchorOffsetY=this._textHeight*this.anchor.y;for(let i2=0;i2<pageMeshData.total;i2++)pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY,pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY,pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY,pageMeshData.vertices[vertexCount++]-=anchorOffsetX,pageMeshData.vertices[vertexCount++]-=anchorOffsetY}this._maxLineHeight=maxLineHeight*scale;const vertexBuffer=pageMeshData.mesh.geometry.getBuffer("aVertexPosition"),textureBuffer=pageMeshData.mesh.geometry.getBuffer("aTextureCoord"),indexBuffer=pageMeshData.mesh.geometry.getIndex();vertexBuffer.data=pageMeshData.vertices,textureBuffer.data=pageMeshData.uvs,indexBuffer.data=pageMeshData.indices,vertexBuffer.update(),textureBuffer.update(),indexBuffer.update()}for(let i=0;i<chars.length;i++)charRenderDataPool.push(chars[i]);this._font=data,this.dirty=!1}updateTransform(){this.validate(),this.containerUpdateTransform()}_render(renderer){this._autoResolution&&this._resolution!==renderer.resolution&&(this._resolution=renderer.resolution,this.dirty=!0);const{distanceFieldRange,distanceFieldType,size}=BitmapFont.available[this._fontName];if("none"!==distanceFieldType){const{a,b,c,d}=this.worldTransform,dx=Math.sqrt(a*a+b*b),dy=Math.sqrt(c*c+d*d),worldScale=(Math.abs(dx)+Math.abs(dy))/2,fontScale=this.fontSize/size,resolution=renderer._view.resolution;for(const mesh of this._activePagesMeshData)mesh.mesh.shader.uniforms.uFWidth=worldScale*distanceFieldRange*fontScale*resolution}super._render(renderer)}getLocalBounds(){return this.validate(),super.getLocalBounds()}validate(){const font=BitmapFont.available[this._fontName];if(!font)throw new Error(`Missing BitmapFont "${this._fontName}"`);this._font!==font&&(this.dirty=!0),this.dirty&&this.updateText()}get tint(){return this._tintColor.value}set tint(value){if(this.tint!==value){this._tintColor.setValue(value);for(let i=0;i<this._activePagesMeshData.length;i++)this._activePagesMeshData[i].mesh.tint=value}}get align(){return this._align}set align(value){this._align!==value&&(this._align=value,this.dirty=!0)}get fontName(){return this._fontName}set fontName(value){if(!BitmapFont.available[value])throw new Error(`Missing BitmapFont "${value}"`);this._fontName!==value&&(this._fontName=value,this.dirty=!0)}get fontSize(){return this._fontSize??BitmapFont.available[this._fontName].size}set fontSize(value){this._fontSize!==value&&(this._fontSize=value,this.dirty=!0)}get anchor(){return this._anchor}set anchor(value){"number"==typeof value?this._anchor.set(value):this._anchor.copyFrom(value)}get text(){return this._text}set text(text){text=String(text??""),this._text!==text&&(this._text=text,this.dirty=!0)}get maxWidth(){return this._maxWidth}set maxWidth(value){this._maxWidth!==value&&(this._maxWidth=value,this.dirty=!0)}get maxLineHeight(){return this.validate(),this._maxLineHeight}get textWidth(){return this.validate(),this._textWidth}get letterSpacing(){return this._letterSpacing}set letterSpacing(value){this._letterSpacing!==value&&(this._letterSpacing=value,this.dirty=!0)}get roundPixels(){return this._roundPixels}set roundPixels(value){value!==this._roundPixels&&(this._roundPixels=value,this.dirty=!0)}get textHeight(){return this.validate(),this._textHeight}get resolution(){return this._resolution}set resolution(value){this._autoResolution=!1,this._resolution!==value&&(this._resolution=value,this.dirty=!0)}destroy(options){const{_textureCache}=this,pageMeshDataPool="none"===BitmapFont.available[this._fontName].distanceFieldType?pageMeshDataDefaultPageMeshData:pageMeshDataMSDFPageMeshData;pageMeshDataPool.push(...this._activePagesMeshData);for(const pageMeshData of this._activePagesMeshData)this.removeChild(pageMeshData.mesh);this._activePagesMeshData=[],pageMeshDataPool.filter((page=>_textureCache[page.mesh.texture.baseTexture.uid])).forEach((page=>{page.mesh.texture=lib.xE.EMPTY}));for(const id in _textureCache)_textureCache[id].destroy(),delete _textureCache[id];this._font=null,this._tintColor=null,this._textureCache=null,super.destroy(options)}};_BitmapText.styleDefaults={align:"left",tint:16777215,maxWidth:0,letterSpacing:0};let BitmapText=_BitmapText;var assets_lib=__webpack_require__("./node_modules/@pixi/assets/lib/index.mjs");const validExtensions=[".xml",".fnt"],loadBitmapFont={extension:{type:lib.nw.LoadParser,priority:assets_lib.Q2.Normal},name:"loadBitmapFont",test:url=>validExtensions.includes(lib.P6.path.extname(url).toLowerCase()),testParse:async data=>TextFormat.test(data)||XMLStringFormat.test(data),async parse(asset,data,loader){const fontData=TextFormat.test(asset)?TextFormat.parse(asset):XMLStringFormat.parse(asset),{src}=data,{page:pages}=fontData,textureUrls=[];for(let i=0;i<pages.length;++i){const pageFile=pages[i].file;let imagePath=lib.P6.path.join(lib.P6.path.dirname(src),pageFile);imagePath=(0,assets_lib.uz)(imagePath,src),textureUrls.push(imagePath)}const loadedTextures=await loader.load(textureUrls),textures=textureUrls.map((url=>loadedTextures[url]));return BitmapFont.install(fontData,textures,!0)},load:async(url,_options)=>(await lib.Xd.ADAPTER.fetch(url)).text(),unload(bitmapFont){bitmapFont.destroy()}};lib.Rw.add(loadBitmapFont)},"./node_modules/@storybook/addon-actions/dist/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{aD:()=>chunk_AY7I2SME.aD});var chunk_AY7I2SME=__webpack_require__("./node_modules/@storybook/addon-actions/dist/chunk-AY7I2SME.mjs")}}]);