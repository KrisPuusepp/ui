"use strict";(self.webpackChunk_pixi_ui=self.webpackChunk_pixi_ui||[]).push([[866],{"./node_modules/@pixi/mesh-extras/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{ZT:()=>NineSlicePlane});var lib=__webpack_require__("./node_modules/@pixi/mesh/lib/index.mjs");class PlaneGeometry extends lib.xc{constructor(width=100,height=100,segWidth=10,segHeight=10){super(),this.segWidth=segWidth,this.segHeight=segHeight,this.width=width,this.height=height,this.build()}build(){const total=this.segWidth*this.segHeight,verts=[],uvs=[],indices=[],segmentsX=this.segWidth-1,segmentsY=this.segHeight-1,sizeX=this.width/segmentsX,sizeY=this.height/segmentsY;for(let i=0;i<total;i++){const x=i%this.segWidth,y=i/this.segWidth|0;verts.push(x*sizeX,y*sizeY),uvs.push(x/segmentsX,y/segmentsY)}const totalSub=segmentsX*segmentsY;for(let i=0;i<totalSub;i++){const xpos=i%segmentsX,ypos=i/segmentsX|0,value=ypos*this.segWidth+xpos,value2=ypos*this.segWidth+xpos+1,value3=(ypos+1)*this.segWidth+xpos,value4=(ypos+1)*this.segWidth+xpos+1;indices.push(value,value2,value3,value2,value4,value3)}this.buffers[0].data=new Float32Array(verts),this.buffers[1].data=new Float32Array(uvs),this.indexBuffer.data=new Uint16Array(indices),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}}var core_lib=__webpack_require__("./node_modules/@pixi/core/lib/index.mjs");class SimplePlane extends lib.Kj{constructor(texture,verticesX,verticesY){super(new PlaneGeometry(texture.width,texture.height,verticesX,verticesY),new lib.rY(core_lib.xE.WHITE)),this.texture=texture,this.autoResize=!0}textureUpdated(){this._textureID=this.shader.texture._updateID;const geometry=this.geometry,{width,height}=this.shader.texture;this.autoResize&&(geometry.width!==width||geometry.height!==height)&&(geometry.width=this.shader.texture.width,geometry.height=this.shader.texture.height,geometry.build())}set texture(value){this.shader.texture!==value&&(this.shader.texture=value,this._textureID=-1,value.baseTexture.valid?this.textureUpdated():value.once("update",this.textureUpdated,this))}get texture(){return this.shader.texture}_render(renderer){this._textureID!==this.shader.texture._updateID&&this.textureUpdated(),super._render(renderer)}destroy(options){this.shader.texture.off("update",this.textureUpdated,this),super.destroy(options)}}class NineSlicePlane extends SimplePlane{constructor(texture,leftWidth,topHeight,rightWidth,bottomHeight){super(core_lib.xE.WHITE,4,4),this._origWidth=texture.orig.width,this._origHeight=texture.orig.height,this._width=this._origWidth,this._height=this._origHeight,this._leftWidth=leftWidth??texture.defaultBorders?.left??10,this._rightWidth=rightWidth??texture.defaultBorders?.right??10,this._topHeight=topHeight??texture.defaultBorders?.top??10,this._bottomHeight=bottomHeight??texture.defaultBorders?.bottom??10,this.texture=texture}textureUpdated(){this._textureID=this.shader.texture._updateID,this._refresh()}get vertices(){return this.geometry.getBuffer("aVertexPosition").data}set vertices(value){this.geometry.getBuffer("aVertexPosition").data=value}updateHorizontalVertices(){const vertices=this.vertices,scale=this._getMinScale();vertices[9]=vertices[11]=vertices[13]=vertices[15]=this._topHeight*scale,vertices[17]=vertices[19]=vertices[21]=vertices[23]=this._height-this._bottomHeight*scale,vertices[25]=vertices[27]=vertices[29]=vertices[31]=this._height}updateVerticalVertices(){const vertices=this.vertices,scale=this._getMinScale();vertices[2]=vertices[10]=vertices[18]=vertices[26]=this._leftWidth*scale,vertices[4]=vertices[12]=vertices[20]=vertices[28]=this._width-this._rightWidth*scale,vertices[6]=vertices[14]=vertices[22]=vertices[30]=this._width}_getMinScale(){const w=this._leftWidth+this._rightWidth,scaleW=this._width>w?1:this._width/w,h=this._topHeight+this._bottomHeight,scaleH=this._height>h?1:this._height/h;return Math.min(scaleW,scaleH)}get width(){return this._width}set width(value){this._width=value,this._refresh()}get height(){return this._height}set height(value){this._height=value,this._refresh()}get leftWidth(){return this._leftWidth}set leftWidth(value){this._leftWidth=value,this._refresh()}get rightWidth(){return this._rightWidth}set rightWidth(value){this._rightWidth=value,this._refresh()}get topHeight(){return this._topHeight}set topHeight(value){this._topHeight=value,this._refresh()}get bottomHeight(){return this._bottomHeight}set bottomHeight(value){this._bottomHeight=value,this._refresh()}_refresh(){const texture=this.texture,uvs=this.geometry.buffers[1].data;this._origWidth=texture.orig.width,this._origHeight=texture.orig.height;const _uvw=1/this._origWidth,_uvh=1/this._origHeight;uvs[0]=uvs[8]=uvs[16]=uvs[24]=0,uvs[1]=uvs[3]=uvs[5]=uvs[7]=0,uvs[6]=uvs[14]=uvs[22]=uvs[30]=1,uvs[25]=uvs[27]=uvs[29]=uvs[31]=1,uvs[2]=uvs[10]=uvs[18]=uvs[26]=_uvw*this._leftWidth,uvs[4]=uvs[12]=uvs[20]=uvs[28]=1-_uvw*this._rightWidth,uvs[9]=uvs[11]=uvs[13]=uvs[15]=_uvh*this._topHeight,uvs[17]=uvs[19]=uvs[21]=uvs[23]=1-_uvh*this._bottomHeight,this.updateHorizontalVertices(),this.updateVerticalVertices(),this.geometry.buffers[0].update(),this.geometry.buffers[1].update()}}},"./node_modules/@pixi/mesh/lib/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Kj:()=>Mesh,xc:()=>MeshGeometry,rY:()=>MeshMaterial});var lib=__webpack_require__("./node_modules/@pixi/core/lib/index.mjs"),display_lib=__webpack_require__("./node_modules/@pixi/display/lib/index.mjs");class MeshBatchUvs{constructor(uvBuffer,uvMatrix){this.uvBuffer=uvBuffer,this.uvMatrix=uvMatrix,this.data=null,this._bufferUpdateId=-1,this._textureUpdateId=-1,this._updateID=0}update(forceUpdate){if(!forceUpdate&&this._bufferUpdateId===this.uvBuffer._updateID&&this._textureUpdateId===this.uvMatrix._updateID)return;this._bufferUpdateId=this.uvBuffer._updateID,this._textureUpdateId=this.uvMatrix._updateID;const data=this.uvBuffer.data;(!this.data||this.data.length!==data.length)&&(this.data=new Float32Array(data.length)),this.uvMatrix.multiplyUvs(data,this.data),this._updateID++}}const tempPoint=new lib.E9,tempPolygon=new lib.mg,_Mesh=class _Mesh2 extends display_lib.W2{constructor(geometry,shader,state,drawMode=lib.lg.TRIANGLES){super(),this.geometry=geometry,this.shader=shader,this.state=state||lib.ZM.for2d(),this.drawMode=drawMode,this.start=0,this.size=0,this.uvs=null,this.indices=null,this.vertexData=new Float32Array(1),this.vertexDirty=-1,this._transformID=-1,this._roundPixels=lib.Xd.ROUND_PIXELS,this.batchUvs=null}get geometry(){return this._geometry}set geometry(value){this._geometry!==value&&(this._geometry&&(this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose()),this._geometry=value,this._geometry&&this._geometry.refCount++,this.vertexDirty=-1)}get uvBuffer(){return this.geometry.buffers[1]}get verticesBuffer(){return this.geometry.buffers[0]}set material(value){this.shader=value}get material(){return this.shader}set blendMode(value){this.state.blendMode=value}get blendMode(){return this.state.blendMode}set roundPixels(value){this._roundPixels!==value&&(this._transformID=-1),this._roundPixels=value}get roundPixels(){return this._roundPixels}get tint(){return"tint"in this.shader?this.shader.tint:null}set tint(value){this.shader.tint=value}get tintValue(){return this.shader.tintValue}get texture(){return"texture"in this.shader?this.shader.texture:null}set texture(value){this.shader.texture=value}_render(renderer){const vertices=this.geometry.buffers[0].data;this.shader.batchable&&this.drawMode===lib.lg.TRIANGLES&&vertices.length<2*_Mesh2.BATCHABLE_SIZE?this._renderToBatch(renderer):this._renderDefault(renderer)}_renderDefault(renderer){const shader=this.shader;shader.alpha=this.worldAlpha,shader.update&&shader.update(),renderer.batch.flush(),shader.uniforms.translationMatrix=this.transform.worldTransform.toArray(!0),renderer.shader.bind(shader),renderer.state.set(this.state),renderer.geometry.bind(this.geometry,shader),renderer.geometry.draw(this.drawMode,this.size,this.start,this.geometry.instanceCount)}_renderToBatch(renderer){const geometry=this.geometry,shader=this.shader;shader.uvMatrix&&(shader.uvMatrix.update(),this.calculateUvs()),this.calculateVertices(),this.indices=geometry.indexBuffer.data,this._tintRGB=shader._tintRGB,this._texture=shader.texture;const pluginName=this.material.pluginName;renderer.batch.setObjectRenderer(renderer.plugins[pluginName]),renderer.plugins[pluginName].render(this)}calculateVertices(){const verticesBuffer=this.geometry.buffers[0],vertices=verticesBuffer.data,vertexDirtyId=verticesBuffer._updateID;if(vertexDirtyId===this.vertexDirty&&this._transformID===this.transform._worldID)return;this._transformID=this.transform._worldID,this.vertexData.length!==vertices.length&&(this.vertexData=new Float32Array(vertices.length));const wt=this.transform.worldTransform,a=wt.a,b=wt.b,c=wt.c,d=wt.d,tx=wt.tx,ty=wt.ty,vertexData=this.vertexData;for(let i=0;i<vertexData.length/2;i++){const x=vertices[2*i],y=vertices[2*i+1];vertexData[2*i]=a*x+c*y+tx,vertexData[2*i+1]=b*x+d*y+ty}if(this._roundPixels){const resolution=lib.Xd.RESOLUTION;for(let i=0;i<vertexData.length;++i)vertexData[i]=Math.round(vertexData[i]*resolution)/resolution}this.vertexDirty=vertexDirtyId}calculateUvs(){const geomUvs=this.geometry.buffers[1],shader=this.shader;shader.uvMatrix.isSimple?this.uvs=geomUvs.data:(this.batchUvs||(this.batchUvs=new MeshBatchUvs(geomUvs,shader.uvMatrix)),this.batchUvs.update(),this.uvs=this.batchUvs.data)}_calculateBounds(){this.calculateVertices(),this._bounds.addVertexData(this.vertexData,0,this.vertexData.length)}containsPoint(point){if(!this.getBounds().contains(point.x,point.y))return!1;this.worldTransform.applyInverse(point,tempPoint);const vertices=this.geometry.getBuffer("aVertexPosition").data,points=tempPolygon.points,indices=this.geometry.getIndex().data,len=indices.length,step=4===this.drawMode?3:1;for(let i=0;i+2<len;i+=step){const ind0=2*indices[i],ind1=2*indices[i+1],ind2=2*indices[i+2];if(points[0]=vertices[ind0],points[1]=vertices[ind0+1],points[2]=vertices[ind1],points[3]=vertices[ind1+1],points[4]=vertices[ind2],points[5]=vertices[ind2+1],tempPolygon.contains(tempPoint.x,tempPoint.y))return!0}return!1}destroy(options){super.destroy(options),this._cachedTexture&&(this._cachedTexture.destroy(),this._cachedTexture=null),this.geometry=null,this.shader=null,this.state=null,this.uvs=null,this.indices=null,this.vertexData=null}};_Mesh.BATCHABLE_SIZE=100;let Mesh=_Mesh;class MeshGeometry extends lib.wG{constructor(vertices,uvs,index){super();const verticesBuffer=new lib.lW(vertices),uvsBuffer=new lib.lW(uvs,!0),indexBuffer=new lib.lW(index,!0,!0);this.addAttribute("aVertexPosition",verticesBuffer,2,!1,lib.vK.FLOAT).addAttribute("aTextureCoord",uvsBuffer,2,!1,lib.vK.FLOAT).addIndex(indexBuffer),this._updateId=-1}get vertexDirtyId(){return this.buffers[0]._updateID}}class MeshMaterial extends lib.ex{constructor(uSampler,options){const uniforms={uSampler,alpha:1,uTextureMatrix:lib.y3.IDENTITY,uColor:new Float32Array([1,1,1,1])};(options=Object.assign({tint:16777215,alpha:1,pluginName:"batch"},options)).uniforms&&Object.assign(uniforms,options.uniforms),super(options.program||lib.$r.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"),uniforms),this._colorDirty=!1,this.uvMatrix=new lib.UX(uSampler),this.batchable=void 0===options.program,this.pluginName=options.pluginName,this._tintColor=new lib.Il(options.tint),this._tintRGB=this._tintColor.toLittleEndianNumber(),this._colorDirty=!0,this.alpha=options.alpha}get texture(){return this.uniforms.uSampler}set texture(value){this.uniforms.uSampler!==value&&(!this.uniforms.uSampler.baseTexture.alphaMode!=!value.baseTexture.alphaMode&&(this._colorDirty=!0),this.uniforms.uSampler=value,this.uvMatrix.texture=value)}set alpha(value){value!==this._alpha&&(this._alpha=value,this._colorDirty=!0)}get alpha(){return this._alpha}set tint(value){value!==this.tint&&(this._tintColor.setValue(value),this._tintRGB=this._tintColor.toLittleEndianNumber(),this._colorDirty=!0)}get tint(){return this._tintColor.value}get tintValue(){return this._tintColor.toNumber()}update(){if(this._colorDirty){this._colorDirty=!1;const applyToChannels=this.texture.baseTexture.alphaMode;lib.Il.shared.setValue(this._tintColor).premultiply(this._alpha,applyToChannels).toArray(this.uniforms.uColor)}this.uvMatrix.update()&&(this.uniforms.uTextureMatrix=this.uvMatrix.mapCoord)}}}}]);